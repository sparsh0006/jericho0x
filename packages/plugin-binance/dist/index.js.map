{"version":3,"sources":["../src/actions/priceCheck.ts","../src/services/base.ts","../src/constants/api.ts","../src/constants/errors.ts","../src/types/internal/error.ts","../src/services/account.ts","../src/constants/defaults.ts","../src/services/price.ts","../src/services/trade.ts","../src/services/index.ts","../src/actions/spotBalance.ts","../src/environment.ts","../src/actions/spotTrade.ts","../src/types.ts","../src/index.ts"],"sourcesContent":["import {\r\n    ActionExample,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateObjectDeprecated,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    type Action,\r\n} from \"@elizaos/core\";\r\nimport { BinanceService } from \"../services\";\r\n\r\nconst priceCheckTemplate = `Look at ONLY your LAST RESPONSE message in this conversation, where you just said which cryptocurrency price you would check.\r\nBased on ONLY that last message, provide the trading symbol.\r\n\r\nFor example:\r\n- If your last message was \"I'll check the current Ethereum price...\" -> return \"ETH\"\r\n- If your last message was \"I'll check the current Solana price...\" -> return \"SOL\"\r\n- If your last message was \"I'll check the current Bitcoin price...\" -> return \"BTC\"\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"symbol\": \"<symbol from your LAST response only>\",\r\n    \"quoteCurrency\": \"<quote currency from your LAST response, or USDT if none mentioned>\"\r\n}\r\n\\`\\`\\`\r\n\r\nLast part of conversation:\r\n{{recentMessages}}`;\r\n\r\nexport const priceCheck: Action = {\r\n    name: \"GET_PRICE\",\r\n    similes: [\r\n        \"CHECK_PRICE\",\r\n        \"PRICE_CHECK\",\r\n        \"GET_CRYPTO_PRICE\",\r\n        \"CRYPTO_PRICE\",\r\n        \"CHECK_CRYPTO_PRICE\",\r\n        \"PRICE_LOOKUP\",\r\n        \"CURRENT_PRICE\",\r\n    ],\r\n    description: \"Get current price information for a cryptocurrency pair\",\r\n    validate: async () => true, // Public endpoint\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ): Promise<boolean> => {\r\n        try {\r\n            // Initialize or update state\r\n            state = !state\r\n                ? await runtime.composeState(message)\r\n                : await runtime.updateRecentMessageState(state);\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template: priceCheckTemplate,\r\n            });\r\n\r\n            const rawContent = await generateObjectDeprecated({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            if (!rawContent?.symbol) {\r\n                throw new Error(\r\n                    \"Could not determine which cryptocurrency to check\"\r\n                );\r\n            }\r\n\r\n            // Ensure the content has the required shape\r\n            const content = {\r\n                symbol: rawContent.symbol.toString().toUpperCase().trim(),\r\n                quoteCurrency: (rawContent.quoteCurrency || \"USDT\")\r\n                    .toString()\r\n                    .toUpperCase()\r\n                    .trim(),\r\n            };\r\n\r\n            if (content.symbol.length < 2 || content.symbol.length > 10) {\r\n                throw new Error(\"Invalid cryptocurrency symbol\");\r\n            }\r\n\r\n            const binanceService = new BinanceService();\r\n            const priceData = await binanceService.getPrice(content);\r\n\r\n            if (callback) {\r\n                callback({\r\n                    text: `The current ${content.symbol} price is ${BinanceService.formatPrice(priceData.price)} ${content.quoteCurrency}`,\r\n                    content: priceData,\r\n                });\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in price check:\", error);\r\n            if (callback) {\r\n                const errorMessage = error.message.includes(\"Invalid API key\")\r\n                    ? \"Unable to connect to Binance API\"\r\n                    : error.message.includes(\"Invalid symbol\")\r\n                      ? `Sorry, could not find price for the cryptocurrency symbol you provided`\r\n                      : `Sorry, I encountered an error: ${error.message}`;\r\n\r\n                callback({\r\n                    text: errorMessage,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"What's the current price of Bitcoin?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll check the current Bitcoin price for you right away.\",\r\n                    action: \"GET_PRICE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"The current BTC price is 42,150.25 USDT\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you check ETH price in EUR?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll fetch the current Ethereum price in euros for you.\",\r\n                    action: \"GET_PRICE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"The current ETH price is 2,245.80 EUR\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","import { Spot } from \"@binance/connector\";\r\nimport { elizaLogger } from \"@elizaos/core\";\r\nimport { API_DEFAULTS } from \"../constants/api\";\r\nimport { ERROR_MESSAGES } from \"../constants/errors\";\r\nimport { BinanceConfig, ServiceOptions } from \"../types/internal/config\";\r\nimport {\r\n    ApiError,\r\n    AuthenticationError,\r\n    BinanceError,\r\n    InvalidSymbolError,\r\n    MinNotionalError,\r\n} from \"../types/internal/error\";\r\n\r\n/**\r\n * Base service class with common functionality\r\n */\r\nexport abstract class BaseService {\r\n    protected client: Spot;\r\n    protected config: BinanceConfig;\r\n\r\n    constructor(config?: BinanceConfig) {\r\n        this.config = {\r\n            baseURL: API_DEFAULTS.BASE_URL,\r\n            timeout: API_DEFAULTS.TIMEOUT,\r\n            ...config,\r\n        };\r\n\r\n        this.client = new Spot(this.config.apiKey, this.config.secretKey, {\r\n            baseURL: this.config.baseURL,\r\n            timeout: this.config.timeout,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles common error scenarios and transforms them into appropriate error types\r\n     */\r\n    protected handleError(error: unknown, context?: string): never {\r\n        if (error instanceof BinanceError) {\r\n            throw error;\r\n        }\r\n\r\n        const apiError = error as any;\r\n        const errorResponse = apiError.response?.data;\r\n        const errorCode = errorResponse?.code || apiError.code;\r\n        const errorMessage = errorResponse?.msg || apiError.message;\r\n\r\n        // Handle authentication errors\r\n        if (apiError.response?.status === 401) {\r\n            throw new AuthenticationError(ERROR_MESSAGES.INVALID_CREDENTIALS);\r\n        }\r\n\r\n        // Handle minimum notional errors\r\n        if (errorCode === -1013 && errorMessage?.includes(\"NOTIONAL\")) {\r\n            throw new MinNotionalError();\r\n        }\r\n\r\n        // Handle invalid symbol errors\r\n        if (errorMessage?.includes(\"Invalid symbol\")) {\r\n            throw new InvalidSymbolError(context || \"Unknown\");\r\n        }\r\n\r\n        // Log unexpected errors for debugging\r\n        elizaLogger.error(\"Unexpected API error:\", {\r\n            context,\r\n            code: errorCode,\r\n            message: errorMessage,\r\n            response: errorResponse,\r\n        });\r\n\r\n        throw new ApiError(\r\n            errorMessage || \"An unexpected error occurred\",\r\n            errorCode || 500,\r\n            errorResponse\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validates required API credentials\r\n     */\r\n    protected validateCredentials(): void {\r\n        if (!this.config.apiKey || !this.config.secretKey) {\r\n            throw new AuthenticationError(\"API credentials are required\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merges default options with provided options\r\n     */\r\n    protected mergeOptions(options?: ServiceOptions): ServiceOptions {\r\n        return {\r\n            timeout: this.config.timeout,\r\n            ...options,\r\n        };\r\n    }\r\n}\r\n","export const API_DEFAULTS = {\r\n    BASE_URL: \"https://api.binance.com\",\r\n    TIMEOUT: 30000, // 30 seconds\r\n    RATE_LIMIT: {\r\n        MAX_REQUESTS_PER_MINUTE: 1200,\r\n        WEIGHT_PER_REQUEST: 1,\r\n    },\r\n};\r\n\r\nexport const API_ENDPOINTS = {\r\n    TICKER: \"/api/v3/ticker/price\",\r\n    ACCOUNT: \"/api/v3/account\",\r\n    ORDER: \"/api/v3/order\",\r\n    EXCHANGE_INFO: \"/api/v3/exchangeInfo\",\r\n};\r\n\r\nexport const ORDER_TYPES = {\r\n    MARKET: \"MARKET\",\r\n    LIMIT: \"LIMIT\",\r\n} as const;\r\n\r\nexport const ORDER_SIDES = {\r\n    BUY: \"BUY\",\r\n    SELL: \"SELL\",\r\n} as const;\r\n\r\nexport const TIME_IN_FORCE = {\r\n    GTC: \"GTC\", // Good Till Cancel\r\n    IOC: \"IOC\", // Immediate or Cancel\r\n    FOK: \"FOK\", // Fill or Kill\r\n} as const;\r\n","export const ERROR_CODES = {\r\n    INVALID_CREDENTIALS: 401,\r\n    INVALID_PARAMETERS: 400,\r\n    INSUFFICIENT_BALANCE: -1012,\r\n    MIN_NOTIONAL_NOT_MET: -1013,\r\n    UNKNOWN_ORDER_COMPOSITION: -1111,\r\n    PRICE_QTY_EXCEED_HARD_LIMITS: -1021,\r\n} as const;\r\n\r\nexport const ERROR_MESSAGES = {\r\n    INVALID_CREDENTIALS:\r\n        \"Invalid API credentials. Please check your API key and secret.\",\r\n    INVALID_SYMBOL: \"Invalid trading pair symbol\",\r\n    SYMBOL_NOT_FOUND: (symbol: string) =>\r\n        `Trading pair ${symbol} is not available`,\r\n    MIN_NOTIONAL_NOT_MET: (minNotional?: string) =>\r\n        `Order value is too small. Please increase the quantity to meet the minimum order value requirement.${\r\n            minNotional ? ` Minimum order value is ${minNotional} USDC.` : \"\"\r\n        }`,\r\n    LIMIT_ORDER_PRICE_REQUIRED: \"Price is required for LIMIT orders\",\r\n    BALANCE_FETCH_ERROR: (asset?: string) =>\r\n        asset\r\n            ? `Failed to fetch balance for ${asset}`\r\n            : \"Failed to fetch account balances\",\r\n    PRICE_FETCH_ERROR: (symbol: string) =>\r\n        `Failed to fetch price for ${symbol}`,\r\n} as const;\r\n\r\nexport const VALIDATION_ERRORS = {\r\n    MISSING_API_KEY: \"BINANCE_API_KEY is required but not configured\",\r\n    MISSING_SECRET_KEY: \"BINANCE_SECRET_KEY is required but not configured\",\r\n    INVALID_SYMBOL_LENGTH: \"Invalid cryptocurrency symbol length\",\r\n} as const;\r\n","import { ERROR_CODES } from \"../../constants/errors\";\r\n\r\ntype ErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];\r\n\r\n/**\r\n * Base error class for Binance-related errors\r\n */\r\nexport class BinanceError extends Error {\r\n    public readonly code: ErrorCode | number;\r\n    public readonly originalError?: unknown;\r\n\r\n    constructor(\r\n        message: string,\r\n        code: ErrorCode | number = ERROR_CODES.INVALID_PARAMETERS,\r\n        originalError?: unknown\r\n    ) {\r\n        super(message);\r\n        this.name = \"BinanceError\";\r\n        this.code = code;\r\n        this.originalError = originalError;\r\n\r\n        // Maintains proper stack trace for where error was thrown\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, BinanceError);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Error thrown when API credentials are invalid or missing\r\n */\r\nexport class AuthenticationError extends BinanceError {\r\n    constructor(message = \"Invalid API credentials\") {\r\n        super(message, ERROR_CODES.INVALID_CREDENTIALS);\r\n        this.name = \"AuthenticationError\";\r\n    }\r\n}\r\n\r\n/**\r\n * Error thrown when order validation fails\r\n */\r\nexport class OrderValidationError extends BinanceError {\r\n    constructor(\r\n        message: string,\r\n        code: ErrorCode | number = ERROR_CODES.INVALID_PARAMETERS\r\n    ) {\r\n        super(message, code);\r\n        this.name = \"OrderValidationError\";\r\n    }\r\n}\r\n\r\n/**\r\n * Error thrown when minimum notional value is not met\r\n */\r\nexport class MinNotionalError extends OrderValidationError {\r\n    constructor(minNotional?: string) {\r\n        super(\r\n            `Order value is too small. ${\r\n                minNotional ? `Minimum order value is ${minNotional} USDC.` : \"\"\r\n            }`,\r\n            ERROR_CODES.MIN_NOTIONAL_NOT_MET\r\n        );\r\n        this.name = \"MinNotionalError\";\r\n    }\r\n}\r\n\r\n/**\r\n * Error thrown when insufficient balance\r\n */\r\nexport class InsufficientBalanceError extends OrderValidationError {\r\n    constructor(asset: string) {\r\n        super(\r\n            `Insufficient ${asset} balance`,\r\n            ERROR_CODES.INSUFFICIENT_BALANCE\r\n        );\r\n        this.name = \"InsufficientBalanceError\";\r\n    }\r\n}\r\n\r\n/**\r\n * Error thrown when symbol is invalid\r\n */\r\nexport class InvalidSymbolError extends BinanceError {\r\n    constructor(symbol: string) {\r\n        super(\r\n            `Trading pair ${symbol} is not available`,\r\n            ERROR_CODES.INVALID_PARAMETERS\r\n        );\r\n        this.name = \"InvalidSymbolError\";\r\n    }\r\n}\r\n\r\n/**\r\n * Error thrown when API request fails\r\n */\r\nexport class ApiError extends BinanceError {\r\n    constructor(\r\n        message: string,\r\n        code: number,\r\n        public readonly response?: unknown\r\n    ) {\r\n        super(message, code);\r\n        this.name = \"ApiError\";\r\n    }\r\n}\r\n","import { BinanceAccountInfo, BinanceBalance } from \"../types/api/account\";\r\nimport { BalanceCheckRequest, BalanceResponse } from \"../types/internal/config\";\r\nimport { BaseService } from \"./base\";\r\n\r\n/**\r\n * Service for handling account-related operations\r\n */\r\nexport class AccountService extends BaseService {\r\n    /**\r\n     * Get account balance for all assets or a specific asset\r\n     */\r\n    async getBalance(request: BalanceCheckRequest): Promise<BalanceResponse> {\r\n        try {\r\n            this.validateCredentials();\r\n\r\n            const response = await this.client.account();\r\n            const accountInfo = response.data as BinanceAccountInfo;\r\n\r\n            let balances = this.filterNonZeroBalances(accountInfo.balances);\r\n\r\n            if (request.asset) {\r\n                balances = this.filterByAsset(balances, request.asset);\r\n            }\r\n\r\n            return {\r\n                balances,\r\n                timestamp: Date.now(),\r\n            };\r\n        } catch (error) {\r\n            throw this.handleError(\r\n                error,\r\n                request.asset ? `Asset: ${request.asset}` : \"All assets\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Filter out zero balances\r\n     */\r\n    private filterNonZeroBalances(\r\n        balances: BinanceBalance[]\r\n    ): BinanceBalance[] {\r\n        return balances.filter(\r\n            (balance) =>\r\n                parseFloat(balance.free) > 0 || parseFloat(balance.locked) > 0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Filter balances by asset\r\n     */\r\n    private filterByAsset(\r\n        balances: BinanceBalance[],\r\n        asset: string\r\n    ): BinanceBalance[] {\r\n        return balances.filter(\r\n            (b) => b.asset.toUpperCase() === asset.toUpperCase()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get account trading status\r\n     */\r\n    async getTradingStatus(): Promise<boolean> {\r\n        try {\r\n            this.validateCredentials();\r\n            const response = await this.client.account();\r\n            const accountInfo = response.data as BinanceAccountInfo;\r\n            return accountInfo.canTrade;\r\n        } catch (error) {\r\n            throw this.handleError(error, \"Trading status check\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if account has sufficient balance for a trade\r\n     */\r\n    async checkBalance(asset: string, required: number): Promise<boolean> {\r\n        try {\r\n            const { balances } = await this.getBalance({ asset });\r\n            const balance = balances[0];\r\n\r\n            if (!balance) {\r\n                return false;\r\n            }\r\n\r\n            const available = parseFloat(balance.free);\r\n            return available >= required;\r\n        } catch (error) {\r\n            throw this.handleError(error, `Balance check for ${asset}`);\r\n        }\r\n    }\r\n}\r\n","export const TRADE_DEFAULTS = {\r\n    QUOTE_CURRENCY: \"USDT\",\r\n    TIME_IN_FORCE: \"GTC\",\r\n    ORDER_TYPE: \"MARKET\",\r\n    PRICE_PRECISION: 8,\r\n    QUANTITY_PRECISION: 8,\r\n};\r\n\r\nexport const DISPLAY_DEFAULTS = {\r\n    PRICE_FORMAT: {\r\n        MIN_FRACTION_DIGITS: 2,\r\n        MAX_FRACTION_DIGITS: 8,\r\n        LOCALE: \"en-US\",\r\n    },\r\n};\r\n\r\nexport const VALIDATION = {\r\n    SYMBOL: {\r\n        MIN_LENGTH: 2,\r\n        MAX_LENGTH: 10,\r\n    },\r\n};\r\n","import { VALIDATION } from \"../constants/defaults\";\r\nimport { ERROR_MESSAGES } from \"../constants/errors\";\r\nimport { BinanceTickerResponse } from \"../types/api/price\";\r\nimport { PriceCheckRequest, PriceResponse } from \"../types/internal/config\";\r\nimport { BinanceError } from \"../types/internal/error\";\r\nimport { BaseService } from \"./base\";\r\n\r\n/**\r\n * Service for handling price-related operations\r\n */\r\nexport class PriceService extends BaseService {\r\n    /**\r\n     * Get current price for a symbol\r\n     */\r\n    async getPrice(request: PriceCheckRequest): Promise<PriceResponse> {\r\n        try {\r\n            this.validateSymbol(request.symbol);\r\n\r\n            const symbol = `${request.symbol}${request.quoteCurrency}`;\r\n            const response = await this.client.tickerPrice(symbol);\r\n            const data = response.data as BinanceTickerResponse;\r\n\r\n            return {\r\n                symbol,\r\n                price: data.price,\r\n                timestamp: Date.now(),\r\n            };\r\n        } catch (error) {\r\n            throw this.handleError(error, request.symbol);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates symbol format\r\n     */\r\n    private validateSymbol(symbol: string): void {\r\n        const trimmedSymbol = symbol.trim();\r\n        if (\r\n            trimmedSymbol.length < VALIDATION.SYMBOL.MIN_LENGTH ||\r\n            trimmedSymbol.length > VALIDATION.SYMBOL.MAX_LENGTH\r\n        ) {\r\n            throw new BinanceError(ERROR_MESSAGES.INVALID_SYMBOL);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Format price for display\r\n     */\r\n    static formatPrice(price: number | string): string {\r\n        const numPrice = typeof price === \"string\" ? parseFloat(price) : price;\r\n        return new Intl.NumberFormat(\"en-US\", {\r\n            style: \"decimal\",\r\n            minimumFractionDigits: 2,\r\n            maximumFractionDigits: 8,\r\n        }).format(numPrice);\r\n    }\r\n}\r\n","import { ORDER_TYPES, TIME_IN_FORCE } from \"../constants/api\";\r\nimport { ERROR_MESSAGES } from \"../constants/errors\";\r\nimport {\r\n    BinanceExchangeInfo,\r\n    BinanceSymbolFilter,\r\n    BinanceSymbolInfo,\r\n} from \"../types/api/price\";\r\nimport {\r\n    BinanceNewOrderParams,\r\n    BinanceOrderResponse,\r\n} from \"../types/api/trade\";\r\nimport { SpotTradeRequest, TradeResponse } from \"../types/internal/config\";\r\nimport { InvalidSymbolError, MinNotionalError } from \"../types/internal/error\";\r\nimport { BaseService } from \"./base\";\r\n\r\n/**\r\n * Service for handling trading operations\r\n */\r\nexport class TradeService extends BaseService {\r\n    /**\r\n     * Execute a spot trade\r\n     */\r\n    async executeTrade(request: SpotTradeRequest): Promise<TradeResponse> {\r\n        try {\r\n            this.validateCredentials();\r\n            await this.validateSymbol(request.symbol);\r\n\r\n            const orderParams = this.buildOrderParams(request);\r\n            const response = await this.client.newOrder(\r\n                orderParams.symbol,\r\n                orderParams.side,\r\n                orderParams.type,\r\n                orderParams\r\n            );\r\n\r\n            const data = response.data as BinanceOrderResponse;\r\n            return {\r\n                symbol: data.symbol,\r\n                orderId: data.orderId,\r\n                status: data.status,\r\n                executedQty: data.executedQty,\r\n                cummulativeQuoteQty: data.cummulativeQuoteQty,\r\n                price: data.price,\r\n                type: data.type,\r\n                side: data.side,\r\n            };\r\n        } catch (error) {\r\n            throw this.handleError(error, request.symbol);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate trading pair and get symbol information\r\n     */\r\n    private async validateSymbol(symbol: string): Promise<BinanceSymbolInfo> {\r\n        const exchangeInfo = await this.client.exchangeInfo();\r\n        const data = exchangeInfo.data as BinanceExchangeInfo;\r\n\r\n        const symbolInfo = data.symbols.find((s) => s.symbol === symbol);\r\n        if (!symbolInfo) {\r\n            throw new InvalidSymbolError(symbol);\r\n        }\r\n\r\n        return symbolInfo;\r\n    }\r\n\r\n    /**\r\n     * Build order parameters for the Binance API\r\n     */\r\n    private buildOrderParams(request: SpotTradeRequest): BinanceNewOrderParams {\r\n        const params: BinanceNewOrderParams = {\r\n            symbol: request.symbol.toUpperCase(),\r\n            side: request.side,\r\n            type: request.type,\r\n            quantity: request.quantity.toString(),\r\n        };\r\n\r\n        if (request.type === ORDER_TYPES.LIMIT) {\r\n            if (!request.price) {\r\n                throw new Error(ERROR_MESSAGES.LIMIT_ORDER_PRICE_REQUIRED);\r\n            }\r\n            params.timeInForce = request.timeInForce || TIME_IN_FORCE.GTC;\r\n            params.price = request.price.toString();\r\n        }\r\n\r\n        return params;\r\n    }\r\n\r\n    /**\r\n     * Get minimum notional value from symbol filters\r\n     */\r\n    private getMinNotional(filters: BinanceSymbolFilter[]): string | undefined {\r\n        const notionalFilter = filters.find((f) => f.filterType === \"NOTIONAL\");\r\n        return notionalFilter?.minNotional;\r\n    }\r\n\r\n    /**\r\n     * Check if order meets minimum notional value\r\n     */\r\n    private checkMinNotional(\r\n        symbolInfo: BinanceSymbolInfo,\r\n        quantity: number,\r\n        price?: number\r\n    ): void {\r\n        const minNotional = this.getMinNotional(symbolInfo.filters);\r\n        if (!minNotional) return;\r\n\r\n        const notionalValue = price ? quantity * price : quantity; // For market orders, quantity is in quote currency\r\n\r\n        if (parseFloat(minNotional) > notionalValue) {\r\n            throw new MinNotionalError(minNotional);\r\n        }\r\n    }\r\n}\r\n","import { BinanceConfig } from \"../types/internal/config\";\r\nimport { AccountService } from \"./account\";\r\nimport { PriceService } from \"./price\";\r\nimport { TradeService } from \"./trade\";\r\n\r\n/**\r\n * Main service facade that coordinates between specialized services\r\n */\r\nexport class BinanceService {\r\n    private priceService: PriceService;\r\n    private tradeService: TradeService;\r\n    private accountService: AccountService;\r\n\r\n    constructor(config?: BinanceConfig) {\r\n        this.priceService = new PriceService(config);\r\n        this.tradeService = new TradeService(config);\r\n        this.accountService = new AccountService(config);\r\n    }\r\n\r\n    /**\r\n     * Price-related operations\r\n     */\r\n    async getPrice(...args: Parameters<PriceService[\"getPrice\"]>) {\r\n        return this.priceService.getPrice(...args);\r\n    }\r\n\r\n    static formatPrice = PriceService.formatPrice;\r\n\r\n    /**\r\n     * Trading operations\r\n     */\r\n    async executeTrade(...args: Parameters<TradeService[\"executeTrade\"]>) {\r\n        return this.tradeService.executeTrade(...args);\r\n    }\r\n\r\n    /**\r\n     * Account operations\r\n     */\r\n    async getBalance(...args: Parameters<AccountService[\"getBalance\"]>) {\r\n        return this.accountService.getBalance(...args);\r\n    }\r\n\r\n    async getTradingStatus() {\r\n        return this.accountService.getTradingStatus();\r\n    }\r\n\r\n    async checkBalance(...args: Parameters<AccountService[\"checkBalance\"]>) {\r\n        return this.accountService.checkBalance(...args);\r\n    }\r\n}\r\n\r\nexport { AccountService, PriceService, TradeService };\r\n","import {\r\n    ActionExample,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateObjectDeprecated,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    type Action,\r\n} from \"@elizaos/core\";\r\nimport { validateBinanceConfig } from \"../environment\";\r\nimport { BinanceService } from \"../services\";\r\nimport { BalanceCheckRequest } from \"../types\";\r\n\r\nconst spotBalanceTemplate = `Look at ONLY your LAST RESPONSE message in this conversation, where you just confirmed which cryptocurrency balance to check.\r\nBased on ONLY that last message, extract the cryptocurrency symbol.\r\n\r\nFor example:\r\n- If your last message was \"I'll fetch your Solana wallet balance...\" -> return \"SOL\"\r\n- If your last message was \"I'll check your BTC balance...\" -> return \"BTC\"\r\n- If your last message was \"I'll get your ETH balance...\" -> return \"ETH\"\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"asset\": \"<symbol from your LAST response only>\"\r\n}\r\n\\`\\`\\`\r\n\r\nLast part of conversation:\r\n{{recentMessages}}`;\r\n\r\nexport const spotBalance: Action = {\r\n    name: \"GET_SPOT_BALANCE\",\r\n    similes: [\r\n        \"CHECK_BALANCE\",\r\n        \"BALANCE_CHECK\",\r\n        \"GET_WALLET_BALANCE\",\r\n        \"WALLET_BALANCE\",\r\n        \"CHECK_WALLET\",\r\n        \"VIEW_BALANCE\",\r\n        \"SHOW_BALANCE\",\r\n    ],\r\n    description: \"Get current spot wallet balance for one or all assets\",\r\n    validate: async (runtime: IAgentRuntime) => {\r\n        try {\r\n            await validateBinanceConfig(runtime);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: { [key: string]: unknown },\r\n        callback?: HandlerCallback\r\n    ): Promise<boolean> => {\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n\r\n        const balanceContext = composeContext({\r\n            state,\r\n            template: spotBalanceTemplate,\r\n        });\r\n\r\n        const content = (await generateObjectDeprecated({\r\n            runtime,\r\n            context: balanceContext,\r\n            modelClass: ModelClass.SMALL,\r\n        })) as BalanceCheckRequest;\r\n\r\n        try {\r\n            const binanceService = new BinanceService({\r\n                apiKey: runtime.getSetting(\"BINANCE_API_KEY\"),\r\n                secretKey: runtime.getSetting(\"BINANCE_SECRET_KEY\"),\r\n            });\r\n\r\n            const balanceData = await binanceService.getBalance(content);\r\n\r\n            if (content.asset) {\r\n                const assetBalance = balanceData.balances[0];\r\n                if (assetBalance) {\r\n                    if (callback) {\r\n                        callback({\r\n                            text: `${content.asset} Balance:\\nAvailable: ${assetBalance.free}\\nLocked: ${assetBalance.locked}`,\r\n                            content: assetBalance,\r\n                        });\r\n                    }\r\n                } else {\r\n                    if (callback) {\r\n                        callback({\r\n                            text: `No balance found for ${content.asset}`,\r\n                            content: { error: \"Asset not found\" },\r\n                        });\r\n                    }\r\n                }\r\n            } else {\r\n                const balanceText = balanceData.balances\r\n                    .map(\r\n                        (b) =>\r\n                            `${b.asset}: Available: ${b.free}, Locked: ${b.locked}`\r\n                    )\r\n                    .join(\"\\n\");\r\n\r\n                if (callback) {\r\n                    callback({\r\n                        text: `Spot Wallet Balances:\\n${balanceText}`,\r\n                        content: balanceData.balances,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in balance check:\", {\r\n                message: error.message,\r\n                code: error.code,\r\n            });\r\n            if (callback) {\r\n                callback({\r\n                    text: error.message,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"What's my current Bitcoin balance?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll check your BTC balance for you.\",\r\n                    action: \"GET_SPOT_BALANCE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"BTC Balance:\\nAvailable: 0.5\\nLocked: 0.1\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Show me all my wallet balances\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll fetch all your spot wallet balances.\",\r\n                    action: \"GET_SPOT_BALANCE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"Spot Wallet Balances:\\nBTC: Available: 0.5, Locked: 0.1\\nETH: Available: 2.0, Locked: 0.0\\nUSDT: Available: 1000.0, Locked: 0.0\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","import { IAgentRuntime } from \"@elizaos/core\";\r\nimport { z } from \"zod\";\r\n\r\nexport const binanceEnvSchema = z.object({\r\n    BINANCE_API_KEY: z.string().min(1, \"Binance API key is required\"),\r\n    BINANCE_SECRET_KEY: z.string().min(1, \"Binance secret key is required\"),\r\n});\r\n\r\nexport type BinanceConfig = z.infer<typeof binanceEnvSchema>;\r\n\r\nexport async function validateBinanceConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<BinanceConfig> {\r\n    try {\r\n        const config = {\r\n            BINANCE_API_KEY: runtime.getSetting(\"BINANCE_API_KEY\"),\r\n            BINANCE_SECRET_KEY: runtime.getSetting(\"BINANCE_SECRET_KEY\"),\r\n        };\r\n\r\n        return binanceEnvSchema.parse(config);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `Binance configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n","import {\r\n    ActionExample,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateObjectDeprecated,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    type Action,\r\n} from \"@elizaos/core\";\r\nimport { BinanceService } from \"../services\";\r\nimport { SpotTradeSchema } from \"../types\";\r\n\r\nconst spotTradeTemplate = `Look at your LAST RESPONSE in the conversation where you confirmed a trade/swap request.\r\nBased on ONLY that last message, extract the trading details:\r\n\r\nTrading pairs on Binance must include USDT or BUSD or USDC. For example:\r\n- For \"swap SOL for USDC\" -> use \"SOLUSDC\" as symbol\r\n- For \"swap ETH for USDT\" -> use \"ETHUSDT\" as symbol\r\n- For \"buy BTC with USDT\" -> use \"BTCUSDT\" as symbol\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"symbol\": \"<pair with stable coin>\",\r\n    \"side\": \"SELL\",\r\n    \"type\": \"MARKET\",\r\n    \"quantity\": \"<amount from your last response>\"\r\n}\r\n\\`\\`\\`\r\n\r\nRecent conversation:\r\n{{recentMessages}}`;\r\n\r\nexport const spotTrade: Action = {\r\n    name: \"EXECUTE_SPOT_TRADE\",\r\n    similes: [\r\n        \"SPOT_TRADE\",\r\n        \"MARKET_ORDER\",\r\n        \"LIMIT_ORDER\",\r\n        \"BUY_CRYPTO\",\r\n        \"SELL_CRYPTO\",\r\n        \"PLACE_ORDER\",\r\n    ],\r\n    description: \"Execute a spot trade on Binance\",\r\n    validate: async (runtime: IAgentRuntime) => {\r\n        return !!(\r\n            runtime.getSetting(\"BINANCE_API_KEY\") &&\r\n            runtime.getSetting(\"BINANCE_SECRET_KEY\")\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ): Promise<boolean> => {\r\n        let content;\r\n        try {\r\n            state = !state\r\n                ? await runtime.composeState(message)\r\n                : await runtime.updateRecentMessageState(state);\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template: spotTradeTemplate,\r\n            });\r\n\r\n            content = await generateObjectDeprecated({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            // Convert quantity to number if it's a string\r\n            if (content && typeof content.quantity === \"string\") {\r\n                content.quantity = parseFloat(content.quantity);\r\n            }\r\n\r\n            const parseResult = SpotTradeSchema.safeParse(content);\r\n            if (!parseResult.success) {\r\n                throw new Error(\r\n                    `Invalid spot trade content: ${JSON.stringify(parseResult.error.errors, null, 2)}`\r\n                );\r\n            }\r\n\r\n            const binanceService = new BinanceService({\r\n                apiKey: runtime.getSetting(\"BINANCE_API_KEY\"),\r\n                secretKey: runtime.getSetting(\"BINANCE_SECRET_KEY\"),\r\n            });\r\n\r\n            const tradeResult = await binanceService.executeTrade(content);\r\n\r\n            if (callback) {\r\n                const orderType =\r\n                    content.type === \"MARKET\"\r\n                        ? \"market\"\r\n                        : `limit at ${BinanceService.formatPrice(content.price!)}`;\r\n\r\n                callback({\r\n                    text: `Successfully placed a ${orderType} order to ${content.side.toLowerCase()} ${content.quantity} ${content.symbol}\\nOrder ID: ${tradeResult.orderId}\\nStatus: ${tradeResult.status}`,\r\n                    content: tradeResult,\r\n                });\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error executing trade:\", {\r\n                content,\r\n                message: error.message,\r\n                code: error.code,\r\n            });\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error executing trade: ${error.message}`,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Buy 0.1 BTC at market price\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll execute a market order to buy 0.1 BTC now.\",\r\n                    action: \"EXECUTE_SPOT_TRADE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"Successfully placed a market order to buy 0.1 BTCUSDT\\nOrder ID: 123456789\\nStatus: FILLED\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Place a limit order to sell 100 BNB at 250 USDT\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll place a limit order to sell 100 BNB at 250 USDT.\",\r\n                    action: \"EXECUTE_SPOT_TRADE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"Successfully placed a limit order to sell 100 BNBUSDT at 250\\nOrder ID: 987654321\\nStatus: NEW\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","// types.ts\r\nimport { z } from \"zod\";\r\n\r\n// Base configuration types\r\nexport interface BinanceConfig {\r\n    apiKey?: string;\r\n    secretKey?: string;\r\n    baseURL?: string;\r\n}\r\n\r\n// Enhanced schemas with better validation\r\nexport const PriceCheckSchema = z.object({\r\n    symbol: z.string().min(1).toUpperCase(),\r\n    quoteCurrency: z.string().min(1).toUpperCase().default(\"USDT\"),\r\n});\r\n\r\nexport const SpotTradeSchema = z.object({\r\n    symbol: z.string().min(1).toUpperCase(),\r\n    side: z.enum([\"BUY\", \"SELL\"]),\r\n    type: z.enum([\"MARKET\", \"LIMIT\"]),\r\n    quantity: z.number().positive(),\r\n    price: z.number().positive().optional(),\r\n    timeInForce: z.enum([\"GTC\", \"IOC\", \"FOK\"]).optional().default(\"GTC\"),\r\n});\r\n\r\n// Inferred types from schemas\r\nexport type PriceCheckRequest = z.infer<typeof PriceCheckSchema>;\r\nexport type SpotTradeRequest = z.infer<typeof SpotTradeSchema>;\r\n\r\n// Response types\r\nexport interface PriceResponse {\r\n    symbol: string;\r\n    price: string;\r\n    timestamp: number;\r\n}\r\n\r\nexport interface TradeResponse {\r\n    symbol: string;\r\n    orderId: number;\r\n    status: \"NEW\" | \"PARTIALLY_FILLED\" | \"FILLED\" | \"CANCELED\" | \"REJECTED\";\r\n    executedQty: string;\r\n    cummulativeQuoteQty: string;\r\n    price: string;\r\n    type: SpotTradeRequest[\"type\"];\r\n    side: SpotTradeRequest[\"side\"];\r\n}\r\n\r\n// Error handling types\r\nexport class BinanceError extends Error {\r\n    constructor(\r\n        message: string,\r\n        public code?: number,\r\n        public details?: unknown\r\n    ) {\r\n        super(message);\r\n        this.name = \"BinanceError\";\r\n    }\r\n}\r\n\r\n// Constants\r\nexport const TRADE_STATUS = {\r\n    NEW: \"NEW\",\r\n    PARTIALLY_FILLED: \"PARTIALLY_FILLED\",\r\n    FILLED: \"FILLED\",\r\n    CANCELED: \"CANCELED\",\r\n    REJECTED: \"REJECTED\",\r\n} as const;\r\n\r\nexport type TradeStatus = keyof typeof TRADE_STATUS;\r\n\r\n// Balance types\r\nexport interface BalanceCheckRequest {\r\n    asset?: string;\r\n}\r\n\r\nexport interface AssetBalance {\r\n    asset: string;\r\n    free: string;\r\n    locked: string;\r\n}\r\n\r\nexport interface BalanceResponse {\r\n    balances: AssetBalance[];\r\n    timestamp: number;\r\n}\r\n","import { Plugin } from \"@elizaos/core\";\r\nimport { priceCheck } from \"./actions/priceCheck\";\r\nimport { spotBalance } from \"./actions/spotBalance\";\r\nimport { spotTrade } from \"./actions/spotTrade\";\r\n\r\n// Export the plugin configuration\r\nexport const binancePlugin: Plugin = {\r\n    name: \"binance\",\r\n    description: \"Binance Plugin for Eliza\",\r\n    actions: [spotTrade, priceCheck, spotBalance],\r\n    evaluators: [],\r\n    providers: [],\r\n};\r\n\r\nexport default binancePlugin;\r\n"],"mappings":"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","names":["elizaLogger","elizaLogger","composeContext","elizaLogger","generateObjectDeprecated","ModelClass","composeContext","generateObjectDeprecated","ModelClass","elizaLogger","composeContext","elizaLogger","generateObjectDeprecated","ModelClass","z","composeContext","generateObjectDeprecated","ModelClass","elizaLogger"]}