{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { v4 } from \"uuid\";\r\n\r\n// Import the entire module as default\r\nimport pg from \"pg\";\r\ntype Pool = pg.Pool;\r\n\r\nimport {\r\n    Account,\r\n    Actor,\r\n    DatabaseAdapter,\r\n    EmbeddingProvider,\r\n    GoalStatus,\r\n    Participant,\r\n    RAGKnowledgeItem,\r\n    elizaLogger,\r\n    getEmbeddingConfig,\r\n    type Goal,\r\n    type IDatabaseCacheAdapter,\r\n    type Memory,\r\n    type Relationship,\r\n    type UUID,\r\n} from \"@elizaos/core\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport {\r\n    QueryConfig,\r\n    QueryConfigValues,\r\n    QueryResult,\r\n    QueryResultRow,\r\n} from \"pg\";\r\nimport { fileURLToPath } from \"url\";\r\n\r\nconst __filename = fileURLToPath(import.meta.url); // get the resolved path to the file\r\nconst __dirname = path.dirname(__filename); // get the name of the directory\r\n\r\nexport class PostgresDatabaseAdapter\r\n    extends DatabaseAdapter<Pool>\r\n    implements IDatabaseCacheAdapter\r\n{\r\n    private pool: Pool;\r\n    private readonly maxRetries: number = 3;\r\n    private readonly baseDelay: number = 1000; // 1 second\r\n    private readonly maxDelay: number = 10000; // 10 seconds\r\n    private readonly jitterMax: number = 1000; // 1 second\r\n    private readonly connectionTimeout: number = 5000; // 5 seconds\r\n\r\n    constructor(connectionConfig: any) {\r\n        super({\r\n            //circuitbreaker stuff\r\n            failureThreshold: 5,\r\n            resetTimeout: 60000,\r\n            halfOpenMaxAttempts: 3,\r\n        });\r\n\r\n        const defaultConfig = {\r\n            max: 20,\r\n            idleTimeoutMillis: 30000,\r\n            connectionTimeoutMillis: this.connectionTimeout,\r\n        };\r\n\r\n        this.pool = new pg.Pool({\r\n            ...defaultConfig,\r\n            ...connectionConfig, // Allow overriding defaults\r\n        });\r\n\r\n        this.pool.on(\"error\", (err) => {\r\n            elizaLogger.error(\"Unexpected pool error\", err);\r\n            this.handlePoolError(err);\r\n        });\r\n\r\n        this.setupPoolErrorHandling();\r\n        this.testConnection();\r\n    }\r\n\r\n    private setupPoolErrorHandling() {\r\n        process.on(\"SIGINT\", async () => {\r\n            await this.cleanup();\r\n            process.exit(0);\r\n        });\r\n\r\n        process.on(\"SIGTERM\", async () => {\r\n            await this.cleanup();\r\n            process.exit(0);\r\n        });\r\n\r\n        process.on(\"beforeExit\", async () => {\r\n            await this.cleanup();\r\n        });\r\n    }\r\n\r\n    private async withDatabase<T>(\r\n        operation: () => Promise<T>,\r\n        context: string\r\n    ): Promise<T> {\r\n        return this.withCircuitBreaker(async () => {\r\n            return this.withRetry(operation);\r\n        }, context);\r\n    }\r\n\r\n    private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\r\n        let lastError: Error = new Error(\"Unknown error\"); // Initialize with default\r\n\r\n        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\r\n            try {\r\n                return await operation();\r\n            } catch (error) {\r\n                lastError = error as Error;\r\n\r\n                if (attempt < this.maxRetries) {\r\n                    // Calculate delay with exponential backoff\r\n                    const backoffDelay = Math.min(\r\n                        this.baseDelay * Math.pow(2, attempt - 1),\r\n                        this.maxDelay\r\n                    );\r\n\r\n                    // Add jitter to prevent thundering herd\r\n                    const jitter = Math.random() * this.jitterMax;\r\n                    const delay = backoffDelay + jitter;\r\n\r\n                    elizaLogger.warn(\r\n                        `Database operation failed (attempt ${attempt}/${this.maxRetries}):`,\r\n                        {\r\n                            error:\r\n                                error instanceof Error\r\n                                    ? error.message\r\n                                    : String(error),\r\n                            nextRetryIn: `${(delay / 1000).toFixed(1)}s`,\r\n                        }\r\n                    );\r\n\r\n                    await new Promise((resolve) => setTimeout(resolve, delay));\r\n                } else {\r\n                    elizaLogger.error(\"Max retry attempts reached:\", {\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                        totalAttempts: attempt,\r\n                    });\r\n                    throw error instanceof Error\r\n                        ? error\r\n                        : new Error(String(error));\r\n                }\r\n            }\r\n        }\r\n\r\n        throw lastError;\r\n    }\r\n\r\n    private async handlePoolError(error: Error) {\r\n        elizaLogger.error(\"Pool error occurred, attempting to reconnect\", {\r\n            error: error.message,\r\n        });\r\n\r\n        try {\r\n            // Close existing pool\r\n            await this.pool.end();\r\n\r\n            // Create new pool\r\n            this.pool = new pg.Pool({\r\n                ...this.pool.options,\r\n                connectionTimeoutMillis: this.connectionTimeout,\r\n            });\r\n\r\n            await this.testConnection();\r\n            elizaLogger.success(\"Pool reconnection successful\");\r\n        } catch (reconnectError) {\r\n            elizaLogger.error(\"Failed to reconnect pool\", {\r\n                error:\r\n                    reconnectError instanceof Error\r\n                        ? reconnectError.message\r\n                        : String(reconnectError),\r\n            });\r\n            throw reconnectError;\r\n        }\r\n    }\r\n\r\n    async query<R extends QueryResultRow = any, I = any[]>(\r\n        queryTextOrConfig: string | QueryConfig<I>,\r\n        values?: QueryConfigValues<I>\r\n    ): Promise<QueryResult<R>> {\r\n        return this.withDatabase(async () => {\r\n            return await this.pool.query(queryTextOrConfig, values);\r\n        }, \"query\");\r\n    }\r\n\r\n    private async validateVectorSetup(): Promise<boolean> {\r\n        try {\r\n            const vectorExt = await this.query(`\r\n                SELECT 1 FROM pg_extension WHERE extname = 'vector'\r\n            `);\r\n            const hasVector = vectorExt.rows.length > 0;\r\n\r\n            if (!hasVector) {\r\n                elizaLogger.error(\"Vector extension not found in database\");\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Failed to validate vector extension:\", {\r\n                error: error instanceof Error ? error.message : String(error),\r\n            });\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async init() {\r\n        await this.testConnection();\r\n\r\n        const client = await this.pool.connect();\r\n        try {\r\n            await client.query(\"BEGIN\");\r\n\r\n            // Set application settings for embedding dimension\r\n            const embeddingConfig = getEmbeddingConfig();\r\n            if (embeddingConfig.provider === EmbeddingProvider.OpenAI) {\r\n                await client.query(\"SET app.use_openai_embedding = 'true'\");\r\n                await client.query(\"SET app.use_ollama_embedding = 'false'\");\r\n                await client.query(\"SET app.use_gaianet_embedding = 'false'\");\r\n            } else if (embeddingConfig.provider === EmbeddingProvider.Ollama) {\r\n                await client.query(\"SET app.use_openai_embedding = 'false'\");\r\n                await client.query(\"SET app.use_ollama_embedding = 'true'\");\r\n                await client.query(\"SET app.use_gaianet_embedding = 'false'\");\r\n            } else if (embeddingConfig.provider === EmbeddingProvider.GaiaNet) {\r\n                await client.query(\"SET app.use_openai_embedding = 'false'\");\r\n                await client.query(\"SET app.use_ollama_embedding = 'false'\");\r\n                await client.query(\"SET app.use_gaianet_embedding = 'true'\");\r\n            } else {\r\n                await client.query(\"SET app.use_openai_embedding = 'false'\");\r\n                await client.query(\"SET app.use_ollama_embedding = 'false'\");\r\n            }\r\n\r\n            // Check if schema already exists (check for a core table)\r\n            const { rows } = await client.query(`\r\n                SELECT EXISTS (\r\n                    SELECT FROM information_schema.tables\r\n                    WHERE table_name = 'rooms'\r\n                );\r\n            `);\r\n\r\n            if (!rows[0].exists || !(await this.validateVectorSetup())) {\r\n                elizaLogger.info(\r\n                    \"Applying database schema - tables or vector extension missing\"\r\n                );\r\n                const schema = fs.readFileSync(\r\n                    path.resolve(__dirname, \"../schema.sql\"),\r\n                    \"utf8\"\r\n                );\r\n                await client.query(schema);\r\n            }\r\n\r\n            await client.query(\"COMMIT\");\r\n        } catch (error) {\r\n            await client.query(\"ROLLBACK\");\r\n            throw error;\r\n        } finally {\r\n            client.release();\r\n        }\r\n    }\r\n\r\n    async close() {\r\n        await this.pool.end();\r\n    }\r\n\r\n    async testConnection(): Promise<boolean> {\r\n        let client;\r\n        try {\r\n            client = await this.pool.connect();\r\n            const result = await client.query(\"SELECT NOW()\");\r\n            elizaLogger.success(\r\n                \"Database connection test successful:\",\r\n                result.rows[0]\r\n            );\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Database connection test failed:\", error);\r\n            throw new Error(\r\n                `Failed to connect to database: ${(error as Error).message}`\r\n            );\r\n        } finally {\r\n            if (client) client.release();\r\n        }\r\n    }\r\n\r\n    async cleanup(): Promise<void> {\r\n        try {\r\n            await this.pool.end();\r\n            elizaLogger.info(\"Database pool closed\");\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error closing database pool:\", error);\r\n        }\r\n    }\r\n\r\n    async getRoom(roomId: UUID): Promise<UUID | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                \"SELECT id FROM rooms WHERE id = $1\",\r\n                [roomId]\r\n            );\r\n            return rows.length > 0 ? (rows[0].id as UUID) : null;\r\n        }, \"getRoom\");\r\n    }\r\n\r\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                `SELECT id, \"userId\", \"roomId\", \"last_message_read\"\r\n                FROM participants\r\n                WHERE \"userId\" = $1`,\r\n                [userId]\r\n            );\r\n            return rows as Participant[];\r\n        }, \"getParticipantsForAccount\");\r\n    }\r\n\r\n    async getParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID\r\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                `SELECT \"userState\" FROM participants WHERE \"roomId\" = $1 AND \"userId\" = $2`,\r\n                [roomId, userId]\r\n            );\r\n            return rows.length > 0 ? rows[0].userState : null;\r\n        }, \"getParticipantUserState\");\r\n    }\r\n\r\n    async getMemoriesByRoomIds(params: {\r\n        roomIds: UUID[];\r\n        agentId?: UUID;\r\n        tableName: string;\r\n        limit?: number;\r\n    }): Promise<Memory[]> {\r\n        return this.withDatabase(async () => {\r\n            if (params.roomIds.length === 0) return [];\r\n            const placeholders = params.roomIds\r\n                .map((_, i) => `$${i + 2}`)\r\n                .join(\", \");\r\n\r\n            let query = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" IN (${placeholders})`;\r\n            let queryParams = [params.tableName, ...params.roomIds];\r\n\r\n            if (params.agentId) {\r\n                query += ` AND \"agentId\" = $${params.roomIds.length + 2}`;\r\n                queryParams = [...queryParams, params.agentId];\r\n            }\r\n\r\n            // Add sorting, and conditionally add LIMIT if provided\r\n            query += ` ORDER BY \"createdAt\" DESC`;\r\n            if (params.limit) {\r\n                query += ` LIMIT $${queryParams.length + 1}`;\r\n                queryParams.push(params.limit.toString());\r\n            }\r\n\r\n            const { rows } = await this.pool.query(query, queryParams);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n            }));\r\n        }, \"getMemoriesByRoomIds\");\r\n    }\r\n\r\n    async setParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n        state: \"FOLLOWED\" | \"MUTED\" | null\r\n    ): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.pool.query(\r\n                `UPDATE participants SET \"userState\" = $1 WHERE \"roomId\" = $2 AND \"userId\" = $3`,\r\n                [state, roomId, userId]\r\n            );\r\n        }, \"setParticipantUserState\");\r\n    }\r\n\r\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                'SELECT \"userId\" FROM participants WHERE \"roomId\" = $1',\r\n                [roomId]\r\n            );\r\n            return rows.map((row) => row.userId);\r\n        }, \"getParticipantsForRoom\");\r\n    }\r\n\r\n    async getAccountById(userId: UUID): Promise<Account | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                \"SELECT * FROM accounts WHERE id = $1\",\r\n                [userId]\r\n            );\r\n            if (rows.length === 0) {\r\n                elizaLogger.debug(\"Account not found:\", { userId });\r\n                return null;\r\n            }\r\n\r\n            const account = rows[0];\r\n            // elizaLogger.debug(\"Account retrieved:\", {\r\n            //     userId,\r\n            //     hasDetails: !!account.details,\r\n            // });\r\n\r\n            return {\r\n                ...account,\r\n                details:\r\n                    typeof account.details === \"string\"\r\n                        ? JSON.parse(account.details)\r\n                        : account.details,\r\n            };\r\n        }, \"getAccountById\");\r\n    }\r\n\r\n    async createAccount(account: Account): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const accountId = account.id ?? v4();\r\n                await this.pool.query(\r\n                    `INSERT INTO accounts (id, name, username, email, \"avatarUrl\", details)\r\n                    VALUES ($1, $2, $3, $4, $5, $6)`,\r\n                    [\r\n                        accountId,\r\n                        account.name,\r\n                        account.username || \"\",\r\n                        account.email || \"\",\r\n                        account.avatarUrl || \"\",\r\n                        JSON.stringify(account.details),\r\n                    ]\r\n                );\r\n                elizaLogger.debug(\"Account created successfully:\", {\r\n                    accountId,\r\n                });\r\n                return true;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error creating account:\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    accountId: account.id,\r\n                    name: account.name, // Only log non-sensitive fields\r\n                });\r\n                return false; // Return false instead of throwing to maintain existing behavior\r\n            }\r\n        }, \"createAccount\");\r\n    }\r\n\r\n    async getActorById(params: { roomId: UUID }): Promise<Actor[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                `SELECT a.id, a.name, a.username, a.details\r\n                FROM participants p\r\n                LEFT JOIN accounts a ON p.\"userId\" = a.id\r\n                WHERE p.\"roomId\" = $1`,\r\n                [params.roomId]\r\n            );\r\n\r\n            elizaLogger.debug(\"Retrieved actors:\", {\r\n                roomId: params.roomId,\r\n                actorCount: rows.length,\r\n            });\r\n\r\n            return rows.map((row) => {\r\n                try {\r\n                    return {\r\n                        ...row,\r\n                        details:\r\n                            typeof row.details === \"string\"\r\n                                ? JSON.parse(row.details)\r\n                                : row.details,\r\n                    };\r\n                } catch (error) {\r\n                    elizaLogger.warn(\"Failed to parse actor details:\", {\r\n                        actorId: row.id,\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                    });\r\n                    return {\r\n                        ...row,\r\n                        details: {}, // Provide default empty details on parse error\r\n                    };\r\n                }\r\n            });\r\n        }, \"getActorById\").catch((error) => {\r\n            elizaLogger.error(\"Failed to get actors:\", {\r\n                roomId: params.roomId,\r\n                error: error.message,\r\n            });\r\n            throw error; // Re-throw to let caller handle database errors\r\n        });\r\n    }\r\n\r\n    async getMemoryById(id: UUID): Promise<Memory | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                \"SELECT * FROM memories WHERE id = $1\",\r\n                [id]\r\n            );\r\n            if (rows.length === 0) return null;\r\n\r\n            return {\r\n                ...rows[0],\r\n                content:\r\n                    typeof rows[0].content === \"string\"\r\n                        ? JSON.parse(rows[0].content)\r\n                        : rows[0].content,\r\n            };\r\n        }, \"getMemoryById\");\r\n    }\r\n\r\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            elizaLogger.debug(\"PostgresAdapter createMemory:\", {\r\n                memoryId: memory.id,\r\n                embeddingLength: memory.embedding?.length,\r\n                contentLength: memory.content?.text?.length,\r\n            });\r\n\r\n            let isUnique = true;\r\n            if (memory.embedding) {\r\n                const similarMemories = await this.searchMemoriesByEmbedding(\r\n                    memory.embedding,\r\n                    {\r\n                        tableName,\r\n                        roomId: memory.roomId,\r\n                        match_threshold: 0.95,\r\n                        count: 1,\r\n                    }\r\n                );\r\n                isUnique = similarMemories.length === 0;\r\n            }\r\n\r\n            await this.pool.query(\r\n                `INSERT INTO memories (\r\n                    id, type, content, embedding, \"userId\", \"roomId\", \"agentId\", \"unique\", \"createdAt\"\r\n                ) VALUES ($1, $2, $3, $4, $5::uuid, $6::uuid, $7::uuid, $8, to_timestamp($9/1000.0))`,\r\n                [\r\n                    memory.id ?? v4(),\r\n                    tableName,\r\n                    JSON.stringify(memory.content),\r\n                    memory.embedding ? `[${memory.embedding.join(\",\")}]` : null,\r\n                    memory.userId,\r\n                    memory.roomId,\r\n                    memory.agentId,\r\n                    memory.unique ?? isUnique,\r\n                    Date.now(),\r\n                ]\r\n            );\r\n        }, \"createMemory\");\r\n    }\r\n\r\n    async searchMemories(params: {\r\n        tableName: string;\r\n        agentId: UUID;\r\n        roomId: UUID;\r\n        embedding: number[];\r\n        match_threshold: number;\r\n        match_count: number;\r\n        unique: boolean;\r\n    }): Promise<Memory[]> {\r\n        return await this.searchMemoriesByEmbedding(params.embedding, {\r\n            match_threshold: params.match_threshold,\r\n            count: params.match_count,\r\n            agentId: params.agentId,\r\n            roomId: params.roomId,\r\n            unique: params.unique,\r\n            tableName: params.tableName,\r\n        });\r\n    }\r\n\r\n    async getMemories(params: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        tableName: string;\r\n        agentId?: UUID;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]> {\r\n        // Parameter validation\r\n        if (!params.tableName) throw new Error(\"tableName is required\");\r\n        if (!params.roomId) throw new Error(\"roomId is required\");\r\n\r\n        return this.withDatabase(async () => {\r\n            // Build query\r\n            let sql = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" = $2`;\r\n            const values: any[] = [params.tableName, params.roomId];\r\n            let paramCount = 2;\r\n\r\n            // Add time range filters\r\n            if (params.start) {\r\n                paramCount++;\r\n                sql += ` AND \"createdAt\" >= to_timestamp($${paramCount})`;\r\n                values.push(params.start / 1000);\r\n            }\r\n\r\n            if (params.end) {\r\n                paramCount++;\r\n                sql += ` AND \"createdAt\" <= to_timestamp($${paramCount})`;\r\n                values.push(params.end / 1000);\r\n            }\r\n\r\n            // Add other filters\r\n            if (params.unique) {\r\n                sql += ` AND \"unique\" = true`;\r\n            }\r\n\r\n            if (params.agentId) {\r\n                paramCount++;\r\n                sql += ` AND \"agentId\" = $${paramCount}`;\r\n                values.push(params.agentId);\r\n            }\r\n\r\n            // Add ordering and limit\r\n            sql += ' ORDER BY \"createdAt\" DESC';\r\n\r\n            if (params.count) {\r\n                paramCount++;\r\n                sql += ` LIMIT $${paramCount}`;\r\n                values.push(params.count);\r\n            }\r\n\r\n            elizaLogger.debug(\"Fetching memories:\", {\r\n                roomId: params.roomId,\r\n                tableName: params.tableName,\r\n                unique: params.unique,\r\n                agentId: params.agentId,\r\n                timeRange:\r\n                    params.start || params.end\r\n                        ? {\r\n                              start: params.start\r\n                                  ? new Date(params.start).toISOString()\r\n                                  : undefined,\r\n                              end: params.end\r\n                                  ? new Date(params.end).toISOString()\r\n                                  : undefined,\r\n                          }\r\n                        : undefined,\r\n                limit: params.count,\r\n            });\r\n\r\n            const { rows } = await this.pool.query(sql, values);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n            }));\r\n        }, \"getMemories\");\r\n    }\r\n\r\n    async getGoals(params: {\r\n        roomId: UUID;\r\n        userId?: UUID | null;\r\n        onlyInProgress?: boolean;\r\n        count?: number;\r\n    }): Promise<Goal[]> {\r\n        return this.withDatabase(async () => {\r\n            let sql = `SELECT * FROM goals WHERE \"roomId\" = $1`;\r\n            const values: any[] = [params.roomId];\r\n            let paramCount = 1;\r\n\r\n            if (params.userId) {\r\n                paramCount++;\r\n                sql += ` AND \"userId\" = $${paramCount}`;\r\n                values.push(params.userId);\r\n            }\r\n\r\n            if (params.onlyInProgress) {\r\n                sql += \" AND status = 'IN_PROGRESS'\";\r\n            }\r\n\r\n            if (params.count) {\r\n                paramCount++;\r\n                sql += ` LIMIT $${paramCount}`;\r\n                values.push(params.count);\r\n            }\r\n\r\n            const { rows } = await this.pool.query(sql, values);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                objectives:\r\n                    typeof row.objectives === \"string\"\r\n                        ? JSON.parse(row.objectives)\r\n                        : row.objectives,\r\n            }));\r\n        }, \"getGoals\");\r\n    }\r\n\r\n    async updateGoal(goal: Goal): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                await this.pool.query(\r\n                    `UPDATE goals SET name = $1, status = $2, objectives = $3 WHERE id = $4`,\r\n                    [\r\n                        goal.name,\r\n                        goal.status,\r\n                        JSON.stringify(goal.objectives),\r\n                        goal.id,\r\n                    ]\r\n                );\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to update goal:\", {\r\n                    goalId: goal.id,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    status: goal.status,\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"updateGoal\");\r\n    }\r\n\r\n    async createGoal(goal: Goal): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.pool.query(\r\n                `INSERT INTO goals (id, \"roomId\", \"userId\", name, status, objectives)\r\n                VALUES ($1, $2, $3, $4, $5, $6)`,\r\n                [\r\n                    goal.id ?? v4(),\r\n                    goal.roomId,\r\n                    goal.userId,\r\n                    goal.name,\r\n                    goal.status,\r\n                    JSON.stringify(goal.objectives),\r\n                ]\r\n            );\r\n        }, \"createGoal\");\r\n    }\r\n\r\n    async removeGoal(goalId: UUID): Promise<void> {\r\n        if (!goalId) throw new Error(\"Goal ID is required\");\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const result = await this.pool.query(\r\n                    \"DELETE FROM goals WHERE id = $1 RETURNING id\",\r\n                    [goalId]\r\n                );\r\n\r\n                elizaLogger.debug(\"Goal removal attempt:\", {\r\n                    goalId,\r\n                    removed: result?.rowCount ?? 0 > 0,\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to remove goal:\", {\r\n                    goalId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"removeGoal\");\r\n    }\r\n\r\n    async createRoom(roomId?: UUID): Promise<UUID> {\r\n        return this.withDatabase(async () => {\r\n            const newRoomId = roomId || v4();\r\n            await this.pool.query(\"INSERT INTO rooms (id) VALUES ($1)\", [\r\n                newRoomId,\r\n            ]);\r\n            return newRoomId as UUID;\r\n        }, \"createRoom\");\r\n    }\r\n\r\n    async removeRoom(roomId: UUID): Promise<void> {\r\n        if (!roomId) throw new Error(\"Room ID is required\");\r\n\r\n        return this.withDatabase(async () => {\r\n            const client = await this.pool.connect();\r\n            try {\r\n                await client.query(\"BEGIN\");\r\n\r\n                // First check if room exists\r\n                const checkResult = await client.query(\r\n                    \"SELECT id FROM rooms WHERE id = $1\",\r\n                    [roomId]\r\n                );\r\n\r\n                if (checkResult.rowCount === 0) {\r\n                    elizaLogger.warn(\"No room found to remove:\", { roomId });\r\n                    throw new Error(`Room not found: ${roomId}`);\r\n                }\r\n\r\n                // Remove related data first (if not using CASCADE)\r\n                await client.query('DELETE FROM memories WHERE \"roomId\" = $1', [\r\n                    roomId,\r\n                ]);\r\n                await client.query(\r\n                    'DELETE FROM participants WHERE \"roomId\" = $1',\r\n                    [roomId]\r\n                );\r\n                await client.query('DELETE FROM goals WHERE \"roomId\" = $1', [\r\n                    roomId,\r\n                ]);\r\n\r\n                // Finally remove the room\r\n                const result = await client.query(\r\n                    \"DELETE FROM rooms WHERE id = $1 RETURNING id\",\r\n                    [roomId]\r\n                );\r\n\r\n                await client.query(\"COMMIT\");\r\n\r\n                elizaLogger.debug(\r\n                    \"Room and related data removed successfully:\",\r\n                    {\r\n                        roomId,\r\n                        removed: result?.rowCount ?? 0 > 0,\r\n                    }\r\n                );\r\n            } catch (error) {\r\n                await client.query(\"ROLLBACK\");\r\n                elizaLogger.error(\"Failed to remove room:\", {\r\n                    roomId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            } finally {\r\n                if (client) client.release();\r\n            }\r\n        }, \"removeRoom\");\r\n    }\r\n\r\n    async createRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<boolean> {\r\n        // Input validation\r\n        if (!params.userA || !params.userB) {\r\n            throw new Error(\"userA and userB are required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const relationshipId = v4();\r\n                await this.pool.query(\r\n                    `INSERT INTO relationships (id, \"userA\", \"userB\", \"userId\")\r\n                    VALUES ($1, $2, $3, $4)\r\n                    RETURNING id`,\r\n                    [relationshipId, params.userA, params.userB, params.userA]\r\n                );\r\n\r\n                elizaLogger.debug(\"Relationship created successfully:\", {\r\n                    relationshipId,\r\n                    userA: params.userA,\r\n                    userB: params.userB,\r\n                });\r\n\r\n                return true;\r\n            } catch (error) {\r\n                // Check for unique constraint violation or other specific errors\r\n                if ((error as { code?: string }).code === \"23505\") {\r\n                    // Unique violation\r\n                    elizaLogger.warn(\"Relationship already exists:\", {\r\n                        userA: params.userA,\r\n                        userB: params.userB,\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                    });\r\n                } else {\r\n                    elizaLogger.error(\"Failed to create relationship:\", {\r\n                        userA: params.userA,\r\n                        userB: params.userB,\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                    });\r\n                }\r\n                return false;\r\n            }\r\n        }, \"createRelationship\");\r\n    }\r\n\r\n    async getRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<Relationship | null> {\r\n        if (!params.userA || !params.userB) {\r\n            throw new Error(\"userA and userB are required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const { rows } = await this.pool.query(\r\n                    `SELECT * FROM relationships\r\n                    WHERE (\"userA\" = $1 AND \"userB\" = $2)\r\n                    OR (\"userA\" = $2 AND \"userB\" = $1)`,\r\n                    [params.userA, params.userB]\r\n                );\r\n\r\n                if (rows.length > 0) {\r\n                    elizaLogger.debug(\"Relationship found:\", {\r\n                        relationshipId: rows[0].id,\r\n                        userA: params.userA,\r\n                        userB: params.userB,\r\n                    });\r\n                    return rows[0];\r\n                }\r\n\r\n                elizaLogger.debug(\"No relationship found between users:\", {\r\n                    userA: params.userA,\r\n                    userB: params.userB,\r\n                });\r\n                return null;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching relationship:\", {\r\n                    userA: params.userA,\r\n                    userB: params.userB,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"getRelationship\");\r\n    }\r\n\r\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\r\n        if (!params.userId) {\r\n            throw new Error(\"userId is required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const { rows } = await this.pool.query(\r\n                    `SELECT * FROM relationships\r\n                    WHERE \"userA\" = $1 OR \"userB\" = $1\r\n                    ORDER BY \"createdAt\" DESC`, // Add ordering if you have this field\r\n                    [params.userId]\r\n                );\r\n\r\n                elizaLogger.debug(\"Retrieved relationships:\", {\r\n                    userId: params.userId,\r\n                    count: rows.length,\r\n                });\r\n\r\n                return rows;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to fetch relationships:\", {\r\n                    userId: params.userId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"getRelationships\");\r\n    }\r\n\r\n    async getCachedEmbeddings(opts: {\r\n        query_table_name: string;\r\n        query_threshold: number;\r\n        query_input: string;\r\n        query_field_name: string;\r\n        query_field_sub_name: string;\r\n        query_match_count: number;\r\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\r\n        // Input validation\r\n        if (!opts.query_table_name)\r\n            throw new Error(\"query_table_name is required\");\r\n        if (!opts.query_input) throw new Error(\"query_input is required\");\r\n        if (!opts.query_field_name)\r\n            throw new Error(\"query_field_name is required\");\r\n        if (!opts.query_field_sub_name)\r\n            throw new Error(\"query_field_sub_name is required\");\r\n        if (opts.query_match_count <= 0)\r\n            throw new Error(\"query_match_count must be positive\");\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                elizaLogger.debug(\"Fetching cached embeddings:\", {\r\n                    tableName: opts.query_table_name,\r\n                    fieldName: opts.query_field_name,\r\n                    subFieldName: opts.query_field_sub_name,\r\n                    matchCount: opts.query_match_count,\r\n                    inputLength: opts.query_input.length,\r\n                });\r\n\r\n                const sql = `\r\n                    WITH content_text AS (\r\n                        SELECT\r\n                            embedding,\r\n                            COALESCE(\r\n                                content->$2->>$3,\r\n                                ''\r\n                            ) as content_text\r\n                        FROM memories\r\n                        WHERE type = $4\r\n                        AND content->$2->>$3 IS NOT NULL\r\n                    )\r\n                    SELECT\r\n                        embedding,\r\n                        levenshtein(\r\n                            $1,\r\n                            content_text\r\n                        ) as levenshtein_score\r\n                    FROM content_text\r\n                    WHERE levenshtein(\r\n                        $1,\r\n                        content_text\r\n                    ) <= $6  -- Add threshold check\r\n                    ORDER BY levenshtein_score\r\n                    LIMIT $5\r\n                `;\r\n\r\n                const { rows } = await this.pool.query(sql, [\r\n                    opts.query_input,\r\n                    opts.query_field_name,\r\n                    opts.query_field_sub_name,\r\n                    opts.query_table_name,\r\n                    opts.query_match_count,\r\n                    opts.query_threshold,\r\n                ]);\r\n\r\n                elizaLogger.debug(\"Retrieved cached embeddings:\", {\r\n                    count: rows.length,\r\n                    tableName: opts.query_table_name,\r\n                    matchCount: opts.query_match_count,\r\n                });\r\n\r\n                return rows\r\n                    .map(\r\n                        (\r\n                            row\r\n                        ): {\r\n                            embedding: number[];\r\n                            levenshtein_score: number;\r\n                        } | null => {\r\n                            if (!Array.isArray(row.embedding)) return null;\r\n                            return {\r\n                                embedding: row.embedding,\r\n                                levenshtein_score: Number(\r\n                                    row.levenshtein_score\r\n                                ),\r\n                            };\r\n                        }\r\n                    )\r\n                    .filter(\r\n                        (\r\n                            row\r\n                        ): row is {\r\n                            embedding: number[];\r\n                            levenshtein_score: number;\r\n                        } => row !== null\r\n                    );\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error in getCachedEmbeddings:\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    tableName: opts.query_table_name,\r\n                    fieldName: opts.query_field_name,\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"getCachedEmbeddings\");\r\n    }\r\n\r\n    async log(params: {\r\n        body: { [key: string]: unknown };\r\n        userId: UUID;\r\n        roomId: UUID;\r\n        type: string;\r\n    }): Promise<void> {\r\n        // Input validation\r\n        if (!params.userId) throw new Error(\"userId is required\");\r\n        if (!params.roomId) throw new Error(\"roomId is required\");\r\n        if (!params.type) throw new Error(\"type is required\");\r\n        if (!params.body || typeof params.body !== \"object\") {\r\n            throw new Error(\"body must be a valid object\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const logId = v4(); // Generate ID for tracking\r\n                await this.pool.query(\r\n                    `INSERT INTO logs (\r\n                        id,\r\n                        body,\r\n                        \"userId\",\r\n                        \"roomId\",\r\n                        type,\r\n                        \"createdAt\"\r\n                    ) VALUES ($1, $2, $3, $4, $5, NOW())\r\n                    RETURNING id`,\r\n                    [\r\n                        logId,\r\n                        JSON.stringify(params.body), // Ensure body is stringified\r\n                        params.userId,\r\n                        params.roomId,\r\n                        params.type,\r\n                    ]\r\n                );\r\n\r\n                elizaLogger.debug(\"Log entry created:\", {\r\n                    logId,\r\n                    type: params.type,\r\n                    roomId: params.roomId,\r\n                    userId: params.userId,\r\n                    bodyKeys: Object.keys(params.body),\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to create log entry:\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    type: params.type,\r\n                    roomId: params.roomId,\r\n                    userId: params.userId,\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"log\");\r\n    }\r\n\r\n    async searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        params: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            agentId?: UUID;\r\n            roomId?: UUID;\r\n            unique?: boolean;\r\n            tableName: string;\r\n        }\r\n    ): Promise<Memory[]> {\r\n        return this.withDatabase(async () => {\r\n            elizaLogger.debug(\"Incoming vector:\", {\r\n                length: embedding.length,\r\n                sample: embedding.slice(0, 5),\r\n                isArray: Array.isArray(embedding),\r\n                allNumbers: embedding.every((n) => typeof n === \"number\"),\r\n            });\r\n\r\n            // Validate embedding dimension\r\n            if (embedding.length !== getEmbeddingConfig().dimensions) {\r\n                throw new Error(\r\n                    `Invalid embedding dimension: expected ${getEmbeddingConfig().dimensions}, got ${embedding.length}`\r\n                );\r\n            }\r\n\r\n            // Ensure vector is properly formatted\r\n            const cleanVector = embedding.map((n) => {\r\n                if (!Number.isFinite(n)) return 0;\r\n                // Limit precision to avoid floating point issues\r\n                return Number(n.toFixed(6));\r\n            });\r\n\r\n            // Format for Postgres pgvector\r\n            const vectorStr = `[${cleanVector.join(\",\")}]`;\r\n\r\n            elizaLogger.debug(\"Vector debug:\", {\r\n                originalLength: embedding.length,\r\n                cleanLength: cleanVector.length,\r\n                sampleStr: vectorStr.slice(0, 100),\r\n            });\r\n\r\n            let sql = `\r\n                SELECT *,\r\n                1 - (embedding <-> $1::vector(${getEmbeddingConfig().dimensions})) as similarity\r\n                FROM memories\r\n                WHERE type = $2\r\n            `;\r\n\r\n            const values: any[] = [vectorStr, params.tableName];\r\n\r\n            // Log the query for debugging\r\n            elizaLogger.debug(\"Query debug:\", {\r\n                sql: sql.slice(0, 200),\r\n                paramTypes: values.map((v) => typeof v),\r\n                vectorStrLength: vectorStr.length,\r\n            });\r\n\r\n            let paramCount = 2;\r\n\r\n            if (params.unique) {\r\n                sql += ` AND \"unique\" = true`;\r\n            }\r\n\r\n            if (params.agentId) {\r\n                paramCount++;\r\n                sql += ` AND \"agentId\" = $${paramCount}`;\r\n                values.push(params.agentId);\r\n            }\r\n\r\n            if (params.roomId) {\r\n                paramCount++;\r\n                sql += ` AND \"roomId\" = $${paramCount}::uuid`;\r\n                values.push(params.roomId);\r\n            }\r\n\r\n            if (params.match_threshold) {\r\n                paramCount++;\r\n                sql += ` AND 1 - (embedding <-> $1::vector) >= $${paramCount}`;\r\n                values.push(params.match_threshold);\r\n            }\r\n\r\n            sql += ` ORDER BY embedding <-> $1::vector`;\r\n\r\n            if (params.count) {\r\n                paramCount++;\r\n                sql += ` LIMIT $${paramCount}`;\r\n                values.push(params.count);\r\n            }\r\n\r\n            const { rows } = await this.pool.query(sql, values);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n                similarity: row.similarity,\r\n            }));\r\n        }, \"searchMemoriesByEmbedding\");\r\n    }\r\n\r\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                await this.pool.query(\r\n                    `INSERT INTO participants (id, \"userId\", \"roomId\")\r\n                    VALUES ($1, $2, $3)`,\r\n                    [v4(), userId, roomId]\r\n                );\r\n                return true;\r\n            } catch (error) {\r\n                console.log(\"Error adding participant\", error);\r\n                return false;\r\n            }\r\n        }, \"addParticpant\");\r\n    }\r\n\r\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                await this.pool.query(\r\n                    `DELETE FROM participants WHERE \"userId\" = $1 AND \"roomId\" = $2`,\r\n                    [userId, roomId]\r\n                );\r\n                return true;\r\n            } catch (error) {\r\n                console.log(\"Error removing participant\", error);\r\n                return false;\r\n            }\r\n        }, \"removeParticipant\");\r\n    }\r\n\r\n    async updateGoalStatus(params: {\r\n        goalId: UUID;\r\n        status: GoalStatus;\r\n    }): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.pool.query(\r\n                \"UPDATE goals SET status = $1 WHERE id = $2\",\r\n                [params.status, params.goalId]\r\n            );\r\n        }, \"updateGoalStatus\");\r\n    }\r\n\r\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.pool.query(\r\n                \"DELETE FROM memories WHERE type = $1 AND id = $2\",\r\n                [tableName, memoryId]\r\n            );\r\n        }, \"removeMemory\");\r\n    }\r\n\r\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.pool.query(\r\n                `DELETE FROM memories WHERE type = $1 AND \"roomId\" = $2`,\r\n                [tableName, roomId]\r\n            );\r\n        }, \"removeAllMemories\");\r\n    }\r\n\r\n    async countMemories(\r\n        roomId: UUID,\r\n        unique = true,\r\n        tableName = \"\"\r\n    ): Promise<number> {\r\n        if (!tableName) throw new Error(\"tableName is required\");\r\n\r\n        return this.withDatabase(async () => {\r\n            let sql = `SELECT COUNT(*) as count FROM memories WHERE type = $1 AND \"roomId\" = $2`;\r\n            if (unique) {\r\n                sql += ` AND \"unique\" = true`;\r\n            }\r\n\r\n            const { rows } = await this.pool.query(sql, [tableName, roomId]);\r\n            return parseInt(rows[0].count);\r\n        }, \"countMemories\");\r\n    }\r\n\r\n    async removeAllGoals(roomId: UUID): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.pool.query(`DELETE FROM goals WHERE \"roomId\" = $1`, [\r\n                roomId,\r\n            ]);\r\n        }, \"removeAllGoals\");\r\n    }\r\n\r\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.pool.query(\r\n                `SELECT \"roomId\" FROM participants WHERE \"userId\" = $1`,\r\n                [userId]\r\n            );\r\n            return rows.map((row) => row.roomId);\r\n        }, \"getRoomsForParticipant\");\r\n    }\r\n\r\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\r\n        return this.withDatabase(async () => {\r\n            const placeholders = userIds.map((_, i) => `$${i + 1}`).join(\", \");\r\n            const { rows } = await this.pool.query(\r\n                `SELECT DISTINCT \"roomId\" FROM participants WHERE \"userId\" IN (${placeholders})`,\r\n                userIds\r\n            );\r\n            return rows.map((row) => row.roomId);\r\n        }, \"getRoomsForParticipants\");\r\n    }\r\n\r\n    async getActorDetails(params: { roomId: string }): Promise<Actor[]> {\r\n        if (!params.roomId) {\r\n            throw new Error(\"roomId is required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const sql = `\r\n                    SELECT\r\n                        a.id,\r\n                        a.name,\r\n                        a.username,\r\n                        a.\"avatarUrl\",\r\n                        COALESCE(a.details::jsonb, '{}'::jsonb) as details\r\n                    FROM participants p\r\n                    LEFT JOIN accounts a ON p.\"userId\" = a.id\r\n                    WHERE p.\"roomId\" = $1\r\n                    ORDER BY a.name\r\n                `;\r\n\r\n                const result = await this.pool.query<Actor>(sql, [\r\n                    params.roomId,\r\n                ]);\r\n\r\n                elizaLogger.debug(\"Retrieved actor details:\", {\r\n                    roomId: params.roomId,\r\n                    actorCount: result.rows.length,\r\n                });\r\n\r\n                return result.rows.map((row) => {\r\n                    try {\r\n                        return {\r\n                            ...row,\r\n                            details:\r\n                                typeof row.details === \"string\"\r\n                                    ? JSON.parse(row.details)\r\n                                    : row.details,\r\n                        };\r\n                    } catch (parseError) {\r\n                        elizaLogger.warn(\"Failed to parse actor details:\", {\r\n                            actorId: row.id,\r\n                            error:\r\n                                parseError instanceof Error\r\n                                    ? parseError.message\r\n                                    : String(parseError),\r\n                        });\r\n                        return {\r\n                            ...row,\r\n                            details: {}, // Fallback to empty object if parsing fails\r\n                        };\r\n                    }\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to fetch actor details:\", {\r\n                    roomId: params.roomId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw new Error(\r\n                    `Failed to fetch actor details: ${error instanceof Error ? error.message : String(error)}`\r\n                );\r\n            }\r\n        }, \"getActorDetails\");\r\n    }\r\n\r\n    async getCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<string | undefined> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const sql = `SELECT \"value\"::TEXT FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`;\r\n                const { rows } = await this.query<{ value: string }>(sql, [\r\n                    params.key,\r\n                    params.agentId,\r\n                ]);\r\n                return rows[0]?.value ?? undefined;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching cache\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    key: params.key,\r\n                    agentId: params.agentId,\r\n                });\r\n                return undefined;\r\n            }\r\n        }, \"getCache\");\r\n    }\r\n\r\n    async setCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n        value: string;\r\n    }): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const client = await this.pool.connect();\r\n                try {\r\n                    await client.query(\"BEGIN\");\r\n                    await client.query(\r\n                        `INSERT INTO cache (\"key\", \"agentId\", \"value\", \"createdAt\")\r\n                         VALUES ($1, $2, $3, CURRENT_TIMESTAMP)\r\n                         ON CONFLICT (\"key\", \"agentId\")\r\n                         DO UPDATE SET \"value\" = EXCLUDED.value, \"createdAt\" = CURRENT_TIMESTAMP`,\r\n                        [params.key, params.agentId, params.value]\r\n                    );\r\n                    await client.query(\"COMMIT\");\r\n                    return true;\r\n                } catch (error) {\r\n                    await client.query(\"ROLLBACK\");\r\n                    elizaLogger.error(\"Error setting cache\", {\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                        key: params.key,\r\n                        agentId: params.agentId,\r\n                    });\r\n                    return false;\r\n                } finally {\r\n                    if (client) client.release();\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    \"Database connection error in setCache\",\r\n                    error\r\n                );\r\n                return false;\r\n            }\r\n        }, \"setCache\");\r\n    }\r\n\r\n    async deleteCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const client = await this.pool.connect();\r\n                try {\r\n                    await client.query(\"BEGIN\");\r\n                    await client.query(\r\n                        `DELETE FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`,\r\n                        [params.key, params.agentId]\r\n                    );\r\n                    await client.query(\"COMMIT\");\r\n                    return true;\r\n                } catch (error) {\r\n                    await client.query(\"ROLLBACK\");\r\n                    elizaLogger.error(\"Error deleting cache\", {\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                        key: params.key,\r\n                        agentId: params.agentId,\r\n                    });\r\n                    return false;\r\n                } finally {\r\n                    client.release();\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    \"Database connection error in deleteCache\",\r\n                    error\r\n                );\r\n                return false;\r\n            }\r\n        }, \"deleteCache\");\r\n    }\r\n\r\n    async getKnowledge(params: {\r\n        id?: UUID;\r\n        agentId: UUID;\r\n        limit?: number;\r\n        query?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        return this.withDatabase(async () => {\r\n            let sql = `SELECT * FROM knowledge WHERE (\"agentId\" = $1 OR \"isShared\" = true)`;\r\n            const queryParams: any[] = [params.agentId];\r\n            let paramCount = 1;\r\n\r\n            if (params.id) {\r\n                paramCount++;\r\n                sql += ` AND id = $${paramCount}`;\r\n                queryParams.push(params.id);\r\n            }\r\n\r\n            if (params.limit) {\r\n                paramCount++;\r\n                sql += ` LIMIT $${paramCount}`;\r\n                queryParams.push(params.limit);\r\n            }\r\n\r\n            const { rows } = await this.pool.query(sql, queryParams);\r\n\r\n            return rows.map((row) => ({\r\n                id: row.id,\r\n                agentId: row.agentId,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n                embedding: row.embedding\r\n                    ? new Float32Array(row.embedding)\r\n                    : undefined,\r\n                createdAt: row.createdAt.getTime(),\r\n            }));\r\n        }, \"getKnowledge\");\r\n    }\r\n\r\n    async searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        return this.withDatabase(async () => {\r\n            const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\r\n            const cachedResult = await this.getCache({\r\n                key: cacheKey,\r\n                agentId: params.agentId,\r\n            });\r\n\r\n            if (cachedResult) {\r\n                return JSON.parse(cachedResult);\r\n            }\r\n\r\n            const vectorStr = `[${Array.from(params.embedding).join(\",\")}]`;\r\n\r\n            const sql = `\r\n                WITH vector_scores AS (\r\n                    SELECT id,\r\n                        1 - (embedding <-> $1::vector) as vector_score\r\n                    FROM knowledge\r\n                    WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR \"agentId\" = $2\r\n                    AND embedding IS NOT NULL\r\n                ),\r\n                keyword_matches AS (\r\n                    SELECT id,\r\n                    CASE\r\n                        WHEN content->>'text' ILIKE $3 THEN 3.0\r\n                        ELSE 1.0\r\n                    END *\r\n                    CASE\r\n                        WHEN (content->'metadata'->>'isChunk')::boolean = true THEN 1.5\r\n                        WHEN (content->'metadata'->>'isMain')::boolean = true THEN 1.2\r\n                        ELSE 1.0\r\n                    END as keyword_score\r\n                    FROM knowledge\r\n                    WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR \"agentId\" = $2\r\n                )\r\n                SELECT k.*,\r\n                    v.vector_score,\r\n                    kw.keyword_score,\r\n                    (v.vector_score * kw.keyword_score) as combined_score\r\n                FROM knowledge k\r\n                JOIN vector_scores v ON k.id = v.id\r\n                LEFT JOIN keyword_matches kw ON k.id = kw.id\r\n                WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR k.\"agentId\" = $2\r\n                AND (\r\n                    v.vector_score >= $4\r\n                    OR (kw.keyword_score > 1.0 AND v.vector_score >= 0.3)\r\n                )\r\n                ORDER BY combined_score DESC\r\n                LIMIT $5\r\n            `;\r\n\r\n            const { rows } = await this.pool.query(sql, [\r\n                vectorStr,\r\n                params.agentId,\r\n                `%${params.searchText || \"\"}%`,\r\n                params.match_threshold,\r\n                params.match_count,\r\n            ]);\r\n\r\n            const results = rows.map((row) => ({\r\n                id: row.id,\r\n                agentId: row.agentId,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n                embedding: row.embedding\r\n                    ? new Float32Array(row.embedding)\r\n                    : undefined,\r\n                createdAt: row.createdAt.getTime(),\r\n                similarity: row.combined_score,\r\n            }));\r\n\r\n            await this.setCache({\r\n                key: cacheKey,\r\n                agentId: params.agentId,\r\n                value: JSON.stringify(results),\r\n            });\r\n\r\n            return results;\r\n        }, \"searchKnowledge\");\r\n    }\r\n\r\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            const client = await this.pool.connect();\r\n            try {\r\n                await client.query(\"BEGIN\");\r\n\r\n                const metadata = knowledge.content.metadata || {};\r\n                const vectorStr = knowledge.embedding\r\n                    ? `[${Array.from(knowledge.embedding).join(\",\")}]`\r\n                    : null;\r\n\r\n                // If this is a chunk, use createKnowledgeChunk\r\n                if (metadata.isChunk && metadata.originalId) {\r\n                    await this.createKnowledgeChunk({\r\n                        id: knowledge.id,\r\n                        originalId: metadata.originalId,\r\n                        agentId: metadata.isShared ? null : knowledge.agentId,\r\n                        content: knowledge.content,\r\n                        embedding: knowledge.embedding,\r\n                        chunkIndex: metadata.chunkIndex || 0,\r\n                        isShared: metadata.isShared || false,\r\n                        createdAt: knowledge.createdAt || Date.now(),\r\n                    });\r\n                } else {\r\n                    // This is a main knowledge item\r\n                    await client.query(\r\n                        `\r\n                        INSERT INTO knowledge (\r\n                            id, \"agentId\", content, embedding, \"createdAt\",\r\n                            \"isMain\", \"originalId\", \"chunkIndex\", \"isShared\"\r\n                        ) VALUES ($1, $2, $3, $4, to_timestamp($5/1000.0), $6, $7, $8, $9)\r\n                        ON CONFLICT (id) DO NOTHING\r\n                    `,\r\n                        [\r\n                            knowledge.id,\r\n                            metadata.isShared ? null : knowledge.agentId,\r\n                            knowledge.content,\r\n                            vectorStr,\r\n                            knowledge.createdAt || Date.now(),\r\n                            true,\r\n                            null,\r\n                            null,\r\n                            metadata.isShared || false,\r\n                        ]\r\n                    );\r\n                }\r\n\r\n                await client.query(\"COMMIT\");\r\n            } catch (error) {\r\n                await client.query(\"ROLLBACK\");\r\n                throw error;\r\n            } finally {\r\n                client.release();\r\n            }\r\n        }, \"createKnowledge\");\r\n    }\r\n\r\n    async removeKnowledge(id: UUID): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            const client = await this.pool.connect();\r\n            try {\r\n                await client.query(\"BEGIN\");\r\n\r\n                // Check if this is a pattern-based chunk deletion (e.g., \"id-chunk-*\")\r\n                if (typeof id === \"string\" && id.includes(\"-chunk-*\")) {\r\n                    const mainId = id.split(\"-chunk-\")[0];\r\n                    // Delete chunks for this main ID\r\n                    await client.query(\r\n                        'DELETE FROM knowledge WHERE \"originalId\" = $1',\r\n                        [mainId]\r\n                    );\r\n                } else {\r\n                    // First delete all chunks associated with this knowledge item\r\n                    await client.query(\r\n                        'DELETE FROM knowledge WHERE \"originalId\" = $1',\r\n                        [id]\r\n                    );\r\n                    // Then delete the main knowledge item\r\n                    await client.query(\"DELETE FROM knowledge WHERE id = $1\", [\r\n                        id,\r\n                    ]);\r\n                }\r\n\r\n                await client.query(\"COMMIT\");\r\n            } catch (error) {\r\n                await client.query(\"ROLLBACK\");\r\n                elizaLogger.error(\"Error removing knowledge\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    id,\r\n                });\r\n                throw error;\r\n            } finally {\r\n                client.release();\r\n            }\r\n        }, \"removeKnowledge\");\r\n    }\r\n\r\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            const sql = shared\r\n                ? 'DELETE FROM knowledge WHERE (\"agentId\" = $1 OR \"isShared\" = true)'\r\n                : 'DELETE FROM knowledge WHERE \"agentId\" = $1';\r\n\r\n            await this.pool.query(sql, [agentId]);\r\n        }, \"clearKnowledge\");\r\n    }\r\n\r\n    private async createKnowledgeChunk(params: {\r\n        id: UUID;\r\n        originalId: UUID;\r\n        agentId: UUID | null;\r\n        content: any;\r\n        embedding: Float32Array | undefined | null;\r\n        chunkIndex: number;\r\n        isShared: boolean;\r\n        createdAt: number;\r\n    }): Promise<void> {\r\n        const vectorStr = params.embedding\r\n            ? `[${Array.from(params.embedding).join(\",\")}]`\r\n            : null;\r\n\r\n        // Store the pattern-based ID in the content metadata for compatibility\r\n        const patternId = `${params.originalId}-chunk-${params.chunkIndex}`;\r\n        const contentWithPatternId = {\r\n            ...params.content,\r\n            metadata: {\r\n                ...params.content.metadata,\r\n                patternId,\r\n            },\r\n        };\r\n\r\n        await this.pool.query(\r\n            `\r\n            INSERT INTO knowledge (\r\n                id, \"agentId\", content, embedding, \"createdAt\",\r\n                \"isMain\", \"originalId\", \"chunkIndex\", \"isShared\"\r\n            ) VALUES ($1, $2, $3, $4, to_timestamp($5/1000.0), $6, $7, $8, $9)\r\n            ON CONFLICT (id) DO NOTHING\r\n        `,\r\n            [\r\n                v4(), // Generate a proper UUID for PostgreSQL\r\n                params.agentId,\r\n                contentWithPatternId, // Store the pattern ID in metadata\r\n                vectorStr,\r\n                params.createdAt,\r\n                false,\r\n                params.originalId,\r\n                params.chunkIndex,\r\n                params.isShared,\r\n            ]\r\n        );\r\n    }\r\n}\r\n\r\nexport default PostgresDatabaseAdapter;\r\n"],"mappings":"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","names":[]}