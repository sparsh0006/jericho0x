{"version":3,"sources":["../src/sqliteTables.ts","../src/index.ts"],"sourcesContent":["export const sqliteTables = `\r\nPRAGMA foreign_keys=OFF;\r\nBEGIN TRANSACTION;\r\n\r\n-- Table: accounts\r\nCREATE TABLE IF NOT EXISTS \"accounts\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"name\" TEXT,\r\n    \"username\" TEXT,\r\n    \"email\" TEXT NOT NULL,\r\n    \"avatarUrl\" TEXT,\r\n    \"details\" TEXT DEFAULT '{}' CHECK(json_valid(\"details\")) -- Ensuring details is a valid JSON field\r\n);\r\n\r\n-- Table: memories\r\nCREATE TABLE IF NOT EXISTS \"memories\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"type\" TEXT NOT NULL,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"content\" TEXT NOT NULL,\r\n    \"embedding\" BLOB NOT NULL, -- TODO: EMBEDDING ARRAY, CONVERT TO BEST FORMAT FOR SQLITE-VSS (JSON?)\r\n    \"userId\" TEXT,\r\n    \"roomId\" TEXT,\r\n    \"agentId\" TEXT,\r\n    \"unique\" INTEGER DEFAULT 1 NOT NULL,\r\n    FOREIGN KEY (\"userId\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"roomId\") REFERENCES \"rooms\"(\"id\"),\r\n    FOREIGN KEY (\"agentId\") REFERENCES \"accounts\"(\"id\")\r\n);\r\n\r\n-- Table: goals\r\nCREATE TABLE IF NOT EXISTS \"goals\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userId\" TEXT,\r\n    \"name\" TEXT,\r\n    \"status\" TEXT,\r\n    \"description\" TEXT,\r\n    \"roomId\" TEXT,\r\n    \"objectives\" TEXT DEFAULT '[]' NOT NULL CHECK(json_valid(\"objectives\")) -- Ensuring objectives is a valid JSON array\r\n);\r\n\r\n-- Table: logs\r\nCREATE TABLE IF NOT EXISTS \"logs\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userId\" TEXT NOT NULL,\r\n    \"body\" TEXT NOT NULL,\r\n    \"type\" TEXT NOT NULL,\r\n    \"roomId\" TEXT NOT NULL\r\n);\r\n\r\n-- Table: participants\r\nCREATE TABLE IF NOT EXISTS \"participants\" (\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userId\" TEXT,\r\n    \"roomId\" TEXT,\r\n    \"userState\" TEXT,\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"last_message_read\" TEXT,\r\n    FOREIGN KEY (\"userId\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"roomId\") REFERENCES \"rooms\"(\"id\")\r\n);\r\n\r\n-- Table: relationships\r\nCREATE TABLE IF NOT EXISTS \"relationships\" (\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userA\" TEXT NOT NULL,\r\n    \"userB\" TEXT NOT NULL,\r\n    \"status\" \"text\",\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"userId\" TEXT NOT NULL,\r\n    FOREIGN KEY (\"userA\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"userB\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"userId\") REFERENCES \"accounts\"(\"id\")\r\n);\r\n\r\n-- Table: rooms\r\nCREATE TABLE IF NOT EXISTS \"rooms\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n);\r\n\r\n-- Table: cache\r\nCREATE TABLE IF NOT EXISTS \"cache\" (\r\n    \"key\" TEXT NOT NULL,\r\n    \"agentId\" TEXT NOT NULL,\r\n    \"value\" TEXT DEFAULT '{}' CHECK(json_valid(\"value\")),\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"expiresAt\" TIMESTAMP,\r\n    PRIMARY KEY (\"key\", \"agentId\")\r\n);\r\n\r\n-- Table: knowledge\r\nCREATE TABLE IF NOT EXISTS \"knowledge\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"agentId\" TEXT,\r\n    \"content\" TEXT NOT NULL CHECK(json_valid(\"content\")),\r\n    \"embedding\" BLOB,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"isMain\" INTEGER DEFAULT 0,\r\n    \"originalId\" TEXT,\r\n    \"chunkIndex\" INTEGER,\r\n    \"isShared\" INTEGER DEFAULT 0,\r\n    FOREIGN KEY (\"agentId\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"originalId\") REFERENCES \"knowledge\"(\"id\"),\r\n    CHECK((isShared = 1 AND agentId IS NULL) OR (isShared = 0 AND agentId IS NOT NULL))\r\n);\r\n\r\n-- Index: relationships_id_key\r\nCREATE UNIQUE INDEX IF NOT EXISTS \"relationships_id_key\" ON \"relationships\" (\"id\");\r\n\r\n-- Index: memories_id_key\r\nCREATE UNIQUE INDEX IF NOT EXISTS \"memories_id_key\" ON \"memories\" (\"id\");\r\n\r\n-- Index: participants_id_key\r\nCREATE UNIQUE INDEX IF NOT EXISTS \"participants_id_key\" ON \"participants\" (\"id\");\r\n\r\n-- Index: knowledge\r\nCREATE INDEX IF NOT EXISTS \"knowledge_agent_key\" ON \"knowledge\" (\"agentId\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_agent_main_key\" ON \"knowledge\" (\"agentId\", \"isMain\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_original_key\" ON \"knowledge\" (\"originalId\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_content_key\" ON \"knowledge\"\r\n    ((json_extract(content, '$.text')))\r\n    WHERE json_extract(content, '$.text') IS NOT NULL;\r\nCREATE INDEX IF NOT EXISTS \"knowledge_created_key\" ON \"knowledge\" (\"agentId\", \"createdAt\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_shared_key\" ON \"knowledge\" (\"isShared\");\r\n\r\nCOMMIT;`;","export * from \"./sqliteTables.ts\";\r\nexport * from \"./types.ts\";\r\n\r\nimport {\r\n    Account,\r\n    Actor,\r\n    DatabaseAdapter,\r\n    GoalStatus,\r\n    IDatabaseCacheAdapter,\r\n    Participant,\r\n    type Goal,\r\n    type Memory,\r\n    type Relationship,\r\n    type UUID,\r\n    RAGKnowledgeItem,\r\n    elizaLogger\r\n} from \"@elizaos/core\";\r\nimport { v4 } from \"uuid\";\r\nimport { sqliteTables } from \"./sqliteTables.ts\";\r\nimport { Database } from \"./types.ts\";\r\n\r\nexport class SqlJsDatabaseAdapter\r\n    extends DatabaseAdapter<Database>\r\n    implements IDatabaseCacheAdapter\r\n{\r\n    constructor(db: Database) {\r\n        super();\r\n        this.db = db;\r\n    }\r\n\r\n    async init() {\r\n        this.db.exec(sqliteTables);\r\n    }\r\n\r\n    async close() {\r\n        this.db.close();\r\n    }\r\n\r\n    async getRoom(roomId: UUID): Promise<UUID | null> {\r\n        const sql = \"SELECT id FROM rooms WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([roomId]);\r\n        const room = stmt.getAsObject() as { id: string } | undefined;\r\n        stmt.free();\r\n        return room ? (room.id as UUID) : null;\r\n    }\r\n\r\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\r\n        const sql = `\r\n      SELECT p.id, p.userId, p.roomId, p.last_message_read\r\n      FROM participants p\r\n      WHERE p.userId = ?\r\n    `;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([userId]);\r\n        const participants: Participant[] = [];\r\n        while (stmt.step()) {\r\n            const participant = stmt.getAsObject() as unknown as Participant;\r\n            participants.push(participant);\r\n        }\r\n        stmt.free();\r\n        return participants;\r\n    }\r\n\r\n    async getParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID\r\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\r\n        const sql =\r\n            \"SELECT userState FROM participants WHERE roomId = ? AND userId = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([roomId, userId]);\r\n        const result = stmt.getAsObject() as {\r\n            userState: \"FOLLOWED\" | \"MUTED\" | null;\r\n        };\r\n        stmt.free();\r\n        return result.userState ?? null;\r\n    }\r\n\r\n    async getMemoriesByRoomIds(params: {\r\n        agentId: UUID;\r\n        roomIds: UUID[];\r\n        tableName: string;\r\n    }): Promise<Memory[]> {\r\n        const placeholders = params.roomIds.map(() => \"?\").join(\", \");\r\n        const sql = `SELECT * FROM memories WHERE 'type' = ? AND agentId = ? AND roomId IN (${placeholders})`;\r\n        const stmt = this.db.prepare(sql);\r\n        const queryParams = [\r\n            params.tableName,\r\n            params.agentId,\r\n            ...params.roomIds,\r\n        ];\r\n        elizaLogger.log({ queryParams });\r\n        stmt.bind(queryParams);\r\n        elizaLogger.log({ queryParams });\r\n\r\n        const memories: Memory[] = [];\r\n        while (stmt.step()) {\r\n            const memory = stmt.getAsObject() as unknown as Memory;\r\n            memories.push({\r\n                ...memory,\r\n                content: JSON.parse(memory.content as unknown as string),\r\n            });\r\n        }\r\n        stmt.free();\r\n        return memories;\r\n    }\r\n\r\n    async setParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n        state: \"FOLLOWED\" | \"MUTED\" | null\r\n    ): Promise<void> {\r\n        const sql =\r\n            \"UPDATE participants SET userState = ? WHERE roomId = ? AND userId = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([state, roomId, userId]);\r\n        stmt.step();\r\n        stmt.free();\r\n    }\r\n\r\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\r\n        const sql = \"SELECT userId FROM participants WHERE roomId = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([roomId]);\r\n        const userIds: UUID[] = [];\r\n        while (stmt.step()) {\r\n            const row = stmt.getAsObject() as { userId: string };\r\n            userIds.push(row.userId as UUID);\r\n        }\r\n        stmt.free();\r\n        return userIds;\r\n    }\r\n\r\n    async getAccountById(userId: UUID): Promise<Account | null> {\r\n        const sql = \"SELECT * FROM accounts WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([userId]);\r\n        const account = stmt.getAsObject() as unknown as Account | undefined;\r\n\r\n        if (account && typeof account.details === \"string\") {\r\n            account.details = JSON.parse(account.details);\r\n        }\r\n\r\n        stmt.free();\r\n        return account || null;\r\n    }\r\n\r\n    async createAccount(account: Account): Promise<boolean> {\r\n        try {\r\n            const sql = `\r\n      INSERT INTO accounts (id, name, username, email, avatarUrl, details)\r\n      VALUES (?, ?, ?, ?, ?, ?)\r\n      `;\r\n            const stmt = this.db.prepare(sql);\r\n            stmt.run([\r\n                account.id ?? v4(),\r\n                account.name,\r\n                account.username || \"\",\r\n                account.email || \"\",\r\n                account.avatarUrl || \"\",\r\n                JSON.stringify(account.details),\r\n            ]);\r\n            stmt.free();\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error creating account\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getActorById(params: { roomId: UUID }): Promise<Actor[]> {\r\n        const sql = `\r\n      SELECT a.id, a.name, a.username, a.details\r\n      FROM participants p\r\n      LEFT JOIN accounts a ON p.userId = a.id\r\n      WHERE p.roomId = ?\r\n    `;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([params.roomId]);\r\n        const rows: Actor[] = [];\r\n        while (stmt.step()) {\r\n            const row = stmt.getAsObject() as unknown as Actor;\r\n            rows.push({\r\n                ...row,\r\n                details:\r\n                    typeof row.details === \"string\"\r\n                        ? JSON.parse(row.details)\r\n                        : row.details,\r\n            });\r\n        }\r\n        stmt.free();\r\n        return rows;\r\n    }\r\n\r\n    async getActorDetails(params: { roomId: UUID }): Promise<Actor[]> {\r\n        const sql = `\r\n      SELECT a.id, a.name, a.username, a.details\r\n      FROM participants p\r\n      LEFT JOIN accounts a ON p.userId = a.id\r\n      WHERE p.roomId = ?\r\n    `;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([params.roomId]);\r\n        const rows: Actor[] = [];\r\n        while (stmt.step()) {\r\n            const row = stmt.getAsObject() as unknown as Actor;\r\n            rows.push({\r\n                ...row,\r\n                details:\r\n                    typeof row.details === \"string\"\r\n                        ? JSON.parse(row.details)\r\n                        : row.details,\r\n            });\r\n        }\r\n        stmt.free();\r\n        return rows;\r\n    }\r\n\r\n    async getMemoryById(id: UUID): Promise<Memory | null> {\r\n        const sql = \"SELECT * FROM memories WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([id]);\r\n        const memory = stmt.getAsObject() as unknown as Memory | undefined;\r\n        stmt.free();\r\n        return memory || null;\r\n    }\r\n\r\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\r\n        let isUnique = true;\r\n        if (memory.embedding) {\r\n            // Check if a similar memory already exists\r\n            const similarMemories = await this.searchMemoriesByEmbedding(\r\n                memory.embedding,\r\n                {\r\n                    agentId: memory.agentId,\r\n                    tableName,\r\n                    roomId: memory.roomId,\r\n                    match_threshold: 0.95, // 5% similarity threshold\r\n                    count: 1,\r\n                }\r\n            );\r\n\r\n            isUnique = similarMemories.length === 0;\r\n        }\r\n\r\n        // Insert the memory with the appropriate 'unique' value\r\n        const sql = `INSERT INTO memories (id, type, content, embedding, userId, roomId, agentId, \\`unique\\`, createdAt) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`;\r\n        const stmt = this.db.prepare(sql);\r\n\r\n        const createdAt = memory.createdAt ?? Date.now();\r\n\r\n        stmt.run([\r\n            memory.id ?? v4(),\r\n            tableName,\r\n            JSON.stringify(memory.content),\r\n            JSON.stringify(memory.embedding),\r\n            memory.userId,\r\n            memory.roomId,\r\n            memory.agentId,\r\n            isUnique ? 1 : 0,\r\n            createdAt,\r\n        ]);\r\n        stmt.free();\r\n    }\r\n\r\n    async searchMemories(params: {\r\n        tableName: string;\r\n        agentId: UUID;\r\n        roomId: UUID;\r\n        embedding: number[];\r\n        match_threshold: number;\r\n        match_count: number;\r\n        unique: boolean;\r\n    }): Promise<Memory[]> {\r\n        let sql =\r\n            `\r\n  SELECT *` +\r\n            // TODO: Uncomment when we compile sql.js with vss\r\n            // `, (1 - vss_distance_l2(embedding, ?)) AS similarity` +\r\n            ` FROM memories\r\n  WHERE type = ? AND agentId = ?\r\n  AND roomId = ?`;\r\n\r\n        if (params.unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n        // TODO: Uncomment when we compile sql.js with vss\r\n        // sql += ` ORDER BY similarity DESC LIMIT ?`;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([\r\n            // JSON.stringify(params.embedding),\r\n            params.tableName,\r\n            params.agentId,\r\n            params.roomId,\r\n            // params.match_count,\r\n        ]);\r\n        const memories: (Memory & { similarity: number })[] = [];\r\n        while (stmt.step()) {\r\n            const memory = stmt.getAsObject() as unknown as Memory & {\r\n                similarity: number;\r\n            };\r\n            memories.push({\r\n                ...memory,\r\n                content: JSON.parse(memory.content as unknown as string),\r\n            });\r\n        }\r\n        stmt.free();\r\n        return memories;\r\n    }\r\n\r\n    async searchMemoriesByEmbedding(\r\n        _embedding: number[],\r\n        params: {\r\n            agentId: UUID;\r\n            match_threshold?: number;\r\n            count?: number;\r\n            roomId?: UUID;\r\n            unique?: boolean;\r\n            tableName: string;\r\n        }\r\n    ): Promise<Memory[]> {\r\n        let sql =\r\n            `SELECT *` +\r\n            // TODO: Uncomment when we compile sql.js with vss\r\n            // `, (1 - vss_distance_l2(embedding, ?)) AS similarity`+\r\n            ` FROM memories\r\n        WHERE type = ? AND agentId = ?`;\r\n\r\n        if (params.unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n        if (params.roomId) {\r\n            sql += \" AND roomId = ?\";\r\n        }\r\n        // TODO: Test this\r\n        if (params.agentId) {\r\n            sql += \" AND userId = ?\";\r\n        }\r\n        // TODO: Uncomment when we compile sql.js with vss\r\n        // sql += ` ORDER BY similarity DESC`;\r\n\r\n        if (params.count) {\r\n            sql += \" LIMIT ?\";\r\n        }\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        const bindings = [\r\n            // JSON.stringify(embedding),\r\n            params.tableName,\r\n            params.agentId,\r\n        ];\r\n        if (params.roomId) {\r\n            bindings.push(params.roomId);\r\n        }\r\n        if (params.count) {\r\n            bindings.push(params.count.toString());\r\n        }\r\n\r\n        stmt.bind(bindings);\r\n        const memories: (Memory & { similarity: number })[] = [];\r\n        while (stmt.step()) {\r\n            const memory = stmt.getAsObject() as unknown as Memory & {\r\n                similarity: number;\r\n            };\r\n            memories.push({\r\n                ...memory,\r\n                content: JSON.parse(memory.content as unknown as string),\r\n            });\r\n        }\r\n        stmt.free();\r\n        return memories;\r\n    }\r\n\r\n    async getCachedEmbeddings(opts: {\r\n        query_table_name: string;\r\n        query_threshold: number;\r\n        query_input: string;\r\n        query_field_name: string;\r\n        query_field_sub_name: string;\r\n        query_match_count: number;\r\n    }): Promise<\r\n        {\r\n            embedding: number[];\r\n            levenshtein_score: number;\r\n        }[]\r\n    > {\r\n        const sql =\r\n            `\r\n        SELECT *\r\n        FROM memories\r\n        WHERE type = ?` +\r\n            // `AND vss_search(${opts.query_field_name}, ?)\r\n            // ORDER BY vss_search(${opts.query_field_name}, ?) DESC` +\r\n            ` LIMIT ?\r\n      `;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([\r\n            opts.query_table_name,\r\n            // opts.query_input,\r\n            // opts.query_input,\r\n            opts.query_match_count,\r\n        ]);\r\n        const memories: Memory[] = [];\r\n        while (stmt.step()) {\r\n            const memory = stmt.getAsObject() as unknown as Memory;\r\n            memories.push(memory);\r\n        }\r\n        stmt.free();\r\n\r\n        return memories.map((memory) => ({\r\n            ...memory,\r\n            createdAt: memory.createdAt ?? Date.now(),\r\n            embedding: JSON.parse(memory.embedding as unknown as string),\r\n            levenshtein_score: 0,\r\n        }));\r\n    }\r\n\r\n    async updateGoalStatus(params: {\r\n        goalId: UUID;\r\n        status: GoalStatus;\r\n    }): Promise<void> {\r\n        const sql = \"UPDATE goals SET status = ? WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([params.status, params.goalId]);\r\n        stmt.free();\r\n    }\r\n\r\n    async log(params: {\r\n        body: { [key: string]: unknown };\r\n        userId: UUID;\r\n        roomId: UUID;\r\n        type: string;\r\n    }): Promise<void> {\r\n        const sql =\r\n            \"INSERT INTO logs (body, userId, roomId, type) VALUES (?, ?, ?, ?)\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([\r\n            JSON.stringify(params.body),\r\n            params.userId,\r\n            params.roomId,\r\n            params.type,\r\n        ]);\r\n        stmt.free();\r\n    }\r\n\r\n    async getMemories(params: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        tableName: string;\r\n        agentId?: UUID;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]> {\r\n        if (!params.tableName) {\r\n            throw new Error(\"tableName is required\");\r\n        }\r\n        if (!params.roomId) {\r\n            throw new Error(\"roomId is required\");\r\n        }\r\n        let sql = `SELECT * FROM memories WHERE type = ? AND roomId = ?`;\r\n\r\n        if (params.start) {\r\n            sql += ` AND createdAt >= ?`;\r\n        }\r\n\r\n        if (params.end) {\r\n            sql += ` AND createdAt <= ?`;\r\n        }\r\n\r\n        if (params.unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n\r\n        if (params.agentId) {\r\n            sql += \" AND agentId = ?\";\r\n        }\r\n\r\n        sql += \" ORDER BY createdAt DESC\";\r\n\r\n        if (params.count) {\r\n            sql += \" LIMIT ?\";\r\n        }\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([\r\n            params.tableName,\r\n            params.roomId,\r\n            ...(params.start ? [params.start] : []),\r\n            ...(params.end ? [params.end] : []),\r\n            ...(params.agentId ? [params.agentId] : []),\r\n            ...(params.count ? [params.count] : []),\r\n        ]);\r\n        const memories: Memory[] = [];\r\n        while (stmt.step()) {\r\n            const memory = stmt.getAsObject() as unknown as Memory;\r\n            memories.push({\r\n                ...memory,\r\n                content: JSON.parse(memory.content as unknown as string),\r\n            });\r\n        }\r\n        stmt.free();\r\n        return memories;\r\n    }\r\n\r\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\r\n        const sql = `DELETE FROM memories WHERE type = ? AND id = ?`;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([tableName, memoryId]);\r\n        stmt.free();\r\n    }\r\n\r\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\r\n        const sql = `DELETE FROM memories WHERE type = ? AND roomId = ?`;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([tableName, roomId]);\r\n        stmt.free();\r\n    }\r\n\r\n    async countMemories(\r\n        roomId: UUID,\r\n        unique = true,\r\n        tableName = \"\"\r\n    ): Promise<number> {\r\n        if (!tableName) {\r\n            throw new Error(\"tableName is required\");\r\n        }\r\n\r\n        let sql = `SELECT COUNT(*) as count FROM memories WHERE type = ? AND roomId = ?`;\r\n        if (unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([tableName, roomId]);\r\n\r\n        let count = 0;\r\n        if (stmt.step()) {\r\n            const result = stmt.getAsObject() as { count: number };\r\n            count = result.count;\r\n        }\r\n\r\n        stmt.free();\r\n        return count;\r\n    }\r\n\r\n    async getGoals(params: {\r\n        roomId: UUID;\r\n        userId?: UUID | null;\r\n        onlyInProgress?: boolean;\r\n        count?: number;\r\n    }): Promise<Goal[]> {\r\n        let sql = \"SELECT * FROM goals WHERE roomId = ?\";\r\n        const bindings: (string | number)[] = [params.roomId];\r\n\r\n        if (params.userId) {\r\n            sql += \" AND userId = ?\";\r\n            bindings.push(params.userId);\r\n        }\r\n\r\n        if (params.onlyInProgress) {\r\n            sql += \" AND status = 'IN_PROGRESS'\";\r\n        }\r\n\r\n        if (params.count) {\r\n            sql += \" LIMIT ?\";\r\n            bindings.push(params.count.toString());\r\n        }\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind(bindings);\r\n        const goals: Goal[] = [];\r\n        while (stmt.step()) {\r\n            const goal = stmt.getAsObject() as unknown as Goal;\r\n            goals.push({\r\n                ...goal,\r\n                objectives:\r\n                    typeof goal.objectives === \"string\"\r\n                        ? JSON.parse(goal.objectives)\r\n                        : goal.objectives,\r\n            });\r\n        }\r\n        stmt.free();\r\n        return goals;\r\n    }\r\n\r\n    async updateGoal(goal: Goal): Promise<void> {\r\n        const sql =\r\n            \"UPDATE goals SET name = ?, status = ?, objectives = ? WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([\r\n            goal.name,\r\n            goal.status,\r\n            JSON.stringify(goal.objectives),\r\n            goal.id as string,\r\n        ]);\r\n        stmt.free();\r\n    }\r\n\r\n    async createGoal(goal: Goal): Promise<void> {\r\n        const sql =\r\n            \"INSERT INTO goals (id, roomId, userId, name, status, objectives) VALUES (?, ?, ?, ?, ?, ?)\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([\r\n            goal.id ?? v4(),\r\n            goal.roomId,\r\n            goal.userId,\r\n            goal.name,\r\n            goal.status,\r\n            JSON.stringify(goal.objectives),\r\n        ]);\r\n        stmt.free();\r\n    }\r\n\r\n    async removeGoal(goalId: UUID): Promise<void> {\r\n        const sql = \"DELETE FROM goals WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([goalId]);\r\n        stmt.free();\r\n    }\r\n\r\n    async removeAllGoals(roomId: UUID): Promise<void> {\r\n        const sql = \"DELETE FROM goals WHERE roomId = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([roomId]);\r\n        stmt.free();\r\n    }\r\n\r\n    async createRoom(roomId?: UUID): Promise<UUID> {\r\n        roomId = roomId || (v4() as UUID);\r\n        try {\r\n            const sql = \"INSERT INTO rooms (id) VALUES (?)\";\r\n            const stmt = this.db.prepare(sql);\r\n            stmt.run([roomId ?? (v4() as UUID)]);\r\n            stmt.free();\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error creating room\", error);\r\n        }\r\n        return roomId as UUID;\r\n    }\r\n\r\n    async removeRoom(roomId: UUID): Promise<void> {\r\n        const sql = \"DELETE FROM rooms WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([roomId]);\r\n        stmt.free();\r\n    }\r\n\r\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\r\n        const sql = \"SELECT roomId FROM participants WHERE userId = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([userId]);\r\n        const rows: { roomId: string }[] = [];\r\n        while (stmt.step()) {\r\n            const row = stmt.getAsObject() as unknown as { roomId: string };\r\n            rows.push(row);\r\n        }\r\n        stmt.free();\r\n        return rows.map((row) => row.roomId as UUID);\r\n    }\r\n\r\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\r\n        // Assuming userIds is an array of UUID strings, prepare a list of placeholders\r\n        const placeholders = userIds.map(() => \"?\").join(\", \");\r\n        // Construct the SQL query with the correct number of placeholders\r\n        const sql = `SELECT roomId FROM participants WHERE userId IN (${placeholders})`;\r\n        const stmt = this.db.prepare(sql);\r\n        // Execute the query with the userIds array spread into arguments\r\n        stmt.bind(userIds);\r\n        const rows: { roomId: string }[] = [];\r\n        while (stmt.step()) {\r\n            const row = stmt.getAsObject() as unknown as { roomId: string };\r\n            rows.push(row);\r\n        }\r\n        stmt.free();\r\n        // Map and return the roomId values as UUIDs\r\n        return rows.map((row) => row.roomId as UUID);\r\n    }\r\n\r\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        try {\r\n            const sql =\r\n                \"INSERT INTO participants (id, userId, roomId) VALUES (?, ?, ?)\";\r\n            const stmt = this.db.prepare(sql);\r\n            stmt.run([v4(), userId, roomId]);\r\n            stmt.free();\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error adding participant\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        try {\r\n            const sql =\r\n                \"DELETE FROM participants WHERE userId = ? AND roomId = ?\";\r\n            const stmt = this.db.prepare(sql);\r\n            stmt.run([userId, roomId]);\r\n            stmt.free();\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error removing participant\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async createRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<boolean> {\r\n        if (!params.userA || !params.userB) {\r\n            throw new Error(\"userA and userB are required\");\r\n        }\r\n        const sql =\r\n            \"INSERT INTO relationships (id, userA, userB, userId) VALUES (?, ?, ?, ?)\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([v4(), params.userA, params.userB, params.userA]);\r\n        stmt.free();\r\n        return true;\r\n    }\r\n\r\n    async getRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<Relationship | null> {\r\n        let relationship: Relationship | null = null;\r\n        try {\r\n            const sql =\r\n                \"SELECT * FROM relationships WHERE (userA = ? AND userB = ?) OR (userA = ? AND userB = ?)\";\r\n            const stmt = this.db.prepare(sql);\r\n            stmt.bind([params.userA, params.userB, params.userB, params.userA]);\r\n\r\n            if (stmt.step()) {\r\n                relationship = stmt.getAsObject() as unknown as Relationship;\r\n            }\r\n            stmt.free();\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error fetching relationship\", error);\r\n        }\r\n        return relationship;\r\n    }\r\n\r\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\r\n        const sql =\r\n            \"SELECT * FROM relationships WHERE (userA = ? OR userB = ?)\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([params.userId, params.userId]);\r\n        const relationships: Relationship[] = [];\r\n        while (stmt.step()) {\r\n            const relationship = stmt.getAsObject() as unknown as Relationship;\r\n            relationships.push(relationship);\r\n        }\r\n        stmt.free();\r\n        return relationships;\r\n    }\r\n\r\n    async getCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<string | undefined> {\r\n        const sql = \"SELECT value FROM cache WHERE (key = ? AND agentId = ?)\";\r\n        const stmt = this.db.prepare(sql);\r\n\r\n        stmt.bind([params.key, params.agentId]);\r\n\r\n        let cached: { value: string } | undefined = undefined;\r\n        if (stmt.step()) {\r\n            cached = stmt.getAsObject() as unknown as { value: string };\r\n        }\r\n        stmt.free();\r\n\r\n        return cached?.value ?? undefined;\r\n    }\r\n\r\n    async setCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n        value: string;\r\n    }): Promise<boolean> {\r\n        const sql =\r\n            \"INSERT OR REPLACE INTO cache (key, agentId, value, createdAt) VALUES (?, ?, ?, CURRENT_TIMESTAMP)\";\r\n        const stmt = this.db.prepare(sql);\r\n\r\n        stmt.run([params.key, params.agentId, params.value]);\r\n        stmt.free();\r\n\r\n        return true;\r\n    }\r\n\r\n    async deleteCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<boolean> {\r\n        try {\r\n            const sql = \"DELETE FROM cache WHERE key = ? AND agentId = ?\";\r\n            const stmt = this.db.prepare(sql);\r\n            stmt.run([params.key, params.agentId]);\r\n            stmt.free();\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error removing cache\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getKnowledge(params: {\r\n        id?: UUID;\r\n        agentId: UUID;\r\n        limit?: number;\r\n        query?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        let sql = `SELECT * FROM knowledge WHERE (\"agentId\" = ? OR \"isShared\" = 1)`;\r\n        const queryParams: any[] = [params.agentId];\r\n\r\n        if (params.id) {\r\n            sql += ` AND id = ?`;\r\n            queryParams.push(params.id);\r\n        }\r\n\r\n        if (params.limit) {\r\n            sql += ` LIMIT ?`;\r\n            queryParams.push(params.limit);\r\n        }\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind(queryParams);\r\n        const results: RAGKnowledgeItem[] = [];\r\n\r\n        while (stmt.step()) {\r\n            const row = stmt.getAsObject() as any;\r\n            results.push({\r\n                id: row.id,\r\n                agentId: row.agentId,\r\n                content: JSON.parse(row.content),\r\n                embedding: row.embedding ? new Float32Array(row.embedding) : undefined, // Convert Uint8Array back to Float32Array\r\n                createdAt: row.createdAt\r\n            });\r\n        }\r\n        stmt.free();\r\n        return results;\r\n    }\r\n\r\n    async searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\r\n        const cachedResult = await this.getCache({\r\n            key: cacheKey,\r\n            agentId: params.agentId\r\n        });\r\n\r\n        if (cachedResult) {\r\n            return JSON.parse(cachedResult);\r\n        }\r\n\r\n        const sql = `\r\n            WITH vector_scores AS (\r\n                SELECT id,\r\n                        1 / (1 + vec_distance_L2(embedding, ?)) as vector_score\r\n                FROM knowledge\r\n                WHERE (\"agentId\" IS NULL AND \"isShared\" = 1) OR \"agentId\" = ?\r\n                AND embedding IS NOT NULL\r\n            ),\r\n            keyword_matches AS (\r\n                SELECT id,\r\n                CASE\r\n                    WHEN json_extract(content, '$.text') LIKE ? THEN 3.0\r\n                    ELSE 1.0\r\n                END *\r\n                CASE\r\n                    WHEN json_extract(content, '$.metadata.isChunk') = 1 THEN 1.5\r\n                    WHEN json_extract(content, '$.metadata.isMain') = 1 THEN 1.2\r\n                    ELSE 1.0\r\n                END as keyword_score\r\n                FROM knowledge\r\n                WHERE (\"agentId\" IS NULL AND \"isShared\" = 1) OR \"agentId\" = ?\r\n            )\r\n            SELECT k.*,\r\n                v.vector_score,\r\n                kw.keyword_score,\r\n                (v.vector_score * kw.keyword_score) as combined_score\r\n            FROM knowledge k\r\n            JOIN vector_scores v ON k.id = v.id\r\n            LEFT JOIN keyword_matches kw ON k.id = kw.id\r\n            WHERE (k.agentId IS NULL AND k.isShared = 1) OR k.agentId = ?\r\n            AND (\r\n                v.vector_score >= ?  -- Using match_threshold parameter\r\n                OR (kw.keyword_score > 1.0 AND v.vector_score >= 0.3)\r\n            )\r\n            ORDER BY combined_score DESC\r\n            LIMIT ?\r\n        `;\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([\r\n            new Uint8Array(params.embedding.buffer),\r\n            params.agentId,\r\n            `%${params.searchText || ''}%`,\r\n            params.agentId,\r\n            params.agentId,\r\n            params.match_threshold,\r\n            params.match_count\r\n        ]);\r\n\r\n        const results: RAGKnowledgeItem[] = [];\r\n        while (stmt.step()) {\r\n            const row = stmt.getAsObject() as any;\r\n            results.push({\r\n                id: row.id,\r\n                agentId: row.agentId,\r\n                content: JSON.parse(row.content),\r\n                embedding: row.embedding ? new Float32Array(row.embedding) : undefined,\r\n                createdAt: row.createdAt,\r\n                similarity: row.keyword_score\r\n            });\r\n        }\r\n        stmt.free();\r\n\r\n        await this.setCache({\r\n            key: cacheKey,\r\n            agentId: params.agentId,\r\n            value: JSON.stringify(results)\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\r\n        try {\r\n            const sql = `\r\n                INSERT INTO knowledge (\r\n                    id, \"agentId\", content, embedding, \"createdAt\",\r\n                    \"isMain\", \"originalId\", \"chunkIndex\", \"isShared\"\r\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n            `;\r\n\r\n            const stmt = this.db.prepare(sql);\r\n            const metadata = knowledge.content.metadata || {};\r\n\r\n            stmt.run([\r\n                knowledge.id,\r\n                metadata.isShared ? null : knowledge.agentId,\r\n                JSON.stringify(knowledge.content),\r\n                knowledge.embedding ? new Uint8Array(knowledge.embedding.buffer) : null,\r\n                knowledge.createdAt || Date.now(),\r\n                metadata.isMain ? 1 : 0,\r\n                metadata.originalId || null,\r\n                metadata.chunkIndex || null,\r\n                metadata.isShared ? 1 : 0\r\n            ]);\r\n            stmt.free();\r\n        } catch (error: any) {\r\n            const isShared = knowledge.content.metadata?.isShared;\r\n            const isPrimaryKeyError = error?.code === 'SQLITE_CONSTRAINT_PRIMARYKEY';\r\n\r\n            if (isShared && isPrimaryKeyError) {\r\n                elizaLogger.info(`Shared knowledge ${knowledge.id} already exists, skipping`);\r\n                return;\r\n            } else if (!isShared && !error.message?.includes('SQLITE_CONSTRAINT_PRIMARYKEY')) {\r\n                elizaLogger.error(`Error creating knowledge ${knowledge.id}:`, {\r\n                    error,\r\n                    embeddingLength: knowledge.embedding?.length,\r\n                    content: knowledge.content\r\n                });\r\n                throw error;\r\n            }\r\n\r\n            elizaLogger.debug(`Knowledge ${knowledge.id} already exists, skipping`);\r\n        }\r\n    }\r\n\r\n    async removeKnowledge(id: UUID): Promise<void> {\r\n        const sql = `DELETE FROM knowledge WHERE id = ?`;\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([id]);\r\n        stmt.free();\r\n    }\r\n\r\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\r\n        const sql = shared ?\r\n            `DELETE FROM knowledge WHERE (\"agentId\" = ? OR \"isShared\" = 1)` :\r\n            `DELETE FROM knowledge WHERE \"agentId\" = ?`;\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.run([agentId]);\r\n        stmt.free();\r\n    }\r\n}\r\n"],"mappings":";AAAO,IAAM,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACG5B;AAAA,EAGI;AAAA,EASA;AAAA,OACG;AACP,SAAS,UAAU;AAIZ,IAAM,uBAAN,cACK,gBAEZ;AAAA,EACI,YAAY,IAAc;AACtB,UAAM;AACN,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,OAAO;AACT,SAAK,GAAG,KAAK,YAAY;AAAA,EAC7B;AAAA,EAEA,MAAM,QAAQ;AACV,SAAK,GAAG,MAAM;AAAA,EAClB;AAAA,EAEA,MAAM,QAAQ,QAAoC;AAC9C,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,MAAM,CAAC;AAClB,UAAM,OAAO,KAAK,YAAY;AAC9B,SAAK,KAAK;AACV,WAAO,OAAQ,KAAK,KAAc;AAAA,EACtC;AAAA,EAEA,MAAM,0BAA0B,QAAsC;AAClE,UAAM,MAAM;AAAA;AAAA;AAAA;AAAA;AAKZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,MAAM,CAAC;AAClB,UAAM,eAA8B,CAAC;AACrC,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,cAAc,KAAK,YAAY;AACrC,mBAAa,KAAK,WAAW;AAAA,IACjC;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,wBACF,QACA,QACoC;AACpC,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,QAAQ,MAAM,CAAC;AAC1B,UAAM,SAAS,KAAK,YAAY;AAGhC,SAAK,KAAK;AACV,WAAO,OAAO,aAAa;AAAA,EAC/B;AAAA,EAEA,MAAM,qBAAqB,QAIL;AAClB,UAAM,eAAe,OAAO,QAAQ,IAAI,MAAM,GAAG,EAAE,KAAK,IAAI;AAC5D,UAAM,MAAM,0EAA0E,YAAY;AAClG,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,UAAM,cAAc;AAAA,MAChB,OAAO;AAAA,MACP,OAAO;AAAA,MACP,GAAG,OAAO;AAAA,IACd;AACA,gBAAY,IAAI,EAAE,YAAY,CAAC;AAC/B,SAAK,KAAK,WAAW;AACrB,gBAAY,IAAI,EAAE,YAAY,CAAC;AAE/B,UAAM,WAAqB,CAAC;AAC5B,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,SAAS,KAAK,YAAY;AAChC,eAAS,KAAK;AAAA,QACV,GAAG;AAAA,QACH,SAAS,KAAK,MAAM,OAAO,OAA4B;AAAA,MAC3D,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,wBACF,QACA,QACA,OACa;AACb,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,OAAO,QAAQ,MAAM,CAAC;AACjC,SAAK,KAAK;AACV,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,uBAAuB,QAA+B;AACxD,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,MAAM,CAAC;AAClB,UAAM,UAAkB,CAAC;AACzB,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,MAAM,KAAK,YAAY;AAC7B,cAAQ,KAAK,IAAI,MAAc;AAAA,IACnC;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,eAAe,QAAuC;AACxD,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,MAAM,CAAC;AAClB,UAAM,UAAU,KAAK,YAAY;AAEjC,QAAI,WAAW,OAAO,QAAQ,YAAY,UAAU;AAChD,cAAQ,UAAU,KAAK,MAAM,QAAQ,OAAO;AAAA,IAChD;AAEA,SAAK,KAAK;AACV,WAAO,WAAW;AAAA,EACtB;AAAA,EAEA,MAAM,cAAc,SAAoC;AACpD,QAAI;AACA,YAAM,MAAM;AAAA;AAAA;AAAA;AAIZ,YAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,WAAK,IAAI;AAAA,QACL,QAAQ,MAAM,GAAG;AAAA,QACjB,QAAQ;AAAA,QACR,QAAQ,YAAY;AAAA,QACpB,QAAQ,SAAS;AAAA,QACjB,QAAQ,aAAa;AAAA,QACrB,KAAK,UAAU,QAAQ,OAAO;AAAA,MAClC,CAAC;AACD,WAAK,KAAK;AACV,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,kBAAY,MAAM,0BAA0B,KAAK;AACjD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,MAAM,aAAa,QAA4C;AAC3D,UAAM,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAMZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,OAAO,MAAM,CAAC;AACzB,UAAM,OAAgB,CAAC;AACvB,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,MAAM,KAAK,YAAY;AAC7B,WAAK,KAAK;AAAA,QACN,GAAG;AAAA,QACH,SACI,OAAO,IAAI,YAAY,WACjB,KAAK,MAAM,IAAI,OAAO,IACtB,IAAI;AAAA,MAClB,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,gBAAgB,QAA4C;AAC9D,UAAM,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAMZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,OAAO,MAAM,CAAC;AACzB,UAAM,OAAgB,CAAC;AACvB,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,MAAM,KAAK,YAAY;AAC7B,WAAK,KAAK;AAAA,QACN,GAAG;AAAA,QACH,SACI,OAAO,IAAI,YAAY,WACjB,KAAK,MAAM,IAAI,OAAO,IACtB,IAAI;AAAA,MAClB,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,cAAc,IAAkC;AAClD,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,EAAE,CAAC;AACd,UAAM,SAAS,KAAK,YAAY;AAChC,SAAK,KAAK;AACV,WAAO,UAAU;AAAA,EACrB;AAAA,EAEA,MAAM,aAAa,QAAgB,WAAkC;AACjE,QAAI,WAAW;AACf,QAAI,OAAO,WAAW;AAElB,YAAM,kBAAkB,MAAM,KAAK;AAAA,QAC/B,OAAO;AAAA,QACP;AAAA,UACI,SAAS,OAAO;AAAA,UAChB;AAAA,UACA,QAAQ,OAAO;AAAA,UACf,iBAAiB;AAAA;AAAA,UACjB,OAAO;AAAA,QACX;AAAA,MACJ;AAEA,iBAAW,gBAAgB,WAAW;AAAA,IAC1C;AAGA,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAEhC,UAAM,YAAY,OAAO,aAAa,KAAK,IAAI;AAE/C,SAAK,IAAI;AAAA,MACL,OAAO,MAAM,GAAG;AAAA,MAChB;AAAA,MACA,KAAK,UAAU,OAAO,OAAO;AAAA,MAC7B,KAAK,UAAU,OAAO,SAAS;AAAA,MAC/B,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,WAAW,IAAI;AAAA,MACf;AAAA,IACJ,CAAC;AACD,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,eAAe,QAQC;AAClB,QAAI,MACA;AAAA;AAAA;AAAA;AAQJ,QAAI,OAAO,QAAQ;AACf,aAAO;AAAA,IACX;AAGA,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK;AAAA;AAAA,MAEN,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA;AAAA,IAEX,CAAC;AACD,UAAM,WAAgD,CAAC;AACvD,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,SAAS,KAAK,YAAY;AAGhC,eAAS,KAAK;AAAA,QACV,GAAG;AAAA,QACH,SAAS,KAAK,MAAM,OAAO,OAA4B;AAAA,MAC3D,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,0BACF,YACA,QAQiB;AACjB,QAAI,MACA;AAAA;AAMJ,QAAI,OAAO,QAAQ;AACf,aAAO;AAAA,IACX;AACA,QAAI,OAAO,QAAQ;AACf,aAAO;AAAA,IACX;AAEA,QAAI,OAAO,SAAS;AAChB,aAAO;AAAA,IACX;AAIA,QAAI,OAAO,OAAO;AACd,aAAO;AAAA,IACX;AAEA,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,UAAM,WAAW;AAAA;AAAA,MAEb,OAAO;AAAA,MACP,OAAO;AAAA,IACX;AACA,QAAI,OAAO,QAAQ;AACf,eAAS,KAAK,OAAO,MAAM;AAAA,IAC/B;AACA,QAAI,OAAO,OAAO;AACd,eAAS,KAAK,OAAO,MAAM,SAAS,CAAC;AAAA,IACzC;AAEA,SAAK,KAAK,QAAQ;AAClB,UAAM,WAAgD,CAAC;AACvD,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,SAAS,KAAK,YAAY;AAGhC,eAAS,KAAK;AAAA,QACV,GAAG;AAAA,QACH,SAAS,KAAK,MAAM,OAAO,OAA4B;AAAA,MAC3D,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,oBAAoB,MAYxB;AACE,UAAM,MACF;AAAA;AAAA;AAAA;AAAA;AAQJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK;AAAA,MACN,KAAK;AAAA;AAAA;AAAA,MAGL,KAAK;AAAA,IACT,CAAC;AACD,UAAM,WAAqB,CAAC;AAC5B,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,SAAS,KAAK,YAAY;AAChC,eAAS,KAAK,MAAM;AAAA,IACxB;AACA,SAAK,KAAK;AAEV,WAAO,SAAS,IAAI,CAAC,YAAY;AAAA,MAC7B,GAAG;AAAA,MACH,WAAW,OAAO,aAAa,KAAK,IAAI;AAAA,MACxC,WAAW,KAAK,MAAM,OAAO,SAA8B;AAAA,MAC3D,mBAAmB;AAAA,IACvB,EAAE;AAAA,EACN;AAAA,EAEA,MAAM,iBAAiB,QAGL;AACd,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,OAAO,QAAQ,OAAO,MAAM,CAAC;AACvC,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,IAAI,QAKQ;AACd,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI;AAAA,MACL,KAAK,UAAU,OAAO,IAAI;AAAA,MAC1B,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,IACX,CAAC;AACD,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,YAAY,QAQI;AAClB,QAAI,CAAC,OAAO,WAAW;AACnB,YAAM,IAAI,MAAM,uBAAuB;AAAA,IAC3C;AACA,QAAI,CAAC,OAAO,QAAQ;AAChB,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACxC;AACA,QAAI,MAAM;AAEV,QAAI,OAAO,OAAO;AACd,aAAO;AAAA,IACX;AAEA,QAAI,OAAO,KAAK;AACZ,aAAO;AAAA,IACX;AAEA,QAAI,OAAO,QAAQ;AACf,aAAO;AAAA,IACX;AAEA,QAAI,OAAO,SAAS;AAChB,aAAO;AAAA,IACX;AAEA,WAAO;AAEP,QAAI,OAAO,OAAO;AACd,aAAO;AAAA,IACX;AAEA,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK;AAAA,MACN,OAAO;AAAA,MACP,OAAO;AAAA,MACP,GAAI,OAAO,QAAQ,CAAC,OAAO,KAAK,IAAI,CAAC;AAAA,MACrC,GAAI,OAAO,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;AAAA,MACjC,GAAI,OAAO,UAAU,CAAC,OAAO,OAAO,IAAI,CAAC;AAAA,MACzC,GAAI,OAAO,QAAQ,CAAC,OAAO,KAAK,IAAI,CAAC;AAAA,IACzC,CAAC;AACD,UAAM,WAAqB,CAAC;AAC5B,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,SAAS,KAAK,YAAY;AAChC,eAAS,KAAK;AAAA,QACV,GAAG;AAAA,QACH,SAAS,KAAK,MAAM,OAAO,OAA4B;AAAA,MAC3D,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,aAAa,UAAgB,WAAkC;AACjE,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,WAAW,QAAQ,CAAC;AAC9B,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,kBAAkB,QAAc,WAAkC;AACpE,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,WAAW,MAAM,CAAC;AAC5B,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,cACF,QACA,SAAS,MACT,YAAY,IACG;AACf,QAAI,CAAC,WAAW;AACZ,YAAM,IAAI,MAAM,uBAAuB;AAAA,IAC3C;AAEA,QAAI,MAAM;AACV,QAAI,QAAQ;AACR,aAAO;AAAA,IACX;AAEA,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,WAAW,MAAM,CAAC;AAE7B,QAAI,QAAQ;AACZ,QAAI,KAAK,KAAK,GAAG;AACb,YAAM,SAAS,KAAK,YAAY;AAChC,cAAQ,OAAO;AAAA,IACnB;AAEA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,SAAS,QAKK;AAChB,QAAI,MAAM;AACV,UAAM,WAAgC,CAAC,OAAO,MAAM;AAEpD,QAAI,OAAO,QAAQ;AACf,aAAO;AACP,eAAS,KAAK,OAAO,MAAM;AAAA,IAC/B;AAEA,QAAI,OAAO,gBAAgB;AACvB,aAAO;AAAA,IACX;AAEA,QAAI,OAAO,OAAO;AACd,aAAO;AACP,eAAS,KAAK,OAAO,MAAM,SAAS,CAAC;AAAA,IACzC;AAEA,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,QAAQ;AAClB,UAAM,QAAgB,CAAC;AACvB,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,OAAO,KAAK,YAAY;AAC9B,YAAM,KAAK;AAAA,QACP,GAAG;AAAA,QACH,YACI,OAAO,KAAK,eAAe,WACrB,KAAK,MAAM,KAAK,UAAU,IAC1B,KAAK;AAAA,MACnB,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,WAAW,MAA2B;AACxC,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,UAAU,KAAK,UAAU;AAAA,MAC9B,KAAK;AAAA,IACT,CAAC;AACD,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,WAAW,MAA2B;AACxC,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI;AAAA,MACL,KAAK,MAAM,GAAG;AAAA,MACd,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,UAAU,KAAK,UAAU;AAAA,IAClC,CAAC;AACD,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,WAAW,QAA6B;AAC1C,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,MAAM,CAAC;AACjB,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,eAAe,QAA6B;AAC9C,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,MAAM,CAAC;AACjB,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,WAAW,QAA8B;AAC3C,aAAS,UAAW,GAAG;AACvB,QAAI;AACA,YAAM,MAAM;AACZ,YAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,WAAK,IAAI,CAAC,UAAW,GAAG,CAAU,CAAC;AACnC,WAAK,KAAK;AAAA,IACd,SAAS,OAAO;AACZ,kBAAY,MAAM,uBAAuB,KAAK;AAAA,IAClD;AACA,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,WAAW,QAA6B;AAC1C,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,MAAM,CAAC;AACjB,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,uBAAuB,QAA+B;AACxD,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,MAAM,CAAC;AAClB,UAAM,OAA6B,CAAC;AACpC,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,MAAM,KAAK,YAAY;AAC7B,WAAK,KAAK,GAAG;AAAA,IACjB;AACA,SAAK,KAAK;AACV,WAAO,KAAK,IAAI,CAAC,QAAQ,IAAI,MAAc;AAAA,EAC/C;AAAA,EAEA,MAAM,wBAAwB,SAAkC;AAE5D,UAAM,eAAe,QAAQ,IAAI,MAAM,GAAG,EAAE,KAAK,IAAI;AAErD,UAAM,MAAM,oDAAoD,YAAY;AAC5E,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAEhC,SAAK,KAAK,OAAO;AACjB,UAAM,OAA6B,CAAC;AACpC,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,MAAM,KAAK,YAAY;AAC7B,WAAK,KAAK,GAAG;AAAA,IACjB;AACA,SAAK,KAAK;AAEV,WAAO,KAAK,IAAI,CAAC,QAAQ,IAAI,MAAc;AAAA,EAC/C;AAAA,EAEA,MAAM,eAAe,QAAc,QAAgC;AAC/D,QAAI;AACA,YAAM,MACF;AACJ,YAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,WAAK,IAAI,CAAC,GAAG,GAAG,QAAQ,MAAM,CAAC;AAC/B,WAAK,KAAK;AACV,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,kBAAY,MAAM,4BAA4B,KAAK;AACnD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,MAAM,kBAAkB,QAAc,QAAgC;AAClE,QAAI;AACA,YAAM,MACF;AACJ,YAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,WAAK,IAAI,CAAC,QAAQ,MAAM,CAAC;AACzB,WAAK,KAAK;AACV,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,kBAAY,MAAM,8BAA8B,KAAK;AACrD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,MAAM,mBAAmB,QAGJ;AACjB,QAAI,CAAC,OAAO,SAAS,CAAC,OAAO,OAAO;AAChC,YAAM,IAAI,MAAM,8BAA8B;AAAA,IAClD;AACA,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,GAAG,GAAG,OAAO,OAAO,OAAO,OAAO,OAAO,KAAK,CAAC;AACzD,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,gBAAgB,QAGW;AAC7B,QAAI,eAAoC;AACxC,QAAI;AACA,YAAM,MACF;AACJ,YAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,WAAK,KAAK,CAAC,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,KAAK,CAAC;AAElE,UAAI,KAAK,KAAK,GAAG;AACb,uBAAe,KAAK,YAAY;AAAA,MACpC;AACA,WAAK,KAAK;AAAA,IACd,SAAS,OAAO;AACZ,kBAAY,MAAM,+BAA+B,KAAK;AAAA,IAC1D;AACA,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,iBAAiB,QAAmD;AACtE,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,CAAC,OAAO,QAAQ,OAAO,MAAM,CAAC;AACxC,UAAM,gBAAgC,CAAC;AACvC,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,eAAe,KAAK,YAAY;AACtC,oBAAc,KAAK,YAAY;AAAA,IACnC;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,SAAS,QAGiB;AAC5B,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAEhC,SAAK,KAAK,CAAC,OAAO,KAAK,OAAO,OAAO,CAAC;AAEtC,QAAI,SAAwC;AAC5C,QAAI,KAAK,KAAK,GAAG;AACb,eAAS,KAAK,YAAY;AAAA,IAC9B;AACA,SAAK,KAAK;AAEV,WAAO,QAAQ,SAAS;AAAA,EAC5B;AAAA,EAEA,MAAM,SAAS,QAIM;AACjB,UAAM,MACF;AACJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAEhC,SAAK,IAAI,CAAC,OAAO,KAAK,OAAO,SAAS,OAAO,KAAK,CAAC;AACnD,SAAK,KAAK;AAEV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,YAAY,QAGG;AACjB,QAAI;AACA,YAAM,MAAM;AACZ,YAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,WAAK,IAAI,CAAC,OAAO,KAAK,OAAO,OAAO,CAAC;AACrC,WAAK,KAAK;AACV,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,kBAAY,MAAM,wBAAwB,KAAK;AAC/C,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,MAAM,aAAa,QAKa;AAC5B,QAAI,MAAM;AACV,UAAM,cAAqB,CAAC,OAAO,OAAO;AAE1C,QAAI,OAAO,IAAI;AACX,aAAO;AACP,kBAAY,KAAK,OAAO,EAAE;AAAA,IAC9B;AAEA,QAAI,OAAO,OAAO;AACd,aAAO;AACP,kBAAY,KAAK,OAAO,KAAK;AAAA,IACjC;AAEA,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK,WAAW;AACrB,UAAM,UAA8B,CAAC;AAErC,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,MAAM,KAAK,YAAY;AAC7B,cAAQ,KAAK;AAAA,QACT,IAAI,IAAI;AAAA,QACR,SAAS,IAAI;AAAA,QACb,SAAS,KAAK,MAAM,IAAI,OAAO;AAAA,QAC/B,WAAW,IAAI,YAAY,IAAI,aAAa,IAAI,SAAS,IAAI;AAAA;AAAA,QAC7D,WAAW,IAAI;AAAA,MACnB,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,gBAAgB,QAMU;AAC5B,UAAM,WAAW,aAAa,OAAO,OAAO,IAAI,OAAO,UAAU;AACjE,UAAM,eAAe,MAAM,KAAK,SAAS;AAAA,MACrC,KAAK;AAAA,MACL,SAAS,OAAO;AAAA,IACpB,CAAC;AAED,QAAI,cAAc;AACd,aAAO,KAAK,MAAM,YAAY;AAAA,IAClC;AAEA,UAAM,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsCZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,KAAK;AAAA,MACN,IAAI,WAAW,OAAO,UAAU,MAAM;AAAA,MACtC,OAAO;AAAA,MACP,IAAI,OAAO,cAAc,EAAE;AAAA,MAC3B,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,IACX,CAAC;AAED,UAAM,UAA8B,CAAC;AACrC,WAAO,KAAK,KAAK,GAAG;AAChB,YAAM,MAAM,KAAK,YAAY;AAC7B,cAAQ,KAAK;AAAA,QACT,IAAI,IAAI;AAAA,QACR,SAAS,IAAI;AAAA,QACb,SAAS,KAAK,MAAM,IAAI,OAAO;AAAA,QAC/B,WAAW,IAAI,YAAY,IAAI,aAAa,IAAI,SAAS,IAAI;AAAA,QAC7D,WAAW,IAAI;AAAA,QACf,YAAY,IAAI;AAAA,MACpB,CAAC;AAAA,IACL;AACA,SAAK,KAAK;AAEV,UAAM,KAAK,SAAS;AAAA,MAChB,KAAK;AAAA,MACL,SAAS,OAAO;AAAA,MAChB,OAAO,KAAK,UAAU,OAAO;AAAA,IACjC,CAAC;AAED,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,gBAAgB,WAA4C;AAC9D,QAAI;AACA,YAAM,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAOZ,YAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,YAAM,WAAW,UAAU,QAAQ,YAAY,CAAC;AAEhD,WAAK,IAAI;AAAA,QACL,UAAU;AAAA,QACV,SAAS,WAAW,OAAO,UAAU;AAAA,QACrC,KAAK,UAAU,UAAU,OAAO;AAAA,QAChC,UAAU,YAAY,IAAI,WAAW,UAAU,UAAU,MAAM,IAAI;AAAA,QACnE,UAAU,aAAa,KAAK,IAAI;AAAA,QAChC,SAAS,SAAS,IAAI;AAAA,QACtB,SAAS,cAAc;AAAA,QACvB,SAAS,cAAc;AAAA,QACvB,SAAS,WAAW,IAAI;AAAA,MAC5B,CAAC;AACD,WAAK,KAAK;AAAA,IACd,SAAS,OAAY;AACjB,YAAM,WAAW,UAAU,QAAQ,UAAU;AAC7C,YAAM,oBAAoB,OAAO,SAAS;AAE1C,UAAI,YAAY,mBAAmB;AAC/B,oBAAY,KAAK,oBAAoB,UAAU,EAAE,2BAA2B;AAC5E;AAAA,MACJ,WAAW,CAAC,YAAY,CAAC,MAAM,SAAS,SAAS,8BAA8B,GAAG;AAC9E,oBAAY,MAAM,4BAA4B,UAAU,EAAE,KAAK;AAAA,UAC3D;AAAA,UACA,iBAAiB,UAAU,WAAW;AAAA,UACtC,SAAS,UAAU;AAAA,QACvB,CAAC;AACD,cAAM;AAAA,MACV;AAEA,kBAAY,MAAM,aAAa,UAAU,EAAE,2BAA2B;AAAA,IAC1E;AAAA,EACJ;AAAA,EAEA,MAAM,gBAAgB,IAAyB;AAC3C,UAAM,MAAM;AACZ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,EAAE,CAAC;AACb,SAAK,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,eAAe,SAAe,QAAiC;AACjE,UAAM,MAAM,SACR,kEACA;AAEJ,UAAM,OAAO,KAAK,GAAG,QAAQ,GAAG;AAChC,SAAK,IAAI,CAAC,OAAO,CAAC;AAClB,SAAK,KAAK;AAAA,EACd;AACJ;","names":[]}