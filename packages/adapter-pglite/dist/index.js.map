{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { v4 } from \"uuid\";\r\n\r\nimport {\r\n    Account,\r\n    Actor,\r\n    GoalStatus,\r\n    type Goal,\r\n    type Memory,\r\n    type Relationship,\r\n    type UUID,\r\n    type IDatabaseCacheAdapter,\r\n    Participant,\r\n    elizaLogger,\r\n    getEmbeddingConfig,\r\n    DatabaseAdapter,\r\n    EmbeddingProvider,\r\n    RAGKnowledgeItem,\r\n} from \"@elizaos/core\";\r\nimport fs from \"fs\";\r\nimport { fileURLToPath } from \"url\";\r\nimport path from \"path\";\r\nimport {\r\n    PGlite,\r\n    PGliteOptions,\r\n    Results,\r\n    Transaction,\r\n} from \"@electric-sql/pglite\";\r\nimport { vector } from \"@electric-sql/pglite/vector\";\r\nimport { fuzzystrmatch } from \"@electric-sql/pglite/contrib/fuzzystrmatch\";\r\n\r\nconst __filename = fileURLToPath(import.meta.url); // get the resolved path to the file\r\nconst __dirname = path.dirname(__filename); // get the name of the directory\r\n\r\nexport class PGLiteDatabaseAdapter\r\n    extends DatabaseAdapter<PGlite>\r\n    implements IDatabaseCacheAdapter\r\n{\r\n    constructor(options: PGliteOptions) {\r\n        super();\r\n        this.db = new PGlite({\r\n            ...options,\r\n            // Add the vector and fuzzystrmatch extensions\r\n            extensions: {\r\n                ...(options.extensions ?? {}),\r\n                vector,\r\n                fuzzystrmatch,\r\n            },\r\n        });\r\n    }\r\n\r\n    async init() {\r\n        await this.db.waitReady;\r\n\r\n        await this.withTransaction(async (tx) => {\r\n            // Set application settings for embedding dimension\r\n            const embeddingConfig = getEmbeddingConfig();\r\n            if (embeddingConfig.provider === EmbeddingProvider.OpenAI) {\r\n                await tx.query(\"SET app.use_openai_embedding = 'true'\");\r\n                await tx.query(\"SET app.use_ollama_embedding = 'false'\");\r\n                await tx.query(\"SET app.use_gaianet_embedding = 'false'\");\r\n            } else if (embeddingConfig.provider === EmbeddingProvider.Ollama) {\r\n                await tx.query(\"SET app.use_openai_embedding = 'false'\");\r\n                await tx.query(\"SET app.use_ollama_embedding = 'true'\");\r\n                await tx.query(\"SET app.use_gaianet_embedding = 'false'\");\r\n            } else if (embeddingConfig.provider === EmbeddingProvider.GaiaNet) {\r\n                await tx.query(\"SET app.use_openai_embedding = 'false'\");\r\n                await tx.query(\"SET app.use_ollama_embedding = 'false'\");\r\n                await tx.query(\"SET app.use_gaianet_embedding = 'true'\");\r\n            } else {\r\n                await tx.query(\"SET app.use_openai_embedding = 'false'\");\r\n                await tx.query(\"SET app.use_ollama_embedding = 'false'\");\r\n                await tx.query(\"SET app.use_gaianet_embedding = 'false'\");\r\n            }\r\n\r\n            const schema = fs.readFileSync(\r\n                path.resolve(__dirname, \"../schema.sql\"),\r\n                \"utf8\"\r\n            );\r\n            await tx.exec(schema);\r\n        }, \"init\");\r\n    }\r\n\r\n    async close() {\r\n        await this.db.close();\r\n    }\r\n\r\n    private async withDatabase<T>(\r\n        operation: () => Promise<T>,\r\n        context: string\r\n    ): Promise<T> {\r\n        return this.withCircuitBreaker(async () => {\r\n            return operation();\r\n        }, context);\r\n    }\r\n\r\n    private async withTransaction<T>(\r\n        operation: (tx: Transaction) => Promise<T>,\r\n        context: string\r\n    ): Promise<T | undefined> {\r\n        return this.withCircuitBreaker(async () => {\r\n            return this.db.transaction(operation);\r\n        }, context);\r\n    }\r\n\r\n    async query<R>(\r\n        queryTextOrConfig: string,\r\n        values?: unknown[]\r\n    ): Promise<Results<R>> {\r\n        return this.withDatabase(async () => {\r\n            return await this.db.query<R>(queryTextOrConfig, values);\r\n        }, \"query\");\r\n    }\r\n\r\n    async getRoom(roomId: UUID): Promise<UUID | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<{ id: UUID }>(\r\n                \"SELECT id FROM rooms WHERE id = $1\",\r\n                [roomId]\r\n            );\r\n            return rows.length > 0 ? rows[0].id : null;\r\n        }, \"getRoom\");\r\n    }\r\n\r\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<Participant>(\r\n                `SELECT id, \"userId\", \"roomId\", \"last_message_read\"\r\n                FROM participants\r\n                WHERE \"userId\" = $1`,\r\n                [userId]\r\n            );\r\n            return rows;\r\n        }, \"getParticipantsForAccount\");\r\n    }\r\n\r\n    async getParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID\r\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<{\r\n                userState: \"FOLLOWED\" | \"MUTED\";\r\n            }>(\r\n                `SELECT \"userState\" FROM participants WHERE \"roomId\" = $1 AND \"userId\" = $2`,\r\n                [roomId, userId]\r\n            );\r\n            return rows.length > 0 ? rows[0].userState : null;\r\n        }, \"getParticipantUserState\");\r\n    }\r\n\r\n    async getMemoriesByRoomIds(params: {\r\n        roomIds: UUID[];\r\n        agentId?: UUID;\r\n        tableName: string;\r\n    }): Promise<Memory[]> {\r\n        return this.withDatabase(async () => {\r\n            if (params.roomIds.length === 0) return [];\r\n            const placeholders = params.roomIds\r\n                .map((_, i) => `$${i + 2}`)\r\n                .join(\", \");\r\n\r\n            let query = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" IN (${placeholders})`;\r\n            let queryParams = [params.tableName, ...params.roomIds];\r\n\r\n            if (params.agentId) {\r\n                query += ` AND \"agentId\" = $${params.roomIds.length + 2}`;\r\n                queryParams = [...queryParams, params.agentId];\r\n            }\r\n\r\n            const { rows } = await this.query<Memory>(query, queryParams);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n            }));\r\n        }, \"getMemoriesByRoomIds\");\r\n    }\r\n\r\n    async setParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n        state: \"FOLLOWED\" | \"MUTED\" | null\r\n    ): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.query(\r\n                `UPDATE participants SET \"userState\" = $1 WHERE \"roomId\" = $2 AND \"userId\" = $3`,\r\n                [state, roomId, userId]\r\n            );\r\n        }, \"setParticipantUserState\");\r\n    }\r\n\r\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<{ userId: UUID }>(\r\n                'SELECT \"userId\" FROM participants WHERE \"roomId\" = $1',\r\n                [roomId]\r\n            );\r\n            return rows.map((row) => row.userId);\r\n        }, \"getParticipantsForRoom\");\r\n    }\r\n\r\n    async getAccountById(userId: UUID): Promise<Account | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<Account>(\r\n                \"SELECT * FROM accounts WHERE id = $1\",\r\n                [userId]\r\n            );\r\n            if (rows.length === 0) {\r\n                elizaLogger.debug(\"Account not found:\", { userId });\r\n                return null;\r\n            }\r\n\r\n            const account = rows[0];\r\n            // elizaLogger.debug(\"Account retrieved:\", {\r\n            //     userId,\r\n            //     hasDetails: !!account.details,\r\n            // });\r\n\r\n            return {\r\n                ...account,\r\n                details:\r\n                    typeof account.details === \"string\"\r\n                        ? JSON.parse(account.details)\r\n                        : account.details,\r\n            };\r\n        }, \"getAccountById\");\r\n    }\r\n\r\n    async createAccount(account: Account): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const accountId = account.id ?? v4();\r\n                await this.query(\r\n                    `INSERT INTO accounts (id, name, username, email, \"avatarUrl\", details)\r\n                    VALUES ($1, $2, $3, $4, $5, $6)`,\r\n                    [\r\n                        accountId,\r\n                        account.name,\r\n                        account.username || \"\",\r\n                        account.email || \"\",\r\n                        account.avatarUrl || \"\",\r\n                        JSON.stringify(account.details),\r\n                    ]\r\n                );\r\n                elizaLogger.debug(\"Account created successfully:\", {\r\n                    accountId,\r\n                });\r\n                return true;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error creating account:\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    accountId: account.id,\r\n                    name: account.name, // Only log non-sensitive fields\r\n                });\r\n                return false; // Return false instead of throwing to maintain existing behavior\r\n            }\r\n        }, \"createAccount\");\r\n    }\r\n\r\n    async getActorById(params: { roomId: UUID }): Promise<Actor[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<Actor>(\r\n                `SELECT a.id, a.name, a.username, a.details\r\n                FROM participants p\r\n                LEFT JOIN accounts a ON p.\"userId\" = a.id\r\n                WHERE p.\"roomId\" = $1`,\r\n                [params.roomId]\r\n            );\r\n\r\n            elizaLogger.debug(\"Retrieved actors:\", {\r\n                roomId: params.roomId,\r\n                actorCount: rows.length,\r\n            });\r\n\r\n            return rows.map((row) => {\r\n                try {\r\n                    return {\r\n                        ...row,\r\n                        details:\r\n                            typeof row.details === \"string\"\r\n                                ? JSON.parse(row.details)\r\n                                : row.details,\r\n                    };\r\n                } catch (error) {\r\n                    elizaLogger.warn(\"Failed to parse actor details:\", {\r\n                        actorId: row.id,\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                    });\r\n                    return {\r\n                        ...row,\r\n                        details: {}, // Provide default empty details on parse error\r\n                    };\r\n                }\r\n            });\r\n        }, \"getActorById\").catch((error) => {\r\n            elizaLogger.error(\"Failed to get actors:\", {\r\n                roomId: params.roomId,\r\n                error: error.message,\r\n            });\r\n            throw error; // Re-throw to let caller handle database errors\r\n        });\r\n    }\r\n\r\n    async getMemoryById(id: UUID): Promise<Memory | null> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<Memory>(\r\n                \"SELECT * FROM memories WHERE id = $1\",\r\n                [id]\r\n            );\r\n            if (rows.length === 0) return null;\r\n\r\n            return {\r\n                ...rows[0],\r\n                content:\r\n                    typeof rows[0].content === \"string\"\r\n                        ? JSON.parse(rows[0].content)\r\n                        : rows[0].content,\r\n            };\r\n        }, \"getMemoryById\");\r\n    }\r\n\r\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            elizaLogger.debug(\"PostgresAdapter createMemory:\", {\r\n                memoryId: memory.id,\r\n                embeddingLength: memory.embedding?.length,\r\n                contentLength: memory.content?.text?.length,\r\n            });\r\n\r\n            let isUnique = true;\r\n            if (memory.embedding) {\r\n                const similarMemories = await this.searchMemoriesByEmbedding(\r\n                    memory.embedding,\r\n                    {\r\n                        tableName,\r\n                        roomId: memory.roomId,\r\n                        match_threshold: 0.95,\r\n                        count: 1,\r\n                    }\r\n                );\r\n                isUnique = similarMemories.length === 0;\r\n            }\r\n\r\n            await this.query(\r\n                `INSERT INTO memories (\r\n                    id, type, content, embedding, \"userId\", \"roomId\", \"agentId\", \"unique\", \"createdAt\"\r\n                ) VALUES ($1, $2, $3, $4, $5::uuid, $6::uuid, $7::uuid, $8, to_timestamp($9/1000.0))`,\r\n                [\r\n                    memory.id ?? v4(),\r\n                    tableName,\r\n                    JSON.stringify(memory.content),\r\n                    memory.embedding ? `[${memory.embedding.join(\",\")}]` : null,\r\n                    memory.userId,\r\n                    memory.roomId,\r\n                    memory.agentId,\r\n                    memory.unique ?? isUnique,\r\n                    Date.now(),\r\n                ]\r\n            );\r\n        }, \"createMemory\");\r\n    }\r\n\r\n    async searchMemories(params: {\r\n        tableName: string;\r\n        agentId: UUID;\r\n        roomId: UUID;\r\n        embedding: number[];\r\n        match_threshold: number;\r\n        match_count: number;\r\n        unique: boolean;\r\n    }): Promise<Memory[]> {\r\n        return await this.searchMemoriesByEmbedding(params.embedding, {\r\n            match_threshold: params.match_threshold,\r\n            count: params.match_count,\r\n            agentId: params.agentId,\r\n            roomId: params.roomId,\r\n            unique: params.unique,\r\n            tableName: params.tableName,\r\n        });\r\n    }\r\n\r\n    async getMemories(params: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        tableName: string;\r\n        agentId?: UUID;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]> {\r\n        // Parameter validation\r\n        if (!params.tableName) throw new Error(\"tableName is required\");\r\n        if (!params.roomId) throw new Error(\"roomId is required\");\r\n\r\n        return this.withDatabase(async () => {\r\n            // Build query\r\n            let sql = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" = $2`;\r\n            const values: unknown[] = [params.tableName, params.roomId];\r\n            let paramCount = 2;\r\n\r\n            // Add time range filters\r\n            if (params.start) {\r\n                paramCount++;\r\n                sql += ` AND \"createdAt\" >= to_timestamp($${paramCount})`;\r\n                values.push(params.start / 1000);\r\n            }\r\n\r\n            if (params.end) {\r\n                paramCount++;\r\n                sql += ` AND \"createdAt\" <= to_timestamp($${paramCount})`;\r\n                values.push(params.end / 1000);\r\n            }\r\n\r\n            // Add other filters\r\n            if (params.unique) {\r\n                sql += ` AND \"unique\" = true`;\r\n            }\r\n\r\n            if (params.agentId) {\r\n                paramCount++;\r\n                sql += ` AND \"agentId\" = $${paramCount}`;\r\n                values.push(params.agentId);\r\n            }\r\n\r\n            // Add ordering and limit\r\n            sql += ' ORDER BY \"createdAt\" DESC';\r\n\r\n            if (params.count) {\r\n                paramCount++;\r\n                sql += ` LIMIT $${paramCount}`;\r\n                values.push(params.count);\r\n            }\r\n\r\n            elizaLogger.debug(\"Fetching memories:\", {\r\n                roomId: params.roomId,\r\n                tableName: params.tableName,\r\n                unique: params.unique,\r\n                agentId: params.agentId,\r\n                timeRange:\r\n                    params.start || params.end\r\n                        ? {\r\n                              start: params.start\r\n                                  ? new Date(params.start).toISOString()\r\n                                  : undefined,\r\n                              end: params.end\r\n                                  ? new Date(params.end).toISOString()\r\n                                  : undefined,\r\n                          }\r\n                        : undefined,\r\n                limit: params.count,\r\n            });\r\n\r\n            const { rows } = await this.query<Memory>(sql, values);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n            }));\r\n        }, \"getMemories\");\r\n    }\r\n\r\n    async getGoals(params: {\r\n        roomId: UUID;\r\n        userId?: UUID | null;\r\n        onlyInProgress?: boolean;\r\n        count?: number;\r\n    }): Promise<Goal[]> {\r\n        return this.withDatabase(async () => {\r\n            let sql = `SELECT * FROM goals WHERE \"roomId\" = $1`;\r\n            const values: unknown[] = [params.roomId];\r\n            let paramCount = 1;\r\n\r\n            if (params.userId) {\r\n                paramCount++;\r\n                sql += ` AND \"userId\" = $${paramCount}`;\r\n                values.push(params.userId);\r\n            }\r\n\r\n            if (params.onlyInProgress) {\r\n                sql += \" AND status = 'IN_PROGRESS'\";\r\n            }\r\n\r\n            if (params.count) {\r\n                paramCount++;\r\n                sql += ` LIMIT $${paramCount}`;\r\n                values.push(params.count);\r\n            }\r\n\r\n            const { rows } = await this.query<Goal>(sql, values);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                objectives:\r\n                    typeof row.objectives === \"string\"\r\n                        ? JSON.parse(row.objectives)\r\n                        : row.objectives,\r\n            }));\r\n        }, \"getGoals\");\r\n    }\r\n\r\n    async updateGoal(goal: Goal): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                await this.query(\r\n                    `UPDATE goals SET name = $1, status = $2, objectives = $3 WHERE id = $4`,\r\n                    [\r\n                        goal.name,\r\n                        goal.status,\r\n                        JSON.stringify(goal.objectives),\r\n                        goal.id,\r\n                    ]\r\n                );\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to update goal:\", {\r\n                    goalId: goal.id,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    status: goal.status,\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"updateGoal\");\r\n    }\r\n\r\n    async createGoal(goal: Goal): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.query(\r\n                `INSERT INTO goals (id, \"roomId\", \"userId\", name, status, objectives)\r\n                VALUES ($1, $2, $3, $4, $5, $6)`,\r\n                [\r\n                    goal.id ?? v4(),\r\n                    goal.roomId,\r\n                    goal.userId,\r\n                    goal.name,\r\n                    goal.status,\r\n                    JSON.stringify(goal.objectives),\r\n                ]\r\n            );\r\n        }, \"createGoal\");\r\n    }\r\n\r\n    async removeGoal(goalId: UUID): Promise<void> {\r\n        if (!goalId) throw new Error(\"Goal ID is required\");\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const result = await this.query(\r\n                    \"DELETE FROM goals WHERE id = $1 RETURNING id\",\r\n                    [goalId]\r\n                );\r\n\r\n                elizaLogger.debug(\"Goal removal attempt:\", {\r\n                    goalId,\r\n                    removed: result?.affectedRows ?? 0 > 0,\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to remove goal:\", {\r\n                    goalId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"removeGoal\");\r\n    }\r\n\r\n    async createRoom(roomId?: UUID): Promise<UUID> {\r\n        return this.withDatabase(async () => {\r\n            const newRoomId = roomId || v4();\r\n            await this.query(\"INSERT INTO rooms (id) VALUES ($1)\", [newRoomId]);\r\n            return newRoomId as UUID;\r\n        }, \"createRoom\");\r\n    }\r\n\r\n    async removeRoom(roomId: UUID): Promise<void> {\r\n        if (!roomId) throw new Error(\"Room ID is required\");\r\n\r\n        return this.withTransaction(async (tx) => {\r\n            try {\r\n                // First check if room exists\r\n                const checkResult = await tx.query(\r\n                    \"SELECT id FROM rooms WHERE id = $1\",\r\n                    [roomId]\r\n                );\r\n\r\n                if (checkResult.rows.length === 0) {\r\n                    elizaLogger.warn(\"No room found to remove:\", {\r\n                        roomId,\r\n                    });\r\n                    throw new Error(`Room not found: ${roomId}`);\r\n                }\r\n\r\n                // Remove related data first (if not using CASCADE)\r\n                await tx.query('DELETE FROM memories WHERE \"roomId\" = $1', [\r\n                    roomId,\r\n                ]);\r\n                await tx.query('DELETE FROM participants WHERE \"roomId\" = $1', [\r\n                    roomId,\r\n                ]);\r\n                await tx.query('DELETE FROM goals WHERE \"roomId\" = $1', [\r\n                    roomId,\r\n                ]);\r\n\r\n                // Finally remove the room\r\n                const result = await tx.query(\r\n                    \"DELETE FROM rooms WHERE id = $1 RETURNING id\",\r\n                    [roomId]\r\n                );\r\n\r\n                elizaLogger.debug(\r\n                    \"Room and related data removed successfully:\",\r\n                    {\r\n                        roomId,\r\n                        removed: result?.affectedRows ?? 0 > 0,\r\n                    }\r\n                );\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to remove room:\", {\r\n                    roomId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"removeRoom\");\r\n    }\r\n\r\n    async createRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<boolean> {\r\n        // Input validation\r\n        if (!params.userA || !params.userB) {\r\n            throw new Error(\"userA and userB are required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const relationshipId = v4();\r\n                await this.query(\r\n                    `INSERT INTO relationships (id, \"userA\", \"userB\", \"userId\")\r\n                    VALUES ($1, $2, $3, $4)\r\n                    RETURNING id`,\r\n                    [relationshipId, params.userA, params.userB, params.userA]\r\n                );\r\n\r\n                elizaLogger.debug(\"Relationship created successfully:\", {\r\n                    relationshipId,\r\n                    userA: params.userA,\r\n                    userB: params.userB,\r\n                });\r\n\r\n                return true;\r\n            } catch (error) {\r\n                // Check for unique constraint violation or other specific errors\r\n                if ((error as { code?: string }).code === \"23505\") {\r\n                    // Unique violation\r\n                    elizaLogger.warn(\"Relationship already exists:\", {\r\n                        userA: params.userA,\r\n                        userB: params.userB,\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                    });\r\n                } else {\r\n                    elizaLogger.error(\"Failed to create relationship:\", {\r\n                        userA: params.userA,\r\n                        userB: params.userB,\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                    });\r\n                }\r\n                return false;\r\n            }\r\n        }, \"createRelationship\");\r\n    }\r\n\r\n    async getRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<Relationship | null> {\r\n        if (!params.userA || !params.userB) {\r\n            throw new Error(\"userA and userB are required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const { rows } = await this.query<Relationship>(\r\n                    `SELECT * FROM relationships\r\n                    WHERE (\"userA\" = $1 AND \"userB\" = $2)\r\n                    OR (\"userA\" = $2 AND \"userB\" = $1)`,\r\n                    [params.userA, params.userB]\r\n                );\r\n\r\n                if (rows.length > 0) {\r\n                    elizaLogger.debug(\"Relationship found:\", {\r\n                        relationshipId: rows[0].id,\r\n                        userA: params.userA,\r\n                        userB: params.userB,\r\n                    });\r\n                    return rows[0];\r\n                }\r\n\r\n                elizaLogger.debug(\"No relationship found between users:\", {\r\n                    userA: params.userA,\r\n                    userB: params.userB,\r\n                });\r\n                return null;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching relationship:\", {\r\n                    userA: params.userA,\r\n                    userB: params.userB,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"getRelationship\");\r\n    }\r\n\r\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\r\n        if (!params.userId) {\r\n            throw new Error(\"userId is required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const { rows } = await this.query<Relationship>(\r\n                    `SELECT * FROM relationships\r\n                    WHERE \"userA\" = $1 OR \"userB\" = $1\r\n                    ORDER BY \"createdAt\" DESC`, // Add ordering if you have this field\r\n                    [params.userId]\r\n                );\r\n\r\n                elizaLogger.debug(\"Retrieved relationships:\", {\r\n                    userId: params.userId,\r\n                    count: rows.length,\r\n                });\r\n\r\n                return rows;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to fetch relationships:\", {\r\n                    userId: params.userId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"getRelationships\");\r\n    }\r\n\r\n    async getCachedEmbeddings(opts: {\r\n        query_table_name: string;\r\n        query_threshold: number;\r\n        query_input: string;\r\n        query_field_name: string;\r\n        query_field_sub_name: string;\r\n        query_match_count: number;\r\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\r\n        // Input validation\r\n        if (!opts.query_table_name)\r\n            throw new Error(\"query_table_name is required\");\r\n        if (!opts.query_input) throw new Error(\"query_input is required\");\r\n        if (!opts.query_field_name)\r\n            throw new Error(\"query_field_name is required\");\r\n        if (!opts.query_field_sub_name)\r\n            throw new Error(\"query_field_sub_name is required\");\r\n        if (opts.query_match_count <= 0)\r\n            throw new Error(\"query_match_count must be positive\");\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                elizaLogger.debug(\"Fetching cached embeddings:\", {\r\n                    tableName: opts.query_table_name,\r\n                    fieldName: opts.query_field_name,\r\n                    subFieldName: opts.query_field_sub_name,\r\n                    matchCount: opts.query_match_count,\r\n                    inputLength: opts.query_input.length,\r\n                });\r\n\r\n                const sql = `\r\n                    WITH content_text AS (\r\n                        SELECT\r\n                            embedding,\r\n                            COALESCE(\r\n                                content->$2->>$3,\r\n                                ''\r\n                            ) as content_text\r\n                        FROM memories\r\n                        WHERE type = $4\r\n                        AND content->$2->>$3 IS NOT NULL\r\n                    )\r\n                    SELECT\r\n                        embedding,\r\n                        levenshtein(\r\n                            $1,\r\n                            content_text\r\n                        ) as levenshtein_score\r\n                    FROM content_text\r\n                    WHERE levenshtein(\r\n                        $1,\r\n                        content_text\r\n                    ) <= $6  -- Add threshold check\r\n                    ORDER BY levenshtein_score\r\n                    LIMIT $5\r\n                `;\r\n\r\n                const { rows } = await this.query<{\r\n                    embedding: number[];\r\n                    levenshtein_score: number;\r\n                }>(sql, [\r\n                    opts.query_input,\r\n                    opts.query_field_name,\r\n                    opts.query_field_sub_name,\r\n                    opts.query_table_name,\r\n                    opts.query_match_count,\r\n                    opts.query_threshold,\r\n                ]);\r\n\r\n                elizaLogger.debug(\"Retrieved cached embeddings:\", {\r\n                    count: rows.length,\r\n                    tableName: opts.query_table_name,\r\n                    matchCount: opts.query_match_count,\r\n                });\r\n\r\n                return rows\r\n                    .map(\r\n                        (\r\n                            row\r\n                        ): {\r\n                            embedding: number[];\r\n                            levenshtein_score: number;\r\n                        } | null => {\r\n                            if (!Array.isArray(row.embedding)) return null;\r\n                            return {\r\n                                embedding: row.embedding,\r\n                                levenshtein_score: Number(\r\n                                    row.levenshtein_score\r\n                                ),\r\n                            };\r\n                        }\r\n                    )\r\n                    .filter(\r\n                        (\r\n                            row\r\n                        ): row is {\r\n                            embedding: number[];\r\n                            levenshtein_score: number;\r\n                        } => row !== null\r\n                    );\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error in getCachedEmbeddings:\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    tableName: opts.query_table_name,\r\n                    fieldName: opts.query_field_name,\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"getCachedEmbeddings\");\r\n    }\r\n\r\n    async log(params: {\r\n        body: { [key: string]: unknown };\r\n        userId: UUID;\r\n        roomId: UUID;\r\n        type: string;\r\n    }): Promise<void> {\r\n        // Input validation\r\n        if (!params.userId) throw new Error(\"userId is required\");\r\n        if (!params.roomId) throw new Error(\"roomId is required\");\r\n        if (!params.type) throw new Error(\"type is required\");\r\n        if (!params.body || typeof params.body !== \"object\") {\r\n            throw new Error(\"body must be a valid object\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const logId = v4(); // Generate ID for tracking\r\n                await this.query(\r\n                    `INSERT INTO logs (\r\n                        id,\r\n                        body,\r\n                        \"userId\",\r\n                        \"roomId\",\r\n                        type,\r\n                        \"createdAt\"\r\n                    ) VALUES ($1, $2, $3, $4, $5, NOW())\r\n                    RETURNING id`,\r\n                    [\r\n                        logId,\r\n                        JSON.stringify(params.body), // Ensure body is stringified\r\n                        params.userId,\r\n                        params.roomId,\r\n                        params.type,\r\n                    ]\r\n                );\r\n\r\n                elizaLogger.debug(\"Log entry created:\", {\r\n                    logId,\r\n                    type: params.type,\r\n                    roomId: params.roomId,\r\n                    userId: params.userId,\r\n                    bodyKeys: Object.keys(params.body),\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to create log entry:\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    type: params.type,\r\n                    roomId: params.roomId,\r\n                    userId: params.userId,\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"log\");\r\n    }\r\n\r\n    async searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        params: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            agentId?: UUID;\r\n            roomId?: UUID;\r\n            unique?: boolean;\r\n            tableName: string;\r\n        }\r\n    ): Promise<Memory[]> {\r\n        return this.withDatabase(async () => {\r\n            elizaLogger.debug(\"Incoming vector:\", {\r\n                length: embedding.length,\r\n                sample: embedding.slice(0, 5),\r\n                isArray: Array.isArray(embedding),\r\n                allNumbers: embedding.every((n) => typeof n === \"number\"),\r\n            });\r\n\r\n            // Validate embedding dimension\r\n            if (embedding.length !== getEmbeddingConfig().dimensions) {\r\n                throw new Error(\r\n                    `Invalid embedding dimension: expected ${getEmbeddingConfig().dimensions}, got ${embedding.length}`\r\n                );\r\n            }\r\n\r\n            // Ensure vector is properly formatted\r\n            const cleanVector = embedding.map((n) => {\r\n                if (!Number.isFinite(n)) return 0;\r\n                // Limit precision to avoid floating point issues\r\n                return Number(n.toFixed(6));\r\n            });\r\n\r\n            // Format for Postgres pgvector\r\n            const vectorStr = `[${cleanVector.join(\",\")}]`;\r\n\r\n            elizaLogger.debug(\"Vector debug:\", {\r\n                originalLength: embedding.length,\r\n                cleanLength: cleanVector.length,\r\n                sampleStr: vectorStr.slice(0, 100),\r\n            });\r\n\r\n            let sql = `\r\n                SELECT *,\r\n                1 - (embedding <-> $1::vector(${getEmbeddingConfig().dimensions})) as similarity\r\n                FROM memories\r\n                WHERE type = $2\r\n            `;\r\n\r\n            const values: unknown[] = [vectorStr, params.tableName];\r\n\r\n            // Log the query for debugging\r\n            elizaLogger.debug(\"Query debug:\", {\r\n                sql: sql.slice(0, 200),\r\n                paramTypes: values.map((v) => typeof v),\r\n                vectorStrLength: vectorStr.length,\r\n            });\r\n\r\n            let paramCount = 2;\r\n\r\n            if (params.unique) {\r\n                sql += ` AND \"unique\" = true`;\r\n            }\r\n\r\n            if (params.agentId) {\r\n                paramCount++;\r\n                sql += ` AND \"agentId\" = $${paramCount}`;\r\n                values.push(params.agentId);\r\n            }\r\n\r\n            if (params.roomId) {\r\n                paramCount++;\r\n                sql += ` AND \"roomId\" = $${paramCount}::uuid`;\r\n                values.push(params.roomId);\r\n            }\r\n\r\n            if (params.match_threshold) {\r\n                paramCount++;\r\n                sql += ` AND 1 - (embedding <-> $1::vector) >= $${paramCount}`;\r\n                values.push(params.match_threshold);\r\n            }\r\n\r\n            sql += ` ORDER BY embedding <-> $1::vector`;\r\n\r\n            if (params.count) {\r\n                paramCount++;\r\n                sql += ` LIMIT $${paramCount}`;\r\n                values.push(params.count);\r\n            }\r\n\r\n            const { rows } = await this.query<Memory>(sql, values);\r\n            return rows.map((row) => ({\r\n                ...row,\r\n                content:\r\n                    typeof row.content === \"string\"\r\n                        ? JSON.parse(row.content)\r\n                        : row.content,\r\n                similarity: row.similarity,\r\n            }));\r\n        }, \"searchMemoriesByEmbedding\");\r\n    }\r\n\r\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                await this.query(\r\n                    `INSERT INTO participants (id, \"userId\", \"roomId\")\r\n                    VALUES ($1, $2, $3)`,\r\n                    [v4(), userId, roomId]\r\n                );\r\n                return true;\r\n            } catch (error) {\r\n                console.log(\"Error adding participant\", error);\r\n                return false;\r\n            }\r\n        }, \"addParticpant\");\r\n    }\r\n\r\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                await this.query(\r\n                    `DELETE FROM participants WHERE \"userId\" = $1 AND \"roomId\" = $2`,\r\n                    [userId, roomId]\r\n                );\r\n                return true;\r\n            } catch (error) {\r\n                console.log(\"Error removing participant\", error);\r\n                return false;\r\n            }\r\n        }, \"removeParticipant\");\r\n    }\r\n\r\n    async updateGoalStatus(params: {\r\n        goalId: UUID;\r\n        status: GoalStatus;\r\n    }): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.query(\"UPDATE goals SET status = $1 WHERE id = $2\", [\r\n                params.status,\r\n                params.goalId,\r\n            ]);\r\n        }, \"updateGoalStatus\");\r\n    }\r\n\r\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.query(\r\n                \"DELETE FROM memories WHERE type = $1 AND id = $2\",\r\n                [tableName, memoryId]\r\n            );\r\n        }, \"removeMemory\");\r\n    }\r\n\r\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.query(\r\n                `DELETE FROM memories WHERE type = $1 AND \"roomId\" = $2`,\r\n                [tableName, roomId]\r\n            );\r\n        }, \"removeAllMemories\");\r\n    }\r\n\r\n    async countMemories(\r\n        roomId: UUID,\r\n        unique = true,\r\n        tableName = \"\"\r\n    ): Promise<number> {\r\n        if (!tableName) throw new Error(\"tableName is required\");\r\n\r\n        return this.withDatabase(async () => {\r\n            let sql = `SELECT COUNT(*) as count FROM memories WHERE type = $1 AND \"roomId\" = $2`;\r\n            if (unique) {\r\n                sql += ` AND \"unique\" = true`;\r\n            }\r\n\r\n            const { rows } = await this.query<{ count: number }>(sql, [\r\n                tableName,\r\n                roomId,\r\n            ]);\r\n            return rows[0].count;\r\n        }, \"countMemories\");\r\n    }\r\n\r\n    async removeAllGoals(roomId: UUID): Promise<void> {\r\n        return this.withDatabase(async () => {\r\n            await this.query(`DELETE FROM goals WHERE \"roomId\" = $1`, [roomId]);\r\n        }, \"removeAllGoals\");\r\n    }\r\n\r\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\r\n        return this.withDatabase(async () => {\r\n            const { rows } = await this.query<{ roomId: UUID }>(\r\n                `SELECT \"roomId\" FROM participants WHERE \"userId\" = $1`,\r\n                [userId]\r\n            );\r\n            return rows.map((row) => row.roomId);\r\n        }, \"getRoomsForParticipant\");\r\n    }\r\n\r\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\r\n        return this.withDatabase(async () => {\r\n            const placeholders = userIds.map((_, i) => `$${i + 1}`).join(\", \");\r\n            const { rows } = await this.query<{ roomId: UUID }>(\r\n                `SELECT DISTINCT \"roomId\" FROM participants WHERE \"userId\" IN (${placeholders})`,\r\n                userIds\r\n            );\r\n            return rows.map((row) => row.roomId);\r\n        }, \"getRoomsForParticipants\");\r\n    }\r\n\r\n    async getActorDetails(params: { roomId: string }): Promise<Actor[]> {\r\n        if (!params.roomId) {\r\n            throw new Error(\"roomId is required\");\r\n        }\r\n\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const sql = `\r\n                    SELECT\r\n                        a.id,\r\n                        a.name,\r\n                        a.username,\r\n                        a.\"avatarUrl\",\r\n                        COALESCE(a.details::jsonb, '{}'::jsonb) as details\r\n                    FROM participants p\r\n                    LEFT JOIN accounts a ON p.\"userId\" = a.id\r\n                    WHERE p.\"roomId\" = $1\r\n                    ORDER BY a.name\r\n                `;\r\n\r\n                const result = await this.query<Actor>(sql, [params.roomId]);\r\n\r\n                elizaLogger.debug(\"Retrieved actor details:\", {\r\n                    roomId: params.roomId,\r\n                    actorCount: result.rows.length,\r\n                });\r\n\r\n                return result.rows.map((row) => {\r\n                    try {\r\n                        return {\r\n                            ...row,\r\n                            details:\r\n                                typeof row.details === \"string\"\r\n                                    ? JSON.parse(row.details)\r\n                                    : row.details,\r\n                        };\r\n                    } catch (parseError) {\r\n                        elizaLogger.warn(\"Failed to parse actor details:\", {\r\n                            actorId: row.id,\r\n                            error:\r\n                                parseError instanceof Error\r\n                                    ? parseError.message\r\n                                    : String(parseError),\r\n                        });\r\n                        return {\r\n                            ...row,\r\n                            details: {}, // Fallback to empty object if parsing fails\r\n                        };\r\n                    }\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to fetch actor details:\", {\r\n                    roomId: params.roomId,\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw new Error(\r\n                    `Failed to fetch actor details: ${error instanceof Error ? error.message : String(error)}`\r\n                );\r\n            }\r\n        }, \"getActorDetails\");\r\n    }\r\n\r\n    async getCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<string | undefined> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                const sql = `SELECT \"value\"::TEXT FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`;\r\n                const { rows } = await this.query<{ value: string }>(sql, [\r\n                    params.key,\r\n                    params.agentId,\r\n                ]);\r\n                return rows[0]?.value ?? undefined;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching cache\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    key: params.key,\r\n                    agentId: params.agentId,\r\n                });\r\n                return undefined;\r\n            }\r\n        }, \"getCache\");\r\n    }\r\n\r\n    async setCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n        value: string;\r\n    }): Promise<boolean> {\r\n        return (\r\n            (await this.withTransaction(async (tx) => {\r\n                try {\r\n                    await tx.query(\r\n                        `INSERT INTO cache (\"key\", \"agentId\", \"value\", \"createdAt\")\r\n                                 VALUES ($1, $2, $3, CURRENT_TIMESTAMP)\r\n                                 ON CONFLICT (\"key\", \"agentId\")\r\n                                 DO UPDATE SET \"value\" = EXCLUDED.value, \"createdAt\" = CURRENT_TIMESTAMP`,\r\n                        [params.key, params.agentId, params.value]\r\n                    );\r\n                    return true;\r\n                } catch (error) {\r\n                    await tx.rollback();\r\n                    elizaLogger.error(\"Error setting cache\", {\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                        key: params.key,\r\n                        agentId: params.agentId,\r\n                    });\r\n                    return false;\r\n                }\r\n            }, \"setCache\")) ?? false\r\n        );\r\n    }\r\n\r\n    async deleteCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<boolean> {\r\n        return (\r\n            (await this.withTransaction(async (tx) => {\r\n                try {\r\n                    await tx.query(\r\n                        `DELETE FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`,\r\n                        [params.key, params.agentId]\r\n                    );\r\n                    return true;\r\n                } catch (error) {\r\n                    tx.rollback();\r\n                    elizaLogger.error(\"Error deleting cache\", {\r\n                        error:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                        key: params.key,\r\n                        agentId: params.agentId,\r\n                    });\r\n                    return false;\r\n                }\r\n            }, \"deleteCache\")) ?? false\r\n        );\r\n    }\r\n\r\n    async getKnowledge(params: {\r\n        id?: UUID;\r\n        agentId: UUID;\r\n        limit?: number;\r\n        query?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        return this.withDatabase(async () => {\r\n            try {\r\n                let sql = `SELECT * FROM knowledge WHERE (\"agentId\" = $1 OR \"isShared\" = true)`;\r\n                const queryParams: any[] = [params.agentId];\r\n                let paramCount = 1;\r\n\r\n                if (params.id) {\r\n                    paramCount++;\r\n                    sql += ` AND id = $${paramCount}`;\r\n                    queryParams.push(params.id);\r\n                }\r\n\r\n                if (params.limit) {\r\n                    paramCount++;\r\n                    sql += ` LIMIT $${paramCount}`;\r\n                    queryParams.push(params.limit);\r\n                }\r\n\r\n                const { rows } = await this.query<RAGKnowledgeItem>(\r\n                    sql,\r\n                    queryParams\r\n                );\r\n\r\n                return rows.map((row) => ({\r\n                    id: row.id,\r\n                    agentId: row.agentId,\r\n                    content:\r\n                        typeof row.content === \"string\"\r\n                            ? JSON.parse(row.content)\r\n                            : row.content,\r\n                    embedding: row.embedding\r\n                        ? new Float32Array(row.embedding)\r\n                        : undefined,\r\n                    createdAt: row.createdAt\r\n                        ? new Date(row.createdAt).getTime()\r\n                        : undefined,\r\n                }));\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error getting knowledge\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    id: params.id,\r\n                    agentId: params.agentId,\r\n                });\r\n                throw new Error(\r\n                    `Failed to getting knowledge: ${error instanceof Error ? error.message : String(error)}`\r\n                );\r\n            }\r\n        }, \"getKnowledge\");\r\n    }\r\n\r\n    async searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        return this.withDatabase(async () => {\r\n            interface KnowledgeSearchRow {\r\n                id: UUID;\r\n                agentId: UUID;\r\n                content: string;\r\n                embedding: Buffer | null;\r\n                createdAt: string | number;\r\n                vector_score: number;\r\n                keyword_score: number;\r\n                combined_score: number;\r\n            }\r\n            try {\r\n                const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\r\n                const cachedResult = await this.getCache({\r\n                    key: cacheKey,\r\n                    agentId: params.agentId,\r\n                });\r\n\r\n                if (cachedResult) {\r\n                    return JSON.parse(cachedResult);\r\n                }\r\n\r\n                const vectorStr = `[${Array.from(params.embedding).join(\",\")}]`;\r\n\r\n                const sql = `\r\n                WITH vector_scores AS (\r\n                    SELECT id,\r\n                        1 - (embedding <-> $1::vector) as vector_score\r\n                    FROM knowledge\r\n                    WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR \"agentId\" = $2\r\n                    AND embedding IS NOT NULL\r\n                ),\r\n                keyword_matches AS (\r\n                    SELECT id,\r\n                    CASE\r\n                        WHEN content->>'text' ILIKE $3 THEN 3.0\r\n                        ELSE 1.0\r\n                    END *\r\n                    CASE\r\n                        WHEN (content->'metadata'->>'isChunk')::boolean = true THEN 1.5\r\n                        WHEN (content->'metadata'->>'isMain')::boolean = true THEN 1.2\r\n                        ELSE 1.0\r\n                    END as keyword_score\r\n                    FROM knowledge\r\n                    WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR \"agentId\" = $2\r\n                )\r\n                SELECT k.*,\r\n                    v.vector_score,\r\n                    kw.keyword_score,\r\n                    (v.vector_score * kw.keyword_score) as combined_score\r\n                FROM knowledge k\r\n                JOIN vector_scores v ON k.id = v.id\r\n                LEFT JOIN keyword_matches kw ON k.id = kw.id\r\n                WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR k.\"agentId\" = $2\r\n                AND (\r\n                    v.vector_score >= $4\r\n                    OR (kw.keyword_score > 1.0 AND v.vector_score >= 0.3)\r\n                )\r\n                ORDER BY combined_score DESC\r\n                LIMIT $5\r\n            `;\r\n\r\n                const { rows } = await this.query<KnowledgeSearchRow>(sql, [\r\n                    vectorStr,\r\n                    params.agentId,\r\n                    `%${params.searchText || \"\"}%`,\r\n                    params.match_threshold,\r\n                    params.match_count,\r\n                ]);\r\n\r\n                const results = rows.map((row) => ({\r\n                    id: row.id,\r\n                    agentId: row.agentId,\r\n                    content:\r\n                        typeof row.content === \"string\"\r\n                            ? JSON.parse(row.content)\r\n                            : row.content,\r\n                    embedding: row.embedding\r\n                        ? new Float32Array(row.embedding)\r\n                        : undefined,\r\n                    createdAt: row.createdAt\r\n                        ? new Date(row.createdAt).getTime()\r\n                        : undefined,\r\n                    similarity: row.combined_score,\r\n                }));\r\n\r\n                await this.setCache({\r\n                    key: cacheKey,\r\n                    agentId: params.agentId,\r\n                    value: JSON.stringify(results),\r\n                });\r\n\r\n                return results;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error searching knowledge\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    searchText: params.searchText,\r\n                    agentId: params.agentId,\r\n                });\r\n                throw new Error(\r\n                    `Failed to search knowledge: ${error instanceof Error ? error.message : String(error)}`\r\n                );\r\n            }\r\n        }, \"searchKnowledge\");\r\n    }\r\n\r\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\r\n        return this.withTransaction(async (tx) => {\r\n            try {\r\n                const sql = `\r\n                    INSERT INTO knowledge (\r\n                        id, \"agentId\", content, embedding, \"createdAt\",\r\n                        \"isMain\", \"originalId\", \"chunkIndex\", \"isShared\"\r\n                    ) VALUES ($1, $2, $3, $4, to_timestamp($5/1000.0), $6, $7, $8, $9)\r\n                    ON CONFLICT (id) DO NOTHING\r\n                `;\r\n\r\n                const metadata = knowledge.content.metadata || {};\r\n                const vectorStr = knowledge.embedding\r\n                    ? `[${Array.from(knowledge.embedding).join(\",\")}]`\r\n                    : null;\r\n\r\n                await tx.query(sql, [\r\n                    knowledge.id,\r\n                    metadata.isShared ? null : knowledge.agentId,\r\n                    knowledge.content,\r\n                    vectorStr,\r\n                    knowledge.createdAt || Date.now(),\r\n                    metadata.isMain || false,\r\n                    metadata.originalId || null,\r\n                    metadata.chunkIndex || null,\r\n                    metadata.isShared || false,\r\n                ]);\r\n            } catch (error) {\r\n                elizaLogger.error(\"Failed to create knowledge:\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                });\r\n                throw error;\r\n            }\r\n        }, \"createKnowledge\");\r\n    }\r\n\r\n    async removeKnowledge(id: UUID): Promise<void> {\r\n        return await this.withTransaction(async (tx) => {\r\n            try {\r\n                await tx.query(\"DELETE FROM knowledge WHERE id = $1\", [id]);\r\n            } catch (error) {\r\n                tx.rollback();\r\n                elizaLogger.error(\"Error removing knowledge\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    id,\r\n                });\r\n            }\r\n        }, \"removeKnowledge\");\r\n    }\r\n\r\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\r\n        return await this.withTransaction(async (tx) => {\r\n            try {\r\n                const sql = shared\r\n                    ? 'DELETE FROM knowledge WHERE (\"agentId\" = $1 OR \"isShared\" = true)'\r\n                    : 'DELETE FROM knowledge WHERE \"agentId\" = $1';\r\n                await tx.query(sql, [agentId]);\r\n            } catch (error) {\r\n                tx.rollback();\r\n                elizaLogger.error(\"Error clearing knowledge\", {\r\n                    error:\r\n                        error instanceof Error ? error.message : String(error),\r\n                    agentId,\r\n                });\r\n            }\r\n        }, \"clearKnowledge\");\r\n    }\r\n}\r\n\r\nexport default PGLiteDatabaseAdapter;\r\n"],"mappings":"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","names":[]}