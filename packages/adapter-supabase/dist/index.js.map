{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { createClient, type SupabaseClient } from \"@supabase/supabase-js\";\r\nimport {\r\n    type Memory,\r\n    type Goal,\r\n    type Relationship,\r\n    Actor,\r\n    GoalStatus,\r\n    Account,\r\n    type UUID,\r\n    Participant,\r\n    Room,\r\n    RAGKnowledgeItem,\r\n    elizaLogger\r\n} from \"@elizaos/core\";\r\nimport { DatabaseAdapter } from \"@elizaos/core\";\r\nimport { v4 as uuid } from \"uuid\";\r\nexport class SupabaseDatabaseAdapter extends DatabaseAdapter {\r\n    async getRoom(roomId: UUID): Promise<UUID | null> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"rooms\")\r\n            .select(\"id\")\r\n            .eq(\"id\", roomId)\r\n            .maybeSingle();\r\n\r\n        if (error) {\r\n            elizaLogger.error(`Error getting room: ${error.message}`);\r\n            return null;\r\n        }\r\n        return data ? (data.id as UUID) : null;\r\n    }\r\n\r\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"participants\")\r\n            .select(\"*\")\r\n            .eq(\"userId\", userId);\r\n\r\n        if (error) {\r\n            throw new Error(\r\n                `Error getting participants for account: ${error.message}`\r\n            );\r\n        }\r\n\r\n        return data as Participant[];\r\n    }\r\n\r\n    async getParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID\r\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"participants\")\r\n            .select(\"userState\")\r\n            .eq(\"roomId\", roomId)\r\n            .eq(\"userId\", userId)\r\n            .single();\r\n\r\n        if (error) {\r\n            elizaLogger.error(\"Error getting participant user state:\", error);\r\n            return null;\r\n        }\r\n\r\n        return data?.userState as \"FOLLOWED\" | \"MUTED\" | null;\r\n    }\r\n\r\n    async setParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n        state: \"FOLLOWED\" | \"MUTED\" | null\r\n    ): Promise<void> {\r\n        const { error } = await this.supabase\r\n            .from(\"participants\")\r\n            .update({ userState: state })\r\n            .eq(\"roomId\", roomId)\r\n            .eq(\"userId\", userId);\r\n\r\n        if (error) {\r\n            elizaLogger.error(\"Error setting participant user state:\", error);\r\n            throw new Error(\"Failed to set participant user state\");\r\n        }\r\n    }\r\n\r\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"participants\")\r\n            .select(\"userId\")\r\n            .eq(\"roomId\", roomId);\r\n\r\n        if (error) {\r\n            throw new Error(\r\n                `Error getting participants for room: ${error.message}`\r\n            );\r\n        }\r\n\r\n        return data.map((row) => row.userId as UUID);\r\n    }\r\n\r\n    supabase: SupabaseClient;\r\n\r\n    constructor(supabaseUrl: string, supabaseKey: string) {\r\n        super();\r\n        this.supabase = createClient(supabaseUrl, supabaseKey);\r\n    }\r\n\r\n    async init() {\r\n        // noop\r\n    }\r\n\r\n    async close() {\r\n        // noop\r\n    }\r\n\r\n    async getMemoriesByRoomIds(params: {\r\n        roomIds: UUID[];\r\n        agentId?: UUID;\r\n        tableName: string;\r\n    }): Promise<Memory[]> {\r\n        let query = this.supabase\r\n            .from(params.tableName)\r\n            .select(\"*\")\r\n            .in(\"roomId\", params.roomIds);\r\n\r\n        if (params.agentId) {\r\n            query = query.eq(\"agentId\", params.agentId);\r\n        }\r\n\r\n        const { data, error } = await query;\r\n\r\n        if (error) {\r\n            elizaLogger.error(\"Error retrieving memories by room IDs:\", error);\r\n            return [];\r\n        }\r\n\r\n        // map createdAt to Date\r\n        const memories = data.map((memory) => ({\r\n            ...memory,\r\n        }));\r\n\r\n        return memories as Memory[];\r\n    }\r\n\r\n    async getAccountById(userId: UUID): Promise<Account | null> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"accounts\")\r\n            .select(\"*\")\r\n            .eq(\"id\", userId);\r\n        if (error) {\r\n            throw new Error(error.message);\r\n        }\r\n        return (data?.[0] as Account) || null;\r\n    }\r\n\r\n    async createAccount(account: Account): Promise<boolean> {\r\n        const { error } = await this.supabase\r\n            .from(\"accounts\")\r\n            .upsert([account]);\r\n        if (error) {\r\n            elizaLogger.error(error.message);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    async getActorDetails(params: { roomId: UUID }): Promise<Actor[]> {\r\n        try {\r\n            const response = await this.supabase\r\n                .from(\"rooms\")\r\n                .select(\r\n                    `\r\n          participants:participants(\r\n            account:accounts(id, name, username, details)\r\n          )\r\n      `\r\n                )\r\n                .eq(\"id\", params.roomId);\r\n\r\n            if (response.error) {\r\n                elizaLogger.error(\"Error!\" + response.error);\r\n                return [];\r\n            }\r\n            const { data } = response;\r\n\r\n            return data\r\n                .map((room) =>\r\n                    room.participants.map((participant) => {\r\n                        const user = participant.account as unknown as Actor;\r\n                        return {\r\n                            name: user?.name,\r\n                            details: user?.details,\r\n                            id: user?.id,\r\n                            username: user?.username,\r\n                        };\r\n                    })\r\n                )\r\n                .flat();\r\n        } catch (error) {\r\n            elizaLogger.error(\"error\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async searchMemories(params: {\r\n        tableName: string;\r\n        roomId: UUID;\r\n        embedding: number[];\r\n        match_threshold: number;\r\n        match_count: number;\r\n        unique: boolean;\r\n    }): Promise<Memory[]> {\r\n        const result = await this.supabase.rpc(\"search_memories\", {\r\n            query_table_name: params.tableName,\r\n            query_roomId: params.roomId,\r\n            query_embedding: params.embedding,\r\n            query_match_threshold: params.match_threshold,\r\n            query_match_count: params.match_count,\r\n            query_unique: params.unique,\r\n        });\r\n        if (result.error) {\r\n            throw new Error(JSON.stringify(result.error));\r\n        }\r\n        return result.data.map((memory) => ({\r\n            ...memory,\r\n        }));\r\n    }\r\n\r\n    async getCachedEmbeddings(opts: {\r\n        query_table_name: string;\r\n        query_threshold: number;\r\n        query_input: string;\r\n        query_field_name: string;\r\n        query_field_sub_name: string;\r\n        query_match_count: number;\r\n    }): Promise<\r\n        {\r\n            embedding: number[];\r\n            levenshtein_score: number;\r\n        }[]\r\n    > {\r\n        const result = await this.supabase.rpc(\"get_embedding_list\", opts);\r\n        if (result.error) {\r\n            throw new Error(JSON.stringify(result.error));\r\n        }\r\n        return result.data;\r\n    }\r\n\r\n    async updateGoalStatus(params: {\r\n        goalId: UUID;\r\n        status: GoalStatus;\r\n    }): Promise<void> {\r\n        await this.supabase\r\n            .from(\"goals\")\r\n            .update({ status: params.status })\r\n            .match({ id: params.goalId });\r\n    }\r\n\r\n    async log(params: {\r\n        body: { [key: string]: unknown };\r\n        userId: UUID;\r\n        roomId: UUID;\r\n        type: string;\r\n    }): Promise<void> {\r\n        const { error } = await this.supabase.from(\"logs\").insert({\r\n            body: params.body,\r\n            userId: params.userId,\r\n            roomId: params.roomId,\r\n            type: params.type,\r\n        });\r\n\r\n        if (error) {\r\n            elizaLogger.error(\"Error inserting log:\", error);\r\n            throw new Error(error.message);\r\n        }\r\n    }\r\n\r\n    async getMemories(params: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        tableName: string;\r\n        agentId?: UUID;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]> {\r\n        const query = this.supabase\r\n            .from(params.tableName)\r\n            .select(\"*\")\r\n            .eq(\"roomId\", params.roomId);\r\n\r\n        if (params.start) {\r\n            query.gte(\"createdAt\", params.start);\r\n        }\r\n\r\n        if (params.end) {\r\n            query.lte(\"createdAt\", params.end);\r\n        }\r\n\r\n        if (params.unique) {\r\n            query.eq(\"unique\", true);\r\n        }\r\n\r\n        if (params.agentId) {\r\n            query.eq(\"agentId\", params.agentId);\r\n        }\r\n\r\n        query.order(\"createdAt\", { ascending: false });\r\n\r\n        if (params.count) {\r\n            query.limit(params.count);\r\n        }\r\n\r\n        const { data, error } = await query;\r\n\r\n        if (error) {\r\n            throw new Error(`Error retrieving memories: ${error.message}`);\r\n        }\r\n\r\n        return data as Memory[];\r\n    }\r\n\r\n    async searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        params: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            roomId?: UUID;\r\n            agentId?: UUID;\r\n            unique?: boolean;\r\n            tableName: string;\r\n        }\r\n    ): Promise<Memory[]> {\r\n        const queryParams = {\r\n            query_table_name: params.tableName,\r\n            query_roomId: params.roomId,\r\n            query_embedding: embedding,\r\n            query_match_threshold: params.match_threshold,\r\n            query_match_count: params.count,\r\n            query_unique: !!params.unique,\r\n        };\r\n        if (params.agentId) {\r\n            (queryParams as any).query_agentId = params.agentId;\r\n        }\r\n\r\n        const result = await this.supabase.rpc(\"search_memories\", queryParams);\r\n        if (result.error) {\r\n            throw new Error(JSON.stringify(result.error));\r\n        }\r\n        return result.data.map((memory) => ({\r\n            ...memory,\r\n        }));\r\n    }\r\n\r\n    async getMemoryById(memoryId: UUID): Promise<Memory | null> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"memories\")\r\n            .select(\"*\")\r\n            .eq(\"id\", memoryId)\r\n            .single();\r\n\r\n        if (error) {\r\n            elizaLogger.error(\"Error retrieving memory by ID:\", error);\r\n            return null;\r\n        }\r\n\r\n        return data as Memory;\r\n    }\r\n\r\n    async createMemory(\r\n        memory: Memory,\r\n        tableName: string,\r\n        unique = false\r\n    ): Promise<void> {\r\n        const createdAt = memory.createdAt ?? Date.now();\r\n        if (unique) {\r\n            const opts = {\r\n                // TODO: Add ID option, optionally\r\n                query_table_name: tableName,\r\n                query_userId: memory.userId,\r\n                query_content: memory.content.text,\r\n                query_roomId: memory.roomId,\r\n                query_embedding: memory.embedding,\r\n                query_createdAt: createdAt,\r\n                similarity_threshold: 0.95,\r\n            };\r\n\r\n            const result = await this.supabase.rpc(\r\n                \"check_similarity_and_insert\",\r\n                opts\r\n            );\r\n\r\n            if (result.error) {\r\n                throw new Error(JSON.stringify(result.error));\r\n            }\r\n        } else {\r\n            const result = await this.supabase\r\n                .from(\"memories\")\r\n                .insert({ ...memory, createdAt, type: tableName });\r\n            const { error } = result;\r\n            if (error) {\r\n                throw new Error(JSON.stringify(error));\r\n            }\r\n        }\r\n    }\r\n\r\n    async removeMemory(memoryId: UUID): Promise<void> {\r\n        const result = await this.supabase\r\n            .from(\"memories\")\r\n            .delete()\r\n            .eq(\"id\", memoryId);\r\n        const { error } = result;\r\n        if (error) {\r\n            throw new Error(JSON.stringify(error));\r\n        }\r\n    }\r\n\r\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\r\n        const result = await this.supabase.rpc(\"remove_memories\", {\r\n            query_table_name: tableName,\r\n            query_roomId: roomId,\r\n        });\r\n\r\n        if (result.error) {\r\n            throw new Error(JSON.stringify(result.error));\r\n        }\r\n    }\r\n\r\n    async countMemories(\r\n        roomId: UUID,\r\n        unique = true,\r\n        tableName: string\r\n    ): Promise<number> {\r\n        if (!tableName) {\r\n            throw new Error(\"tableName is required\");\r\n        }\r\n        const query = {\r\n            query_table_name: tableName,\r\n            query_roomId: roomId,\r\n            query_unique: !!unique,\r\n        };\r\n        const result = await this.supabase.rpc(\"count_memories\", query);\r\n\r\n        if (result.error) {\r\n            throw new Error(JSON.stringify(result.error));\r\n        }\r\n\r\n        return result.data;\r\n    }\r\n\r\n    async getGoals(params: {\r\n        roomId: UUID;\r\n        userId?: UUID | null;\r\n        onlyInProgress?: boolean;\r\n        count?: number;\r\n    }): Promise<Goal[]> {\r\n        const opts = {\r\n            query_roomId: params.roomId,\r\n            query_userId: params.userId,\r\n            only_in_progress: params.onlyInProgress,\r\n            row_count: params.count,\r\n        };\r\n\r\n        const { data: goals, error } = await this.supabase.rpc(\r\n            \"get_goals\",\r\n            opts\r\n        );\r\n\r\n        if (error) {\r\n            throw new Error(error.message);\r\n        }\r\n\r\n        return goals;\r\n    }\r\n\r\n    async updateGoal(goal: Goal): Promise<void> {\r\n        const { error } = await this.supabase\r\n            .from(\"goals\")\r\n            .update(goal)\r\n            .match({ id: goal.id });\r\n        if (error) {\r\n            throw new Error(`Error creating goal: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async createGoal(goal: Goal): Promise<void> {\r\n        const { error } = await this.supabase.from(\"goals\").insert(goal);\r\n        if (error) {\r\n            throw new Error(`Error creating goal: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async removeGoal(goalId: UUID): Promise<void> {\r\n        const { error } = await this.supabase\r\n            .from(\"goals\")\r\n            .delete()\r\n            .eq(\"id\", goalId);\r\n        if (error) {\r\n            throw new Error(`Error removing goal: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async removeAllGoals(roomId: UUID): Promise<void> {\r\n        const { error } = await this.supabase\r\n            .from(\"goals\")\r\n            .delete()\r\n            .eq(\"roomId\", roomId);\r\n        if (error) {\r\n            throw new Error(`Error removing goals: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"participants\")\r\n            .select(\"roomId\")\r\n            .eq(\"userId\", userId);\r\n\r\n        if (error) {\r\n            throw new Error(\r\n                `Error getting rooms by participant: ${error.message}`\r\n            );\r\n        }\r\n\r\n        return data.map((row) => row.roomId as UUID);\r\n    }\r\n\r\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"participants\")\r\n            .select(\"roomId\")\r\n            .in(\"userId\", userIds);\r\n\r\n        if (error) {\r\n            throw new Error(\r\n                `Error getting rooms by participants: ${error.message}`\r\n            );\r\n        }\r\n\r\n        return [...new Set(data.map((row) => row.roomId as UUID))] as UUID[];\r\n    }\r\n\r\n    async createRoom(roomId?: UUID): Promise<UUID> {\r\n        roomId = roomId ?? (uuid() as UUID);\r\n        const { data, error } = await this.supabase.rpc(\"create_room\", {\r\n            roomId,\r\n        });\r\n\r\n        if (error) {\r\n            throw new Error(`Error creating room: ${error.message}`);\r\n        }\r\n\r\n        if (!data || data.length === 0) {\r\n            throw new Error(\"No data returned from room creation\");\r\n        }\r\n\r\n        return data[0].id as UUID;\r\n    }\r\n\r\n    async removeRoom(roomId: UUID): Promise<void> {\r\n        const { error } = await this.supabase\r\n            .from(\"rooms\")\r\n            .delete()\r\n            .eq(\"id\", roomId);\r\n\r\n        if (error) {\r\n            throw new Error(`Error removing room: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        const { error } = await this.supabase\r\n            .from(\"participants\")\r\n            .insert({ userId: userId, roomId: roomId });\r\n\r\n        if (error) {\r\n            elizaLogger.error(`Error adding participant: ${error.message}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        const { error } = await this.supabase\r\n            .from(\"participants\")\r\n            .delete()\r\n            .eq(\"userId\", userId)\r\n            .eq(\"roomId\", roomId);\r\n\r\n        if (error) {\r\n            elizaLogger.error(`Error removing participant: ${error.message}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    async createRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<boolean> {\r\n        const allRoomData = await this.getRoomsForParticipants([\r\n            params.userA,\r\n            params.userB,\r\n        ]);\r\n\r\n        let roomId: UUID;\r\n\r\n        if (!allRoomData || allRoomData.length === 0) {\r\n            // If no existing room is found, create a new room\r\n            const { data: newRoomData, error: roomsError } = await this.supabase\r\n                .from(\"rooms\")\r\n                .insert({})\r\n                .single();\r\n\r\n            if (roomsError) {\r\n                throw new Error(\"Room creation error: \" + roomsError.message);\r\n            }\r\n\r\n            roomId = (newRoomData as Room)?.id as UUID;\r\n        } else {\r\n            // If an existing room is found, use the first room's ID\r\n            roomId = allRoomData[0];\r\n        }\r\n\r\n        const { error: participantsError } = await this.supabase\r\n            .from(\"participants\")\r\n            .insert([\r\n                { userId: params.userA, roomId },\r\n                { userId: params.userB, roomId },\r\n            ]);\r\n\r\n        if (participantsError) {\r\n            throw new Error(\r\n                \"Participants creation error: \" + participantsError.message\r\n            );\r\n        }\r\n\r\n        // Create or update the relationship between the two users\r\n        const { error: relationshipError } = await this.supabase\r\n            .from(\"relationships\")\r\n            .upsert({\r\n                userA: params.userA,\r\n                userB: params.userB,\r\n                userId: params.userA,\r\n                status: \"FRIENDS\",\r\n            })\r\n            .eq(\"userA\", params.userA)\r\n            .eq(\"userB\", params.userB);\r\n\r\n        if (relationshipError) {\r\n            throw new Error(\r\n                \"Relationship creation error: \" + relationshipError.message\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async getRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<Relationship | null> {\r\n        const { data, error } = await this.supabase.rpc(\"get_relationship\", {\r\n            usera: params.userA,\r\n            userb: params.userB,\r\n        });\r\n\r\n        if (error) {\r\n            throw new Error(error.message);\r\n        }\r\n\r\n        return data[0];\r\n    }\r\n\r\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\r\n        const { data, error } = await this.supabase\r\n            .from(\"relationships\")\r\n            .select(\"*\")\r\n            .or(`userA.eq.${params.userId},userB.eq.${params.userId}`)\r\n            .eq(\"status\", \"FRIENDS\");\r\n\r\n        if (error) {\r\n            throw new Error(error.message);\r\n        }\r\n\r\n        return data as Relationship[];\r\n    }\r\n\r\n    async getCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<string | undefined> {\r\n        const { data, error } = await this.supabase\r\n            .from('cache')\r\n            .select('value')\r\n            .eq('key', params.key)\r\n            .eq('agentId', params.agentId)\r\n            .single();\r\n\r\n        if (error) {\r\n            elizaLogger.error('Error fetching cache:', error);\r\n            return undefined;\r\n        }\r\n\r\n        return data?.value;\r\n    }\r\n\r\n    async setCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n        value: string;\r\n    }): Promise<boolean> {\r\n        const { error } = await this.supabase\r\n            .from('cache')\r\n            .upsert({\r\n                key: params.key,\r\n                agentId: params.agentId,\r\n                value: params.value,\r\n                createdAt: new Date()\r\n            });\r\n\r\n        if (error) {\r\n            elizaLogger.error('Error setting cache:', error);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async deleteCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<boolean> {\r\n        try {\r\n            const { error } = await this.supabase\r\n                .from('cache')\r\n                .delete()\r\n                .eq('key', params.key)\r\n                .eq('agentId', params.agentId);\r\n\r\n            if (error) {\r\n                elizaLogger.error(\"Error deleting cache\", {\r\n                    error: error.message,\r\n                    key: params.key,\r\n                    agentId: params.agentId,\r\n                });\r\n                return false;\r\n            }\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Database connection error in deleteCache\",\r\n                error instanceof Error ? error.message : String(error)\r\n            );\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getKnowledge(params: {\r\n        id?: UUID;\r\n        agentId: UUID;\r\n        limit?: number;\r\n        query?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        let query = this.supabase\r\n            .from('knowledge')\r\n            .select('*')\r\n            .or(`agentId.eq.${params.agentId},isShared.eq.true`);\r\n\r\n        if (params.id) {\r\n            query = query.eq('id', params.id);\r\n        }\r\n\r\n        if (params.limit) {\r\n            query = query.limit(params.limit);\r\n        }\r\n\r\n        const { data, error } = await query;\r\n\r\n        if (error) {\r\n            throw new Error(`Error getting knowledge: ${error.message}`);\r\n        }\r\n\r\n        return data.map(row => ({\r\n            id: row.id,\r\n            agentId: row.agentId,\r\n            content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,\r\n            embedding: row.embedding ? new Float32Array(row.embedding) : undefined,\r\n            createdAt: new Date(row.createdAt).getTime()\r\n        }));\r\n    }\r\n\r\n    async searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\r\n        const cachedResult = await this.getCache({\r\n            key: cacheKey,\r\n            agentId: params.agentId\r\n        });\r\n\r\n        if (cachedResult) {\r\n            return JSON.parse(cachedResult);\r\n        }\r\n\r\n        // Convert Float32Array to array for Postgres vector\r\n        const embedding = Array.from(params.embedding);\r\n\r\n        const { data, error } = await this.supabase.rpc('search_knowledge', {\r\n            query_embedding: embedding,\r\n            query_agent_id: params.agentId,\r\n            match_threshold: params.match_threshold,\r\n            match_count: params.match_count,\r\n            search_text: params.searchText || ''\r\n        });\r\n\r\n        if (error) {\r\n            throw new Error(`Error searching knowledge: ${error.message}`);\r\n        }\r\n\r\n        const results = data.map(row => ({\r\n            id: row.id,\r\n            agentId: row.agentId,\r\n            content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,\r\n            embedding: row.embedding ? new Float32Array(row.embedding) : undefined,\r\n            createdAt: new Date(row.createdAt).getTime(),\r\n            similarity: row.similarity\r\n        }));\r\n\r\n        await this.setCache({\r\n            key: cacheKey,\r\n            agentId: params.agentId,\r\n            value: JSON.stringify(results)\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\r\n        try {\r\n            const metadata = knowledge.content.metadata || {};\r\n\r\n            const { error } = await this.supabase\r\n                .from('knowledge')\r\n                .insert({\r\n                    id: knowledge.id,\r\n                    agentId: metadata.isShared ? null : knowledge.agentId,\r\n                    content: knowledge.content,\r\n                    embedding: knowledge.embedding ? Array.from(knowledge.embedding) : null,\r\n                    createdAt: knowledge.createdAt || new Date(),\r\n                    isMain: metadata.isMain || false,\r\n                    originalId: metadata.originalId || null,\r\n                    chunkIndex: metadata.chunkIndex || null,\r\n                    isShared: metadata.isShared || false\r\n                });\r\n\r\n            if (error) {\r\n                if (metadata.isShared && error.code === '23505') { // Unique violation\r\n                    elizaLogger.info(`Shared knowledge ${knowledge.id} already exists, skipping`);\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n        } catch (error: any) {\r\n            elizaLogger.error(`Error creating knowledge ${knowledge.id}:`, {\r\n                error,\r\n                embeddingLength: knowledge.embedding?.length,\r\n                content: knowledge.content\r\n            });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async removeKnowledge(id: UUID): Promise<void> {\r\n        const { error } = await this.supabase\r\n            .from('knowledge')\r\n            .delete()\r\n            .eq('id', id);\r\n\r\n        if (error) {\r\n            throw new Error(`Error removing knowledge: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\r\n        if (shared) {\r\n            const { error } = await this.supabase\r\n                .from('knowledge')\r\n                .delete()\r\n                .filter('agentId', 'eq', agentId)\r\n                .filter('isShared', 'eq', true);\r\n\r\n            if (error) {\r\n                elizaLogger.error(`Error clearing shared knowledge for agent ${agentId}:`, error);\r\n                throw error;\r\n            }\r\n        } else {\r\n            const { error } = await this.supabase\r\n                .from('knowledge')\r\n                .delete()\r\n                .eq('agentId', agentId);\r\n\r\n            if (error) {\r\n                elizaLogger.error(`Error clearing knowledge for agent ${agentId}:`, error);\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":[]}