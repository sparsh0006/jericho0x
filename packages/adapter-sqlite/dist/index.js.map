{"version":3,"sources":["../src/sqliteTables.ts","../src/sqlite_vec.ts","../src/index.ts"],"sourcesContent":["export const sqliteTables = `\r\nPRAGMA foreign_keys=OFF;\r\nBEGIN TRANSACTION;\r\n\r\n-- Table: accounts\r\nCREATE TABLE IF NOT EXISTS \"accounts\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"name\" TEXT,\r\n    \"username\" TEXT,\r\n    \"email\" TEXT NOT NULL,\r\n    \"avatarUrl\" TEXT,\r\n    \"details\" TEXT DEFAULT '{}' CHECK(json_valid(\"details\")) -- Ensuring details is a valid JSON field\r\n);\r\n\r\n-- Table: memories\r\nCREATE TABLE IF NOT EXISTS \"memories\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"type\" TEXT NOT NULL,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"content\" TEXT NOT NULL,\r\n    \"embedding\" BLOB NOT NULL, -- TODO: EMBEDDING ARRAY, CONVERT TO BEST FORMAT FOR SQLITE-VSS (JSON?)\r\n    \"userId\" TEXT,\r\n    \"roomId\" TEXT,\r\n    \"agentId\" TEXT,\r\n    \"unique\" INTEGER DEFAULT 1 NOT NULL,\r\n    FOREIGN KEY (\"userId\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"roomId\") REFERENCES \"rooms\"(\"id\"),\r\n    FOREIGN KEY (\"agentId\") REFERENCES \"accounts\"(\"id\")\r\n);\r\n\r\n-- Table: goals\r\nCREATE TABLE IF NOT EXISTS \"goals\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userId\" TEXT,\r\n    \"name\" TEXT,\r\n    \"status\" TEXT,\r\n    \"description\" TEXT,\r\n    \"roomId\" TEXT,\r\n    \"objectives\" TEXT DEFAULT '[]' NOT NULL CHECK(json_valid(\"objectives\")) -- Ensuring objectives is a valid JSON array\r\n);\r\n\r\n-- Table: logs\r\nCREATE TABLE IF NOT EXISTS \"logs\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userId\" TEXT NOT NULL,\r\n    \"body\" TEXT NOT NULL,\r\n    \"type\" TEXT NOT NULL,\r\n    \"roomId\" TEXT NOT NULL\r\n);\r\n\r\n-- Table: participants\r\nCREATE TABLE IF NOT EXISTS \"participants\" (\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userId\" TEXT,\r\n    \"roomId\" TEXT,\r\n    \"userState\" TEXT,\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"last_message_read\" TEXT,\r\n    FOREIGN KEY (\"userId\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"roomId\") REFERENCES \"rooms\"(\"id\")\r\n);\r\n\r\n-- Table: relationships\r\nCREATE TABLE IF NOT EXISTS \"relationships\" (\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"userA\" TEXT NOT NULL,\r\n    \"userB\" TEXT NOT NULL,\r\n    \"status\" \"text\",\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"userId\" TEXT NOT NULL,\r\n    FOREIGN KEY (\"userA\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"userB\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"userId\") REFERENCES \"accounts\"(\"id\")\r\n);\r\n\r\n-- Table: rooms\r\nCREATE TABLE IF NOT EXISTS \"rooms\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n);\r\n\r\n-- Table: cache\r\nCREATE TABLE IF NOT EXISTS \"cache\" (\r\n    \"key\" TEXT NOT NULL,\r\n    \"agentId\" TEXT NOT NULL,\r\n    \"value\" TEXT DEFAULT '{}' CHECK(json_valid(\"value\")),\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"expiresAt\" TIMESTAMP,\r\n    PRIMARY KEY (\"key\", \"agentId\")\r\n);\r\n\r\n-- Table: knowledge\r\nCREATE TABLE IF NOT EXISTS \"knowledge\" (\r\n    \"id\" TEXT PRIMARY KEY,\r\n    \"agentId\" TEXT,\r\n    \"content\" TEXT NOT NULL CHECK(json_valid(\"content\")),\r\n    \"embedding\" BLOB,\r\n    \"createdAt\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    \"isMain\" INTEGER DEFAULT 0,\r\n    \"originalId\" TEXT,\r\n    \"chunkIndex\" INTEGER,\r\n    \"isShared\" INTEGER DEFAULT 0,\r\n    FOREIGN KEY (\"agentId\") REFERENCES \"accounts\"(\"id\"),\r\n    FOREIGN KEY (\"originalId\") REFERENCES \"knowledge\"(\"id\"),\r\n    CHECK((isShared = 1 AND agentId IS NULL) OR (isShared = 0 AND agentId IS NOT NULL))\r\n);\r\n\r\n-- Index: relationships_id_key\r\nCREATE UNIQUE INDEX IF NOT EXISTS \"relationships_id_key\" ON \"relationships\" (\"id\");\r\n\r\n-- Index: memories_id_key\r\nCREATE UNIQUE INDEX IF NOT EXISTS \"memories_id_key\" ON \"memories\" (\"id\");\r\n\r\n-- Index: participants_id_key\r\nCREATE UNIQUE INDEX IF NOT EXISTS \"participants_id_key\" ON \"participants\" (\"id\");\r\n\r\n-- Index: knowledge\r\nCREATE INDEX IF NOT EXISTS \"knowledge_agent_key\" ON \"knowledge\" (\"agentId\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_agent_main_key\" ON \"knowledge\" (\"agentId\", \"isMain\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_original_key\" ON \"knowledge\" (\"originalId\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_content_key\" ON \"knowledge\"\r\n    ((json_extract(content, '$.text')))\r\n    WHERE json_extract(content, '$.text') IS NOT NULL;\r\nCREATE INDEX IF NOT EXISTS \"knowledge_created_key\" ON \"knowledge\" (\"agentId\", \"createdAt\");\r\nCREATE INDEX IF NOT EXISTS \"knowledge_shared_key\" ON \"knowledge\" (\"isShared\");\r\n\r\nCOMMIT;`;","import * as sqliteVec from \"sqlite-vec\";\r\nimport { Database } from \"better-sqlite3\";\r\nimport { elizaLogger } from \"@elizaos/core\";\r\n\r\n// Loads the sqlite-vec extensions into the provided SQLite database\r\nexport function loadVecExtensions(db: Database): void {\r\n    try {\r\n        // Load sqlite-vec extensions\r\n        sqliteVec.load(db);\r\n        elizaLogger.log(\"sqlite-vec extensions loaded successfully.\");\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to load sqlite-vec extensions:\", error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * @param db - An instance of better - sqlite3 Database\r\n */\r\nexport function load(db: Database): void {\r\n    loadVecExtensions(db);\r\n}\r\n","export * from \"./sqliteTables.ts\";\r\nexport * from \"./sqlite_vec.ts\";\r\n\r\nimport {\r\n    DatabaseAdapter,\r\n    elizaLogger,\r\n    IDatabaseCacheAdapter,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    Account,\r\n    Actor,\r\n    GoalStatus,\r\n    Participant,\r\n    type Goal,\r\n    type Memory,\r\n    type Relationship,\r\n    type UUID,\r\n    RAGKnowledgeItem,\r\n} from \"@elizaos/core\";\r\nimport { Database } from \"better-sqlite3\";\r\nimport { v4 } from \"uuid\";\r\nimport { load } from \"./sqlite_vec.ts\";\r\nimport { sqliteTables } from \"./sqliteTables.ts\";\r\n\r\nexport class SqliteDatabaseAdapter\r\n    extends DatabaseAdapter<Database>\r\n    implements IDatabaseCacheAdapter\r\n{\r\n    async getRoom(roomId: UUID): Promise<UUID | null> {\r\n        const sql = \"SELECT id FROM rooms WHERE id = ?\";\r\n        const room = this.db.prepare(sql).get(roomId) as\r\n            | { id: string }\r\n            | undefined;\r\n        return room ? (room.id as UUID) : null;\r\n    }\r\n\r\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\r\n        const sql = `\r\n      SELECT p.id, p.userId, p.roomId, p.last_message_read\r\n      FROM participants p\r\n      WHERE p.userId = ?\r\n    `;\r\n        const rows = this.db.prepare(sql).all(userId) as Participant[];\r\n        return rows;\r\n    }\r\n\r\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\r\n        const sql = \"SELECT userId FROM participants WHERE roomId = ?\";\r\n        const rows = this.db.prepare(sql).all(roomId) as { userId: string }[];\r\n        return rows.map((row) => row.userId as UUID);\r\n    }\r\n\r\n    async getParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID\r\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\r\n        const stmt = this.db.prepare(\r\n            \"SELECT userState FROM participants WHERE roomId = ? AND userId = ?\"\r\n        );\r\n        const res = stmt.get(roomId, userId) as\r\n            | { userState: \"FOLLOWED\" | \"MUTED\" | null }\r\n            | undefined;\r\n        return res?.userState ?? null;\r\n    }\r\n\r\n    async setParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n        state: \"FOLLOWED\" | \"MUTED\" | null\r\n    ): Promise<void> {\r\n        const stmt = this.db.prepare(\r\n            \"UPDATE participants SET userState = ? WHERE roomId = ? AND userId = ?\"\r\n        );\r\n        stmt.run(state, roomId, userId);\r\n    }\r\n\r\n    constructor(db: Database) {\r\n        super();\r\n        this.db = db;\r\n        load(db);\r\n    }\r\n\r\n    async init() {\r\n        this.db.exec(sqliteTables);\r\n    }\r\n\r\n    async close() {\r\n        this.db.close();\r\n    }\r\n\r\n    async getAccountById(userId: UUID): Promise<Account | null> {\r\n        const sql = \"SELECT * FROM accounts WHERE id = ?\";\r\n        const account = this.db.prepare(sql).get(userId) as Account;\r\n        if (!account) return null;\r\n        if (account) {\r\n            if (typeof account.details === \"string\") {\r\n                account.details = JSON.parse(\r\n                    account.details as unknown as string\r\n                );\r\n            }\r\n        }\r\n        return account;\r\n    }\r\n\r\n    async createAccount(account: Account): Promise<boolean> {\r\n        try {\r\n            const sql =\r\n                \"INSERT INTO accounts (id, name, username, email, avatarUrl, details) VALUES (?, ?, ?, ?, ?, ?)\";\r\n            this.db\r\n                .prepare(sql)\r\n                .run(\r\n                    account.id ?? v4(),\r\n                    account.name,\r\n                    account.username,\r\n                    account.email,\r\n                    account.avatarUrl,\r\n                    JSON.stringify(account.details)\r\n                );\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error creating account\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getActorDetails(params: { roomId: UUID }): Promise<Actor[]> {\r\n        const sql = `\r\n      SELECT a.id, a.name, a.username, a.details\r\n      FROM participants p\r\n      LEFT JOIN accounts a ON p.userId = a.id\r\n      WHERE p.roomId = ?\r\n    `;\r\n        const rows = this.db\r\n            .prepare(sql)\r\n            .all(params.roomId) as (Actor | null)[];\r\n\r\n        return rows\r\n            .map((row) => {\r\n                if (row === null) {\r\n                    return null;\r\n                }\r\n                return {\r\n                    ...row,\r\n                    details:\r\n                        typeof row.details === \"string\"\r\n                            ? JSON.parse(row.details)\r\n                            : row.details,\r\n                };\r\n            })\r\n            .filter((row): row is Actor => row !== null);\r\n    }\r\n\r\n    async getMemoriesByRoomIds(params: {\r\n        agentId: UUID;\r\n        roomIds: UUID[];\r\n        tableName: string;\r\n    }): Promise<Memory[]> {\r\n        if (!params.tableName) {\r\n            // default to messages\r\n            params.tableName = \"messages\";\r\n        }\r\n        const placeholders = params.roomIds.map(() => \"?\").join(\", \");\r\n        const sql = `SELECT * FROM memories WHERE type = ? AND agentId = ? AND roomId IN (${placeholders})`;\r\n        const queryParams = [\r\n            params.tableName,\r\n            params.agentId,\r\n            ...params.roomIds,\r\n        ];\r\n\r\n        const stmt = this.db.prepare(sql);\r\n        const rows = stmt.all(...queryParams) as (Memory & {\r\n            content: string;\r\n        })[];\r\n\r\n        return rows.map((row) => ({\r\n            ...row,\r\n            content: JSON.parse(row.content),\r\n        }));\r\n    }\r\n\r\n    async getMemoryById(memoryId: UUID): Promise<Memory | null> {\r\n        const sql = \"SELECT * FROM memories WHERE id = ?\";\r\n        const stmt = this.db.prepare(sql);\r\n        stmt.bind([memoryId]);\r\n        const memory = stmt.get() as Memory | undefined;\r\n\r\n        if (memory) {\r\n            return {\r\n                ...memory,\r\n                content: JSON.parse(memory.content as unknown as string),\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\r\n        // Delete any existing memory with the same ID first\r\n        // const deleteSql = `DELETE FROM memories WHERE id = ? AND type = ?`;\r\n        // this.db.prepare(deleteSql).run(memory.id, tableName);\r\n\r\n        let isUnique = true;\r\n\r\n        if (memory.embedding) {\r\n            // Check if a similar memory already exists\r\n            const similarMemories = await this.searchMemoriesByEmbedding(\r\n                memory.embedding,\r\n                {\r\n                    tableName,\r\n                    agentId: memory.agentId,\r\n                    roomId: memory.roomId,\r\n                    match_threshold: 0.95, // 5% similarity threshold\r\n                    count: 1,\r\n                }\r\n            );\r\n\r\n            isUnique = similarMemories.length === 0;\r\n        }\r\n\r\n        const content = JSON.stringify(memory.content);\r\n        const createdAt = memory.createdAt ?? Date.now();\r\n\r\n        let embeddingValue: Float32Array = new Float32Array(384);\r\n        // If embedding is not available, we just load an array with a length of 384\r\n        if (memory?.embedding && memory?.embedding?.length > 0) {\r\n            embeddingValue = new Float32Array(memory.embedding);\r\n        }\r\n\r\n        // Insert the memory with the appropriate 'unique' value\r\n        const sql = `INSERT OR REPLACE INTO memories (id, type, content, embedding, userId, roomId, agentId, \\`unique\\`, createdAt) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`;\r\n        this.db\r\n            .prepare(sql)\r\n            .run(\r\n                memory.id ?? v4(),\r\n                tableName,\r\n                content,\r\n                embeddingValue,\r\n                memory.userId,\r\n                memory.roomId,\r\n                memory.agentId,\r\n                isUnique ? 1 : 0,\r\n                createdAt\r\n            );\r\n    }\r\n\r\n    async searchMemories(params: {\r\n        tableName: string;\r\n        roomId: UUID;\r\n        agentId?: UUID;\r\n        embedding: number[];\r\n        match_threshold: number;\r\n        match_count: number;\r\n        unique: boolean;\r\n    }): Promise<Memory[]> {\r\n        // Build the query and parameters carefully\r\n        const queryParams = [\r\n            new Float32Array(params.embedding), // Ensure embedding is Float32Array\r\n            params.tableName,\r\n            params.roomId,\r\n        ];\r\n\r\n        let sql = `\r\n            SELECT *, vec_distance_L2(embedding, ?) AS similarity\r\n            FROM memories\r\n            WHERE type = ?\r\n            AND roomId = ?`;\r\n\r\n        if (params.unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n\r\n        if (params.agentId) {\r\n            sql += \" AND agentId = ?\";\r\n            queryParams.push(params.agentId);\r\n        }\r\n        sql += ` ORDER BY similarity ASC LIMIT ?`; // ASC for lower distance\r\n        queryParams.push(params.match_count.toString()); // Convert number to string\r\n\r\n        // Execute the prepared statement with the correct number of parameters\r\n        const memories = this.db.prepare(sql).all(...queryParams) as (Memory & {\r\n            similarity: number;\r\n        })[];\r\n\r\n        return memories.map((memory) => ({\r\n            ...memory,\r\n            createdAt:\r\n                typeof memory.createdAt === \"string\"\r\n                    ? Date.parse(memory.createdAt as string)\r\n                    : memory.createdAt,\r\n            content: JSON.parse(memory.content as unknown as string),\r\n        }));\r\n    }\r\n\r\n    async searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        params: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            roomId?: UUID;\r\n            agentId: UUID;\r\n            unique?: boolean;\r\n            tableName: string;\r\n        }\r\n    ): Promise<Memory[]> {\r\n        const queryParams = [\r\n            // JSON.stringify(embedding),\r\n            new Float32Array(embedding),\r\n            params.tableName,\r\n            params.agentId,\r\n        ];\r\n\r\n        let sql = `\r\n      SELECT *, vec_distance_L2(embedding, ?) AS similarity\r\n      FROM memories\r\n      WHERE embedding IS NOT NULL AND type = ? AND agentId = ?`;\r\n\r\n        if (params.unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n\r\n        if (params.roomId) {\r\n            sql += \" AND roomId = ?\";\r\n            queryParams.push(params.roomId);\r\n        }\r\n        sql += ` ORDER BY similarity DESC`;\r\n\r\n        if (params.count) {\r\n            sql += \" LIMIT ?\";\r\n            queryParams.push(params.count.toString());\r\n        }\r\n\r\n        const memories = this.db.prepare(sql).all(...queryParams) as (Memory & {\r\n            similarity: number;\r\n        })[];\r\n        return memories.map((memory) => ({\r\n            ...memory,\r\n            createdAt:\r\n                typeof memory.createdAt === \"string\"\r\n                    ? Date.parse(memory.createdAt as string)\r\n                    : memory.createdAt,\r\n            content: JSON.parse(memory.content as unknown as string),\r\n        }));\r\n    }\r\n\r\n    async getCachedEmbeddings(opts: {\r\n        query_table_name: string;\r\n        query_threshold: number;\r\n        query_input: string;\r\n        query_field_name: string;\r\n        query_field_sub_name: string;\r\n        query_match_count: number;\r\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\r\n        // First get content text and calculate Levenshtein distance\r\n        const sql = `\r\n            WITH content_text AS (\r\n                SELECT\r\n                    embedding,\r\n                    json_extract(\r\n                        json(content),\r\n                        '$.' || ? || '.' || ?\r\n                    ) as content_text\r\n                FROM memories\r\n                WHERE type = ?\r\n                AND json_extract(\r\n                    json(content),\r\n                    '$.' || ? || '.' || ?\r\n                ) IS NOT NULL\r\n            )\r\n            SELECT\r\n                embedding,\r\n                length(?) + length(content_text) - (\r\n                    length(?) + length(content_text) - (\r\n                        length(replace(lower(?), lower(content_text), '')) +\r\n                        length(replace(lower(content_text), lower(?), ''))\r\n                    ) / 2\r\n                ) as levenshtein_score\r\n            FROM content_text\r\n            ORDER BY levenshtein_score ASC\r\n            LIMIT ?\r\n        `;\r\n\r\n        const rows = this.db\r\n            .prepare(sql)\r\n            .all(\r\n                opts.query_field_name,\r\n                opts.query_field_sub_name,\r\n                opts.query_table_name,\r\n                opts.query_field_name,\r\n                opts.query_field_sub_name,\r\n                opts.query_input,\r\n                opts.query_input,\r\n                opts.query_input,\r\n                opts.query_input,\r\n                opts.query_match_count\r\n            ) as { embedding: Buffer; levenshtein_score: number }[];\r\n\r\n        return rows.map((row) => ({\r\n            embedding: Array.from(new Float32Array(row.embedding as Buffer)),\r\n            levenshtein_score: row.levenshtein_score,\r\n        }));\r\n    }\r\n\r\n    async updateGoalStatus(params: {\r\n        goalId: UUID;\r\n        status: GoalStatus;\r\n    }): Promise<void> {\r\n        const sql = \"UPDATE goals SET status = ? WHERE id = ?\";\r\n        this.db.prepare(sql).run(params.status, params.goalId);\r\n    }\r\n\r\n    async log(params: {\r\n        body: { [key: string]: unknown };\r\n        userId: UUID;\r\n        roomId: UUID;\r\n        type: string;\r\n    }): Promise<void> {\r\n        const sql =\r\n            \"INSERT INTO logs (body, userId, roomId, type) VALUES (?, ?, ?, ?)\";\r\n        this.db\r\n            .prepare(sql)\r\n            .run(\r\n                JSON.stringify(params.body),\r\n                params.userId,\r\n                params.roomId,\r\n                params.type\r\n            );\r\n    }\r\n\r\n    async getMemories(params: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        tableName: string;\r\n        agentId: UUID;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]> {\r\n        if (!params.tableName) {\r\n            throw new Error(\"tableName is required\");\r\n        }\r\n        if (!params.roomId) {\r\n            throw new Error(\"roomId is required\");\r\n        }\r\n        let sql = `SELECT * FROM memories WHERE type = ? AND agentId = ? AND roomId = ?`;\r\n\r\n        const queryParams = [\r\n            params.tableName,\r\n            params.agentId,\r\n            params.roomId,\r\n        ] as any[];\r\n\r\n        if (params.unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n\r\n        if (params.start) {\r\n            sql += ` AND createdAt >= ?`;\r\n            queryParams.push(params.start);\r\n        }\r\n\r\n        if (params.end) {\r\n            sql += ` AND createdAt <= ?`;\r\n            queryParams.push(params.end);\r\n        }\r\n\r\n        sql += \" ORDER BY createdAt DESC\";\r\n\r\n        if (params.count) {\r\n            sql += \" LIMIT ?\";\r\n            queryParams.push(params.count);\r\n        }\r\n\r\n        const memories = this.db.prepare(sql).all(...queryParams) as Memory[];\r\n\r\n        return memories.map((memory) => ({\r\n            ...memory,\r\n            createdAt:\r\n                typeof memory.createdAt === \"string\"\r\n                    ? Date.parse(memory.createdAt as string)\r\n                    : memory.createdAt,\r\n            content: JSON.parse(memory.content as unknown as string),\r\n        }));\r\n    }\r\n\r\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\r\n        const sql = `DELETE FROM memories WHERE type = ? AND id = ?`;\r\n        this.db.prepare(sql).run(tableName, memoryId);\r\n    }\r\n\r\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\r\n        const sql = `DELETE FROM memories WHERE type = ? AND roomId = ?`;\r\n        this.db.prepare(sql).run(tableName, roomId);\r\n    }\r\n\r\n    async countMemories(\r\n        roomId: UUID,\r\n        unique = true,\r\n        tableName = \"\"\r\n    ): Promise<number> {\r\n        if (!tableName) {\r\n            throw new Error(\"tableName is required\");\r\n        }\r\n\r\n        let sql = `SELECT COUNT(*) as count FROM memories WHERE type = ? AND roomId = ?`;\r\n        const queryParams = [tableName, roomId] as string[];\r\n\r\n        if (unique) {\r\n            sql += \" AND `unique` = 1\";\r\n        }\r\n\r\n        return (this.db.prepare(sql).get(...queryParams) as { count: number })\r\n            .count;\r\n    }\r\n\r\n    async getGoals(params: {\r\n        roomId: UUID;\r\n        userId?: UUID | null;\r\n        onlyInProgress?: boolean;\r\n        count?: number;\r\n    }): Promise<Goal[]> {\r\n        let sql = \"SELECT * FROM goals WHERE roomId = ?\";\r\n        const queryParams = [params.roomId];\r\n\r\n        if (params.userId) {\r\n            sql += \" AND userId = ?\";\r\n            queryParams.push(params.userId);\r\n        }\r\n\r\n        if (params.onlyInProgress) {\r\n            sql += \" AND status = 'IN_PROGRESS'\";\r\n        }\r\n\r\n        if (params.count) {\r\n            sql += \" LIMIT ?\";\r\n            // @ts-expect-error - queryParams is an array of strings\r\n            queryParams.push(params.count.toString());\r\n        }\r\n\r\n        const goals = this.db.prepare(sql).all(...queryParams) as Goal[];\r\n        return goals.map((goal) => ({\r\n            ...goal,\r\n            objectives:\r\n                typeof goal.objectives === \"string\"\r\n                    ? JSON.parse(goal.objectives)\r\n                    : goal.objectives,\r\n        }));\r\n    }\r\n\r\n    async updateGoal(goal: Goal): Promise<void> {\r\n        const sql =\r\n            \"UPDATE goals SET name = ?, status = ?, objectives = ? WHERE id = ?\";\r\n        this.db\r\n            .prepare(sql)\r\n            .run(\r\n                goal.name,\r\n                goal.status,\r\n                JSON.stringify(goal.objectives),\r\n                goal.id\r\n            );\r\n    }\r\n\r\n    async createGoal(goal: Goal): Promise<void> {\r\n        const sql =\r\n            \"INSERT INTO goals (id, roomId, userId, name, status, objectives) VALUES (?, ?, ?, ?, ?, ?)\";\r\n        this.db\r\n            .prepare(sql)\r\n            .run(\r\n                goal.id ?? v4(),\r\n                goal.roomId,\r\n                goal.userId,\r\n                goal.name,\r\n                goal.status,\r\n                JSON.stringify(goal.objectives)\r\n            );\r\n    }\r\n\r\n    async removeGoal(goalId: UUID): Promise<void> {\r\n        const sql = \"DELETE FROM goals WHERE id = ?\";\r\n        this.db.prepare(sql).run(goalId);\r\n    }\r\n\r\n    async removeAllGoals(roomId: UUID): Promise<void> {\r\n        const sql = \"DELETE FROM goals WHERE roomId = ?\";\r\n        this.db.prepare(sql).run(roomId);\r\n    }\r\n\r\n    async createRoom(roomId?: UUID): Promise<UUID> {\r\n        roomId = roomId || (v4() as UUID);\r\n        try {\r\n            const sql = \"INSERT INTO rooms (id) VALUES (?)\";\r\n            this.db.prepare(sql).run(roomId ?? (v4() as UUID));\r\n        } catch (error) {\r\n            console.log(\"Error creating room\", error);\r\n        }\r\n        return roomId as UUID;\r\n    }\r\n\r\n    async removeRoom(roomId: UUID): Promise<void> {\r\n        const sql = \"DELETE FROM rooms WHERE id = ?\";\r\n        this.db.prepare(sql).run(roomId);\r\n    }\r\n\r\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\r\n        const sql = \"SELECT roomId FROM participants WHERE userId = ?\";\r\n        const rows = this.db.prepare(sql).all(userId) as { roomId: string }[];\r\n        return rows.map((row) => row.roomId as UUID);\r\n    }\r\n\r\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\r\n        // Assuming userIds is an array of UUID strings, prepare a list of placeholders\r\n        const placeholders = userIds.map(() => \"?\").join(\", \");\r\n        // Construct the SQL query with the correct number of placeholders\r\n        const sql = `SELECT DISTINCT roomId FROM participants WHERE userId IN (${placeholders})`;\r\n        // Execute the query with the userIds array spread into arguments\r\n        const rows = this.db.prepare(sql).all(...userIds) as {\r\n            roomId: string;\r\n        }[];\r\n        // Map and return the roomId values as UUIDs\r\n        return rows.map((row) => row.roomId as UUID);\r\n    }\r\n\r\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        try {\r\n            const sql =\r\n                \"INSERT INTO participants (id, userId, roomId) VALUES (?, ?, ?)\";\r\n            this.db.prepare(sql).run(v4(), userId, roomId);\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error adding participant\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        try {\r\n            const sql =\r\n                \"DELETE FROM participants WHERE userId = ? AND roomId = ?\";\r\n            this.db.prepare(sql).run(userId, roomId);\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error removing participant\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async createRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<boolean> {\r\n        if (!params.userA || !params.userB) {\r\n            throw new Error(\"userA and userB are required\");\r\n        }\r\n        const sql =\r\n            \"INSERT INTO relationships (id, userA, userB, userId) VALUES (?, ?, ?, ?)\";\r\n        this.db\r\n            .prepare(sql)\r\n            .run(v4(), params.userA, params.userB, params.userA);\r\n        return true;\r\n    }\r\n\r\n    async getRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<Relationship | null> {\r\n        const sql =\r\n            \"SELECT * FROM relationships WHERE (userA = ? AND userB = ?) OR (userA = ? AND userB = ?)\";\r\n        return (\r\n            (this.db\r\n                .prepare(sql)\r\n                .get(\r\n                    params.userA,\r\n                    params.userB,\r\n                    params.userB,\r\n                    params.userA\r\n                ) as Relationship) || null\r\n        );\r\n    }\r\n\r\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\r\n        const sql =\r\n            \"SELECT * FROM relationships WHERE (userA = ? OR userB = ?)\";\r\n        return this.db\r\n            .prepare(sql)\r\n            .all(params.userId, params.userId) as Relationship[];\r\n    }\r\n\r\n    async getCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<string | undefined> {\r\n        const sql = \"SELECT value FROM cache WHERE (key = ? AND agentId = ?)\";\r\n        const cached = this.db\r\n            .prepare<[string, UUID], { value: string }>(sql)\r\n            .get(params.key, params.agentId);\r\n\r\n        return cached?.value ?? undefined;\r\n    }\r\n\r\n    async setCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n        value: string;\r\n    }): Promise<boolean> {\r\n        const sql =\r\n            \"INSERT OR REPLACE INTO cache (key, agentId, value, createdAt) VALUES (?, ?, ?, CURRENT_TIMESTAMP)\";\r\n        this.db.prepare(sql).run(params.key, params.agentId, params.value);\r\n        return true;\r\n    }\r\n\r\n    async deleteCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<boolean> {\r\n        try {\r\n            const sql = \"DELETE FROM cache WHERE key = ? AND agentId = ?\";\r\n            this.db.prepare(sql).run(params.key, params.agentId);\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error removing cache\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getKnowledge(params: {\r\n        id?: UUID;\r\n        agentId: UUID;\r\n        limit?: number;\r\n        query?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        let sql = `SELECT * FROM knowledge WHERE (agentId = ? OR isShared = 1)`;\r\n        const queryParams: any[] = [params.agentId];\r\n\r\n        if (params.id) {\r\n            sql += ` AND id = ?`;\r\n            queryParams.push(params.id);\r\n        }\r\n\r\n        if (params.limit) {\r\n            sql += ` LIMIT ?`;\r\n            queryParams.push(params.limit);\r\n        }\r\n\r\n        interface KnowledgeRow {\r\n            id: UUID;\r\n            agentId: UUID;\r\n            content: string;\r\n            embedding: Buffer | null;\r\n            createdAt: string | number;\r\n        }\r\n\r\n        const rows = this.db.prepare(sql).all(...queryParams) as KnowledgeRow[];\r\n\r\n        return rows.map((row) => ({\r\n            id: row.id,\r\n            agentId: row.agentId,\r\n            content: JSON.parse(row.content),\r\n            embedding: row.embedding\r\n                ? new Float32Array(row.embedding)\r\n                : undefined,\r\n            createdAt:\r\n                typeof row.createdAt === \"string\"\r\n                    ? Date.parse(row.createdAt)\r\n                    : row.createdAt,\r\n        }));\r\n    }\r\n\r\n    async searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\r\n        const cachedResult = await this.getCache({\r\n            key: cacheKey,\r\n            agentId: params.agentId,\r\n        });\r\n\r\n        if (cachedResult) {\r\n            return JSON.parse(cachedResult);\r\n        }\r\n\r\n        interface KnowledgeSearchRow {\r\n            id: UUID;\r\n            agentId: UUID;\r\n            content: string;\r\n            embedding: Buffer | null;\r\n            createdAt: string | number;\r\n            vector_score: number;\r\n            keyword_score: number;\r\n            combined_score: number;\r\n        }\r\n\r\n        const sql = `\r\n            WITH vector_scores AS (\r\n                SELECT id,\r\n                        1 / (1 + vec_distance_L2(embedding, ?)) as vector_score\r\n                FROM knowledge\r\n                WHERE (agentId IS NULL AND isShared = 1) OR agentId = ?\r\n                AND embedding IS NOT NULL\r\n            ),\r\n            keyword_matches AS (\r\n                SELECT id,\r\n                CASE\r\n                    WHEN lower(json_extract(content, '$.text')) LIKE ? THEN 3.0\r\n                    ELSE 1.0\r\n                END *\r\n                CASE\r\n                    WHEN json_extract(content, '$.metadata.isChunk') = 1 THEN 1.5\r\n                    WHEN json_extract(content, '$.metadata.isMain') = 1 THEN 1.2\r\n                    ELSE 1.0\r\n                END as keyword_score\r\n                FROM knowledge\r\n                WHERE (agentId IS NULL AND isShared = 1) OR agentId = ?\r\n            )\r\n            SELECT k.*,\r\n                v.vector_score,\r\n                kw.keyword_score,\r\n                (v.vector_score * kw.keyword_score) as combined_score\r\n            FROM knowledge k\r\n            JOIN vector_scores v ON k.id = v.id\r\n            LEFT JOIN keyword_matches kw ON k.id = kw.id\r\n            WHERE (k.agentId IS NULL AND k.isShared = 1) OR k.agentId = ?\r\n            AND (\r\n                v.vector_score >= ?  -- Using match_threshold parameter\r\n                OR (kw.keyword_score > 1.0 AND v.vector_score >= 0.3)\r\n            )\r\n            ORDER BY combined_score DESC\r\n            LIMIT ?\r\n        `;\r\n\r\n        const searchParams = [\r\n            params.embedding,\r\n            params.agentId,\r\n            `%${params.searchText?.toLowerCase() || \"\"}%`,\r\n            params.agentId,\r\n            params.agentId,\r\n            params.match_threshold,\r\n            params.match_count,\r\n        ];\r\n\r\n        try {\r\n            const rows = this.db\r\n                .prepare(sql)\r\n                .all(...searchParams) as KnowledgeSearchRow[];\r\n            const results = rows.map((row) => ({\r\n                id: row.id,\r\n                agentId: row.agentId,\r\n                content: JSON.parse(row.content),\r\n                embedding: row.embedding\r\n                    ? new Float32Array(row.embedding)\r\n                    : undefined,\r\n                createdAt:\r\n                    typeof row.createdAt === \"string\"\r\n                        ? Date.parse(row.createdAt)\r\n                        : row.createdAt,\r\n                similarity: row.combined_score,\r\n            }));\r\n\r\n            await this.setCache({\r\n                key: cacheKey,\r\n                agentId: params.agentId,\r\n                value: JSON.stringify(results),\r\n            });\r\n\r\n            return results;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in searchKnowledge:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\r\n        try {\r\n            this.db.transaction(() => {\r\n                const sql = `\r\n                    INSERT INTO knowledge (\r\n                    id, agentId, content, embedding, createdAt,\r\n                    isMain, originalId, chunkIndex, isShared\r\n                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n                `;\r\n\r\n                const embeddingArray = knowledge.embedding || null;\r\n\r\n                const metadata = knowledge.content.metadata || {};\r\n                const isShared = metadata.isShared ? 1 : 0;\r\n\r\n                this.db\r\n                    .prepare(sql)\r\n                    .run(\r\n                        knowledge.id,\r\n                        metadata.isShared ? null : knowledge.agentId,\r\n                        JSON.stringify(knowledge.content),\r\n                        embeddingArray,\r\n                        knowledge.createdAt || Date.now(),\r\n                        metadata.isMain ? 1 : 0,\r\n                        metadata.originalId || null,\r\n                        metadata.chunkIndex || null,\r\n                        isShared\r\n                    );\r\n            })();\r\n        } catch (error: any) {\r\n            const isShared = knowledge.content.metadata?.isShared;\r\n            const isPrimaryKeyError =\r\n                error?.code === \"SQLITE_CONSTRAINT_PRIMARYKEY\";\r\n\r\n            if (isShared && isPrimaryKeyError) {\r\n                elizaLogger.info(\r\n                    `Shared knowledge ${knowledge.id} already exists, skipping`\r\n                );\r\n                return;\r\n            } else if (\r\n                !isShared &&\r\n                !error.message?.includes(\"SQLITE_CONSTRAINT_PRIMARYKEY\")\r\n            ) {\r\n                elizaLogger.error(`Error creating knowledge ${knowledge.id}:`, {\r\n                    error,\r\n                    embeddingLength: knowledge.embedding?.length,\r\n                    content: knowledge.content,\r\n                });\r\n                throw error;\r\n            }\r\n\r\n            elizaLogger.debug(\r\n                `Knowledge ${knowledge.id} already exists, skipping`\r\n            );\r\n        }\r\n    }\r\n\r\n    async removeKnowledge(id: UUID): Promise<void> {\r\n        const sql = `DELETE FROM knowledge WHERE id = ?`;\r\n        this.db.prepare(sql).run(id);\r\n    }\r\n\r\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\r\n        const sql = shared\r\n            ? `DELETE FROM knowledge WHERE (agentId = ? OR isShared = 1)`\r\n            : `DELETE FROM knowledge WHERE agentId = ?`;\r\n        try {\r\n            this.db.prepare(sql).run(agentId);\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                `Error clearing knowledge for agent ${agentId}:`,\r\n                error\r\n            );\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":["load","elizaLogger","load","elizaLogger"]}