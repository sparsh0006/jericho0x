{"version":3,"sources":["../src/actions/spotTrade.ts","../src/types.ts","../src/templates.ts","../src/actions/priceCheck.ts","../src/actions/cancelOrders.ts","../src/index.ts"],"sourcesContent":["import {\r\n    Action,\r\n    ActionExample,\r\n    IAgentRuntime,\r\n    Memory,\r\n    State,\r\n    HandlerCallback,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateObjectDeprecated,\r\n    ModelClass,\r\n} from \"@elizaos/core\";\r\nimport { Hyperliquid } from \"hyperliquid\";\r\nimport {\r\n    SpotOrderSchema,\r\n    HyperliquidError,\r\n    PRICE_VALIDATION,\r\n} from \"../types.js\";\r\nimport { spotTradeTemplate } from \"../templates.js\";\r\n\r\nexport const spotTrade: Action = {\r\n    name: \"SPOT_TRADE\",\r\n    similes: [\"SPOT_ORDER\", \"SPOT_BUY\", \"SPOT_SELL\"],\r\n    description: \"Place a spot trade order on Hyperliquid\",\r\n    validate: async (runtime: IAgentRuntime) => {\r\n        return !!runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\");\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        try {\r\n            // Initialize or update state\r\n            state = !state\r\n                ? await runtime.composeState(message)\r\n                : await runtime.updateRecentMessageState(state);\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template: spotTradeTemplate,\r\n            });\r\n\r\n            const content = await generateObjectDeprecated({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            if (!content) {\r\n                throw new HyperliquidError(\r\n                    \"Could not parse trading parameters from conversation\"\r\n                );\r\n            }\r\n\r\n            elizaLogger.info(\r\n                \"Raw content from LLM:\",\r\n                JSON.stringify(content, null, 2)\r\n            );\r\n\r\n            // Validate order parameters\r\n            const validatedOrder = SpotOrderSchema.parse(content);\r\n            elizaLogger.info(\"Validated order:\", validatedOrder);\r\n\r\n            // Initialize SDK\r\n            const sdk = new Hyperliquid({\r\n                privateKey: runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\"),\r\n                testnet: runtime.getSetting(\"HYPERLIQUID_TESTNET\") === \"true\",\r\n                enableWs: false,\r\n            });\r\n            await sdk.connect();\r\n\r\n            // Get market data\r\n            const [meta, assetCtxs] =\r\n                await sdk.info.spot.getSpotMetaAndAssetCtxs();\r\n\r\n            // Find token and market\r\n            const tokenIndex = meta.tokens.findIndex(\r\n                (token) =>\r\n                    token.name.toUpperCase() ===\r\n                    validatedOrder.coin.toUpperCase()\r\n            );\r\n            if (tokenIndex === -1) {\r\n                throw new HyperliquidError(\r\n                    `Could not find token ${validatedOrder.coin}`\r\n                );\r\n            }\r\n            const tokenInfo = meta.tokens[tokenIndex];\r\n            elizaLogger.info(\"Found token:\", tokenInfo.name);\r\n\r\n            const marketIndex = assetCtxs.findIndex(\r\n                (ctx) => ctx.coin === `${validatedOrder.coin}-SPOT`\r\n            );\r\n            if (marketIndex === -1) {\r\n                throw new HyperliquidError(\r\n                    `Could not find market for ${validatedOrder.coin}`\r\n                );\r\n            }\r\n            const marketCtx = assetCtxs[marketIndex];\r\n            if (!marketCtx || !marketCtx.midPx) {\r\n                throw new HyperliquidError(\r\n                    `Could not get market price for ${validatedOrder.coin}`\r\n                );\r\n            }\r\n\r\n            // Calculate prices\r\n            const midPrice = Number(marketCtx.midPx);\r\n            const isMarketOrder = !validatedOrder.limit_px;\r\n            let finalPrice: number;\r\n\r\n            if (isMarketOrder) {\r\n                // For market orders, use current price with slippage\r\n                const slippage = PRICE_VALIDATION.SLIPPAGE;\r\n                finalPrice = validatedOrder.is_buy\r\n                    ? midPrice * (1 + slippage)\r\n                    : midPrice * (1 - slippage);\r\n\r\n                // Validate market order price\r\n                if (\r\n                    finalPrice <\r\n                        midPrice * PRICE_VALIDATION.MARKET_ORDER.MIN_RATIO ||\r\n                    finalPrice >\r\n                        midPrice * PRICE_VALIDATION.MARKET_ORDER.MAX_RATIO\r\n                ) {\r\n                    throw new HyperliquidError(\r\n                        `Market order price (${finalPrice.toFixed(2)} USDC) is too far from market price (${midPrice.toFixed(2)} USDC). This might be due to low liquidity.`\r\n                    );\r\n                }\r\n            } else {\r\n                // For limit orders\r\n                finalPrice = validatedOrder.limit_px;\r\n\r\n                // Validate limit order price is optimal\r\n                if (validatedOrder.is_buy && finalPrice > midPrice) {\r\n                    throw new HyperliquidError(\r\n                        `Cannot place buy limit order at ${finalPrice.toFixed(2)} USDC because it's above market price (${midPrice.toFixed(2)} USDC). To execute immediately, use a market order. For a limit order, set a price below ${midPrice.toFixed(2)} USDC.`\r\n                    );\r\n                } else if (!validatedOrder.is_buy && finalPrice < midPrice) {\r\n                    throw new HyperliquidError(\r\n                        `Cannot place sell limit order at ${finalPrice.toFixed(2)} USDC because it's below market price (${midPrice.toFixed(2)} USDC). To execute immediately, use a market order. For a limit order, set a price above ${midPrice.toFixed(2)} USDC.`\r\n                    );\r\n                }\r\n\r\n                // Log warning if price is very different from market\r\n                if (\r\n                    finalPrice <\r\n                        midPrice *\r\n                            PRICE_VALIDATION.LIMIT_ORDER.WARNING_MIN_RATIO ||\r\n                    finalPrice >\r\n                        midPrice *\r\n                            PRICE_VALIDATION.LIMIT_ORDER.WARNING_MAX_RATIO\r\n                ) {\r\n                    elizaLogger.warn(\r\n                        `Limit price (${finalPrice.toFixed(2)} USDC) is very different from market price (${midPrice.toFixed(2)} USDC). Make sure this is intentional.`,\r\n                        {\r\n                            finalPrice,\r\n                            midPrice,\r\n                            ratio: finalPrice / midPrice,\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Prepare and place order\r\n            const rounded_px = Number(finalPrice.toFixed(tokenInfo.szDecimals));\r\n            const orderRequest = {\r\n                coin: `${validatedOrder.coin}-SPOT`,\r\n                asset: 10000 + marketIndex,\r\n                is_buy: validatedOrder.is_buy,\r\n                sz: validatedOrder.sz,\r\n                limit_px: rounded_px,\r\n                reduce_only: false,\r\n                order_type: isMarketOrder\r\n                    ? { market: {} }\r\n                    : { limit: { tif: \"Gtc\" as const } },\r\n            };\r\n\r\n            elizaLogger.info(\"Placing order:\", orderRequest);\r\n            const result = await sdk.exchange.placeOrder(orderRequest);\r\n\r\n            // Check if order was rejected\r\n            if (\r\n                result.status === \"ok\" &&\r\n                result.response?.type === \"order\" &&\r\n                result.response.data?.statuses?.[0]?.error\r\n            ) {\r\n                throw new HyperliquidError(\r\n                    result.response.data.statuses[0].error\r\n                );\r\n            }\r\n\r\n            // Send success callback\r\n            if (callback) {\r\n                const action = validatedOrder.is_buy ? \"buy\" : \"sell\";\r\n                const executionPrice =\r\n                    result.response?.data?.statuses?.[0]?.px || rounded_px;\r\n                callback({\r\n                    text: `Successfully placed ${isMarketOrder ? \"a market\" : \"a limit\"} order to ${action} ${validatedOrder.sz} ${validatedOrder.coin} at ${executionPrice}`,\r\n                    content: result,\r\n                });\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error placing spot order:\", error);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error placing spot order: ${error.message}`,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Buy 0.1 HYPE at 20 USDC\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll place a spot buy order for 0.1 HYPE at 20 USDC.\",\r\n                    action: \"SPOT_TRADE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"Successfully placed a limit order to buy 0.1 HYPE at 20 USDC\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Sell 2 HYPE at 21 USDC\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll place a spot sell order for 2 HYPE at 21 USDC.\",\r\n                    action: \"SPOT_TRADE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"Successfully placed a limit order to sell 2 HYPE at 21 USDC\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n};\r\n\r\nexport default spotTrade;\r\n","import { z } from \"zod\";\r\n\r\n// Base configuration types\r\nexport interface HyperliquidConfig {\r\n    privateKey: string;\r\n    testnet?: boolean;\r\n    walletAddress?: string;\r\n}\r\n\r\n// Enhanced schemas with better validation\r\nexport const SpotOrderSchema = z.object({\r\n    coin: z.string().min(1),\r\n    is_buy: z.boolean(),\r\n    sz: z.number().positive(),\r\n    limit_px: z.number().positive().nullable(),\r\n    reduce_only: z.boolean().default(false),\r\n    order_type: z\r\n        .object({\r\n            limit: z.object({\r\n                tif: z.enum([\"Ioc\", \"Gtc\"]),\r\n            }),\r\n        })\r\n        .default({ limit: { tif: \"Gtc\" } }),\r\n});\r\n\r\n// Inferred types from schemas\r\nexport type SpotOrder = z.infer<typeof SpotOrderSchema>;\r\n\r\n// Response types\r\nexport interface OrderResponse {\r\n    coin: string;\r\n    orderId: string;\r\n    status: \"open\" | \"filled\" | \"cancelled\" | \"rejected\";\r\n    size: number;\r\n    price: number;\r\n    is_buy: boolean;\r\n}\r\n\r\n// Error handling types\r\nexport class HyperliquidError extends Error {\r\n    constructor(\r\n        message: string,\r\n        public code?: number,\r\n        public details?: unknown\r\n    ) {\r\n        super(message);\r\n        this.name = \"HyperliquidError\";\r\n    }\r\n}\r\n\r\n// Constants\r\nexport const ORDER_STATUS = {\r\n    OPEN: \"open\",\r\n    FILLED: \"filled\",\r\n    CANCELLED: \"cancelled\",\r\n    REJECTED: \"rejected\",\r\n} as const;\r\n\r\nexport const PRICE_VALIDATION = {\r\n    MARKET_ORDER: {\r\n        MIN_RATIO: 0.5, // -50% from mid price\r\n        MAX_RATIO: 1.5, // +50% from mid price\r\n    },\r\n    LIMIT_ORDER: {\r\n        WARNING_MIN_RATIO: 0.2, // -80% from mid price\r\n        WARNING_MAX_RATIO: 5, // +500% from mid price\r\n    },\r\n    SLIPPAGE: 0.01, // 1% slippage for market orders\r\n} as const;\r\n\r\nexport type OrderStatus = keyof typeof ORDER_STATUS;\r\n\r\n// Balance types\r\nexport interface BalanceResponse {\r\n    coin: string;\r\n    free: number;\r\n    locked: number;\r\n}\r\n","export const spotTradeTemplate = `Look at your LAST RESPONSE in the conversation where you confirmed a trade request.\r\nBased on ONLY that last message, extract the trading details:\r\n\r\nFor Hyperliquid spot trading:\r\n- Market orders (executes immediately at best available price):\r\n  \"buy 1 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1 }\r\n  \"sell 2 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 2 }\r\n  \"market buy 1 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1 }\r\n  \"market sell 2 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 2 }\r\n\r\n- Limit orders (waits for specified price):\r\n  \"buy 1 HYPE at 20 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1, \"limit_px\": 20 }\r\n  \"sell 0.5 HYPE at 21 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 0.5, \"limit_px\": 21 }\r\n  \"limit buy 1 HYPE at 20 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1, \"limit_px\": 20 }\r\n  \"limit sell 0.5 HYPE at 21 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 0.5, \"limit_px\": 21 }\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"coin\": \"<coin symbol>\",\r\n    \"is_buy\": \"<true for buy, false for sell>\",\r\n    \"sz\": \"<quantity to trade>\",\r\n    \"limit_px\": \"<price in USDC if limit order, null if market order>\"\r\n}\r\n\\`\\`\\`\r\n\r\nNote:\r\n- Just use the coin symbol (HYPE, ETH, etc.)\r\n- sz is the size/quantity to trade (exactly as specified in the message)\r\n- limit_px is optional:\r\n  - If specified (with \"at X USDC\"), order will be placed at that exact price\r\n  - If not specified, order will be placed at current market price\r\n- Words like \"market\" or \"limit\" at the start are optional but help clarify intent\r\n\r\nRecent conversation:\r\n{{recentMessages}}`;\r\n\r\nexport const priceCheckTemplate = `Look at your LAST RESPONSE in the conversation where you confirmed which token price to check.\r\nBased on ONLY that last message, extract the token symbol.\r\n\r\nFor example:\r\n- \"I'll check PIP price for you\" -> { \"symbol\": \"PIP\" }\r\n- \"Let me check the price of HYPE\" -> { \"symbol\": \"HYPE\" }\r\n- \"I'll get the current ETH price\" -> { \"symbol\": \"ETH\" }\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"symbol\": \"<token symbol from your last message>\"\r\n}\r\n\\`\\`\\`\r\n\r\nNote:\r\n- Just return the token symbol (PIP, HYPE, ETH, etc.)\r\n- Remove any suffixes like \"-SPOT\" or \"USDC\"\r\n- If multiple tokens are mentioned, use the last one\r\n\r\nRecent conversation:\r\n{{recentMessages}}`;\r\n","import {\r\n    Action,\r\n    ActionExample,\r\n    IAgentRuntime,\r\n    Memory,\r\n    State,\r\n    HandlerCallback,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateObjectDeprecated,\r\n    ModelClass,\r\n} from \"@elizaos/core\";\r\nimport { Hyperliquid } from \"hyperliquid\";\r\nimport { HyperliquidError } from \"../types.js\";\r\nimport { priceCheckTemplate } from \"../templates.js\";\r\n\r\nexport const priceCheck: Action = {\r\n    name: \"PRICE_CHECK\",\r\n    similes: [\"CHECK_PRICE\", \"GET_PRICE\", \"PRICE\", \"CURRENT_PRICE\"],\r\n    description: \"Get current price for a token on Hyperliquid\",\r\n    validate: async () => true, // Public endpoint\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        try {\r\n            // Initialize or update state\r\n            state = !state\r\n                ? await runtime.composeState(message)\r\n                : await runtime.updateRecentMessageState(state);\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template: priceCheckTemplate,\r\n            });\r\n\r\n            const content = await generateObjectDeprecated({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            if (!content?.symbol) {\r\n                throw new HyperliquidError(\r\n                    \"Could not determine which token price to check\"\r\n                );\r\n            }\r\n\r\n            elizaLogger.info(\"Checking price for token:\", content.symbol);\r\n\r\n            // Initialize SDK\r\n            const sdk = new Hyperliquid({\r\n                enableWs: false,\r\n            });\r\n            await sdk.connect();\r\n\r\n            // Get market data\r\n            const [meta, assetCtxs] =\r\n                await sdk.info.spot.getSpotMetaAndAssetCtxs();\r\n\r\n            // Find token and market\r\n            const tokenIndex = meta.tokens.findIndex(\r\n                (token) =>\r\n                    token.name.toUpperCase() === content.symbol.toUpperCase()\r\n            );\r\n            if (tokenIndex === -1) {\r\n                throw new HyperliquidError(\r\n                    `Could not find token ${content.symbol}`\r\n                );\r\n            }\r\n\r\n            const marketIndex = assetCtxs.findIndex(\r\n                (ctx) => ctx.coin === `${content.symbol}-SPOT`\r\n            );\r\n            if (marketIndex === -1) {\r\n                throw new HyperliquidError(\r\n                    `Could not find market for ${content.symbol}`\r\n                );\r\n            }\r\n\r\n            const marketCtx = assetCtxs[marketIndex];\r\n            if (!marketCtx || !marketCtx.midPx) {\r\n                throw new HyperliquidError(\r\n                    `Could not get market price for ${content.symbol}`\r\n                );\r\n            }\r\n\r\n            const price = Number(marketCtx.midPx);\r\n            const dayChange = (\r\n                ((price - Number(marketCtx.prevDayPx)) /\r\n                    Number(marketCtx.prevDayPx)) *\r\n                100\r\n            ).toFixed(2);\r\n            const volume = Number(marketCtx.dayNtlVlm).toFixed(2);\r\n\r\n            if (callback) {\r\n                callback({\r\n                    text: `${content.symbol} price: ${price.toFixed(2)} USDC (24h change: ${dayChange}%, volume: ${volume} USDC)`,\r\n                    content: {\r\n                        symbol: content.symbol,\r\n                        price: price,\r\n                        dayChange: dayChange,\r\n                        volume: volume,\r\n                    },\r\n                });\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error checking price:\", error);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error checking price: ${error.message}`,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"What's the current price of PIP?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll check the current PIP price for you.\",\r\n                    action: \"PRICE_CHECK\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"PIP price: 19.73 USDC (24h change: -1.82%, volume: 1053445.75 USDC)\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n};\r\n\r\nexport default priceCheck;\r\n","import {\r\n    Action,\r\n    ActionExample,\r\n    IAgentRuntime,\r\n    Memory,\r\n    State,\r\n    HandlerCallback,\r\n    elizaLogger,\r\n} from \"@elizaos/core\";\r\nimport { Hyperliquid } from \"hyperliquid\";\r\n\r\nexport const cancelOrders: Action = {\r\n    name: \"CANCEL_ORDERS\",\r\n    similes: [\"CANCEL_ALL_ORDERS\", \"CANCEL\", \"CANCEL_ALL\"],\r\n    description: \"Cancel all open orders on Hyperliquid\",\r\n    validate: async (runtime: IAgentRuntime) => {\r\n        return !!runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\");\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        try {\r\n            // Initialize SDK\r\n            const sdk = new Hyperliquid({\r\n                privateKey: runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\"),\r\n                testnet: runtime.getSetting(\"HYPERLIQUID_TESTNET\") === \"true\",\r\n                enableWs: false,\r\n            });\r\n            await sdk.connect();\r\n\r\n            elizaLogger.info(\"Cancelling all open orders...\");\r\n            const result = await sdk.custom.cancelAllOrders();\r\n            elizaLogger.info(\"Cancel result:\", result);\r\n\r\n            if (callback) {\r\n                const cancelledCount =\r\n                    result?.response?.data?.statuses?.length || 0;\r\n                callback({\r\n                    text:\r\n                        cancelledCount > 0\r\n                            ? `Successfully cancelled ${cancelledCount} open order${cancelledCount > 1 ? \"s\" : \"\"}`\r\n                            : \"No open orders to cancel\",\r\n                    content: result,\r\n                });\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error cancelling orders:\", error);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error cancelling orders: ${error.message}`,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Cancel all my orders\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"I'll cancel all your open orders.\",\r\n                    action: \"CANCEL_ORDERS\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{agent}}\",\r\n                content: {\r\n                    text: \"Successfully cancelled 2 open orders\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n};\r\n\r\nexport default cancelOrders;\r\n","import { Plugin } from \"@elizaos/core\";\r\nimport { spotTrade } from \"./actions/spotTrade\";\r\nimport { priceCheck } from \"./actions/priceCheck\";\r\nimport { cancelOrders } from \"./actions/cancelOrders\";\r\n\r\nexport const hyperliquidPlugin: Plugin = {\r\n    name: \"hyperliquid\",\r\n    description: \"Hyperliquid plugin\",\r\n    actions: [spotTrade, priceCheck, cancelOrders],\r\n    providers: [],\r\n    evaluators: [],\r\n    services: [],\r\n    clients: [],\r\n};\r\n\r\nexport default hyperliquidPlugin;\r\n"],"mappings":"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","names":["composeContext","elizaLogger","generateObjectDeprecated","ModelClass","Hyperliquid","composeContext","generateObjectDeprecated","ModelClass","elizaLogger","Hyperliquid","elizaLogger","Hyperliquid"]}