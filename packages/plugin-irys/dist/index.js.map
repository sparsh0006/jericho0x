{"version":3,"sources":["../src/services/irysService.ts","../src/index.ts"],"sourcesContent":["import {\r\n    IAgentRuntime,\r\n    Service,\r\n    ServiceType,\r\n    IIrysService,\r\n    UploadIrysResult,\r\n    DataIrysFetchedFromGQL,\r\n    GraphQLTag,\r\n    IrysMessageType,\r\n    generateMessageResponse,\r\n    ModelClass,\r\n    IrysDataType,\r\n    IrysTimestamp,\r\n} from \"@elizaos/core\";\r\nimport { Uploader } from \"@irys/upload\";\r\nimport { BaseEth } from \"@irys/upload-ethereum\";\r\nimport { GraphQLClient, gql } from 'graphql-request';\r\nimport crypto from 'crypto';\r\n\r\ninterface NodeGQL {\r\n    id: string;\r\n    address: string;\r\n}\r\n\r\ninterface TransactionsIdAddress {\r\n    success: boolean;\r\n    data: NodeGQL[];\r\n    error?: string;\r\n}\r\n\r\ninterface TransactionGQL {\r\n    transactions: {\r\n        edges: {\r\n            node: {\r\n                id: string;\r\n                address: string;\r\n            }\r\n        }[]\r\n    }\r\n}\r\n\r\nexport class IrysService extends Service implements IIrysService {\r\n    static serviceType: ServiceType = ServiceType.IRYS;\r\n\r\n    private runtime: IAgentRuntime | null = null;\r\n    private irysUploader: any | null = null;\r\n    private endpointForTransactionId: string = \"https://uploader.irys.xyz/graphql\";\r\n    private endpointForData: string = \"https://gateway.irys.xyz\";\r\n\r\n    async initialize(runtime: IAgentRuntime): Promise<void> {\r\n        console.log(\"Initializing IrysService\");\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    private async getTransactionId(owners: string[] = null, tags: GraphQLTag[] = null, timestamp: IrysTimestamp = null): Promise<TransactionsIdAddress> {\r\n        const graphQLClient = new GraphQLClient(this.endpointForTransactionId);\r\n        const QUERY = gql`\r\n            query($owners: [String!], $tags: [TagFilter!], $timestamp: TimestampFilter) {\r\n                transactions(owners: $owners, tags: $tags, timestamp: $timestamp) {\r\n                    edges {\r\n                        node {\r\n                            id,\r\n                            address\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        `;\r\n        try {\r\n            const variables = {\r\n                owners: owners,\r\n                tags: tags,\r\n                timestamp: timestamp\r\n            }\r\n            const data: TransactionGQL = await graphQLClient.request(QUERY, variables);\r\n            const listOfTransactions : NodeGQL[] = data.transactions.edges.map((edge: any) => edge.node);\r\n            console.log(\"Transaction IDs retrieved\")\r\n            return { success: true, data: listOfTransactions };\r\n        } catch (error) {\r\n            console.error(\"Error fetching transaction IDs\", error);\r\n            return { success: false, data: [], error: \"Error fetching transaction IDs\" };\r\n        }\r\n    }\r\n\r\n    private async initializeIrysUploader(): Promise<boolean> {\r\n        if (this.irysUploader) return true;\r\n        if (!this.runtime) return false;\r\n\r\n        try {\r\n            const EVM_WALLET_PRIVATE_KEY = this.runtime.getSetting(\"EVM_WALLET_PRIVATE_KEY\");\r\n            if (!EVM_WALLET_PRIVATE_KEY) return false;\r\n\r\n            const irysUploader = await Uploader(BaseEth).withWallet(EVM_WALLET_PRIVATE_KEY);\r\n            this.irysUploader = irysUploader;\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"Error initializing Irys uploader:\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private async fetchDataFromTransactionId(transactionId: string): Promise<DataIrysFetchedFromGQL> {\r\n        console.log(`Fetching data from transaction ID: ${transactionId}`);\r\n        const response = await fetch(`${this.endpointForData}/${transactionId}`);\r\n        if (!response.ok) return { success: false, data: null, error: \"Error fetching data from transaction ID\" };\r\n        return {\r\n            success: true,\r\n            data: response,\r\n        };\r\n    }\r\n    private converToValues(value: any): any[] {\r\n        if (Array.isArray(value)) {\r\n            return value;\r\n        }\r\n        return [value];\r\n    }\r\n\r\n    private async orchestrateRequest(requestMessage: string, tags: GraphQLTag[], timestamp: IrysTimestamp = null): Promise<DataIrysFetchedFromGQL> {\r\n        const serviceCategory = tags.find((tag) => tag.name == \"Service-Category\")?.values;\r\n        const protocol = tags.find((tag) => tag.name == \"Protocol\")?.values;\r\n        const minimumProviders = Number(tags.find((tag) => tag.name == \"Minimum-Providers\")?.values);\r\n        /*\r\n            Further implementation of the orchestrator\r\n            { name: \"Validation-Threshold\", values: validationThreshold },\r\n            { name: \"Test-Provider\", values: testProvider },\r\n            { name: \"Reputation\", values: reputation },\r\n        */\r\n        const tagsToRetrieve : GraphQLTag[] = [\r\n            { name: \"Message-Type\", values: [IrysMessageType.DATA_STORAGE] },\r\n            { name: \"Service-Category\", values: this.converToValues(serviceCategory) },\r\n            { name: \"Protocol\", values: this.converToValues(protocol) },\r\n        ];\r\n        const data = await this.getDataFromAnAgent(null, tagsToRetrieve, timestamp);\r\n        if (!data.success) return { success: false, data: null, error: data.error };\r\n        const dataArray = data.data as Array<any>;\r\n        try {\r\n            for (let i = 0; i < dataArray.length; i++) {\r\n                const node = dataArray[i];\r\n                const templateRequest = `\r\n                Determine the truthfulness of the relationship between the given context and text.\r\n                Context: ${requestMessage}\r\n                Text: ${node.data}\r\n                Return True or False\r\n            `;\r\n            const responseFromModel = await generateMessageResponse({\r\n                runtime: this.runtime,\r\n                context: templateRequest,\r\n                modelClass: ModelClass.MEDIUM,\r\n            });\r\n            console.log(\"RESPONSE FROM MODEL : \", responseFromModel)\r\n            if (!responseFromModel.success || ((responseFromModel.content?.toString().toLowerCase().includes('false')) && (!responseFromModel.content?.toString().toLowerCase().includes('true')))) {\r\n                dataArray.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n        } catch (error) {\r\n            if (error.message.includes(\"TypeError: Cannot read properties of undefined (reading 'settings')\")) {\r\n                return { success: false, data: null, error: \"Error in the orchestrator\" };\r\n            }\r\n        }\r\n        const responseTags: GraphQLTag[] = [\r\n            { name: \"Message-Type\", values: [IrysMessageType.REQUEST_RESPONSE] },\r\n            { name: \"Service-Category\", values: [serviceCategory] },\r\n            { name: \"Protocol\", values: [protocol] },\r\n            { name: \"Request-Id\", values: [tags.find((tag) => tag.name == \"Request-Id\")?.values[0]] },\r\n        ];\r\n        if (dataArray.length == 0) {\r\n            const response = await this.uploadDataOnIrys(\"No relevant data found from providers\", responseTags, IrysMessageType.REQUEST_RESPONSE);\r\n            console.log(\"Response from Irys: \", response);\r\n            return { success: false, data: null, error: \"No relevant data found from providers\" };\r\n        }\r\n        const listProviders = new Set(dataArray.map((provider: any) => provider.address));\r\n        if (listProviders.size < minimumProviders) {\r\n            const response = await this.uploadDataOnIrys(\"Not enough providers\", responseTags, IrysMessageType.REQUEST_RESPONSE);\r\n            console.log(\"Response from Irys: \", response);\r\n            return { success: false, data: null, error: \"Not enough providers\" };\r\n        }\r\n        const listData = dataArray.map((provider: any) => provider.data);\r\n        const response = await this.uploadDataOnIrys(listData, responseTags, IrysMessageType.REQUEST_RESPONSE);\r\n        console.log(\"Response from Irys: \", response);\r\n        return {\r\n            success: true,\r\n            data: listData\r\n        }\r\n    }\r\n\r\n    // Orchestrator\r\n    private async uploadDataOnIrys(data: any, tags: GraphQLTag[], messageType: IrysMessageType, timestamp: IrysTimestamp = null): Promise<UploadIrysResult> {\r\n        if (!(await this.initializeIrysUploader())) {\r\n            return {\r\n                success: false,\r\n                error: \"Irys uploader not initialized\",\r\n            };\r\n        }\r\n\r\n        // Transform tags to the correct format\r\n        const formattedTags = tags.map(tag => ({\r\n            name: tag.name,\r\n            value: Array.isArray(tag.values) ? tag.values.join(',') : tag.values\r\n        }));\r\n\r\n        const requestId = String(crypto.createHash('sha256').update(new Date().toISOString()).digest('hex'));\r\n        formattedTags.push({\r\n            name: \"Request-Id\",\r\n            value: requestId\r\n        });\r\n        try {\r\n            const dataToStore = {\r\n                data: data,\r\n            };\r\n            const receipt = await this.irysUploader.upload(JSON.stringify(dataToStore), { tags: formattedTags });\r\n            if (messageType == IrysMessageType.DATA_STORAGE || messageType == IrysMessageType.REQUEST_RESPONSE) {\r\n                return { success: true, url: `https://gateway.irys.xyz/${receipt.id}`};\r\n            } else if (messageType == IrysMessageType.REQUEST) {\r\n                const response = await this.orchestrateRequest(data, tags, timestamp);\r\n                return {\r\n                    success: response.success,\r\n                    url: `https://gateway.irys.xyz/${receipt.id}`,\r\n                    data: response.data,\r\n                    error: response.error ? response.error : null\r\n                }\r\n\r\n            }\r\n            return { success: true, url: `https://gateway.irys.xyz/${receipt.id}` };\r\n        } catch (error) {\r\n            return { success: false, error: \"Error uploading to Irys, \" + error };\r\n        }\r\n    }\r\n\r\n    private async uploadFileOrImageOnIrys(data: string, tags: GraphQLTag[]): Promise<UploadIrysResult> {\r\n        if (!(await this.initializeIrysUploader())) {\r\n            return {\r\n                success: false,\r\n                error: \"Irys uploader not initialized\"\r\n            };\r\n        }\r\n\r\n        const formattedTags = tags.map(tag => ({\r\n            name: tag.name,\r\n            value: Array.isArray(tag.values) ? tag.values.join(',') : tag.values\r\n        }));\r\n\r\n        try {\r\n            const receipt = await this.irysUploader.uploadFile(data, { tags: formattedTags });\r\n            return { success: true, url: `https://gateway.irys.xyz/${receipt.id}` };\r\n        } catch (error) {\r\n            return { success: false, error: \"Error uploading to Irys, \" + error };\r\n        }\r\n    }\r\n\r\n    private normalizeArrayValues(arr: number[], min: number, max?: number): void {\r\n        for (let i = 0; i < arr.length; i++) {\r\n            arr[i] = Math.max(min, max !== undefined ? Math.min(arr[i], max) : arr[i]);\r\n        }\r\n    }\r\n\r\n    private normalizeArraySize(arr: any[]): any {\r\n        if (arr.length == 1) {\r\n            return arr[0];\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    async workerUploadDataOnIrys(data: any, dataType: IrysDataType, messageType: IrysMessageType, serviceCategory: string[], protocol: string[], validationThreshold: number[] = [], minimumProviders: number[] = [], testProvider: boolean[] = [], reputation: number[] = []): Promise<UploadIrysResult> {\r\n        this.normalizeArrayValues(validationThreshold, 0, 1);\r\n        this.normalizeArrayValues(minimumProviders, 0);\r\n        this.normalizeArrayValues(reputation, 0, 1);\r\n\r\n        const tags = [\r\n            { name: \"Message-Type\", values: messageType },\r\n            { name: \"Service-Category\", values: this.normalizeArraySize(serviceCategory) },\r\n            { name: \"Protocol\", values: this.normalizeArraySize(protocol) },\r\n        ] as GraphQLTag[];\r\n\r\n        if (messageType == IrysMessageType.REQUEST) {\r\n            if (validationThreshold.length > 0) {\r\n                tags.push({ name: \"Validation-Threshold\", values: this.normalizeArraySize(validationThreshold) });\r\n            }\r\n            if (minimumProviders.length > 0) {\r\n                tags.push({ name: \"Minimum-Providers\", values: this.normalizeArraySize(minimumProviders) });\r\n            }\r\n            if (testProvider.length > 0) {\r\n                tags.push({ name: \"Test-Provider\", values: this.normalizeArraySize(testProvider) });\r\n            }\r\n            if (reputation.length > 0) {\r\n                tags.push({ name: \"Reputation\", values: this.normalizeArraySize(reputation) });\r\n            }\r\n        }\r\n        if (dataType == IrysDataType.FILE || dataType == IrysDataType.IMAGE) {\r\n            return await this.uploadFileOrImageOnIrys(data, tags);\r\n        }\r\n\r\n        return await this.uploadDataOnIrys(data, tags, messageType);\r\n    }\r\n\r\n    async providerUploadDataOnIrys(data: any, dataType: IrysDataType, serviceCategory: string[], protocol: string[]): Promise<UploadIrysResult> {\r\n        const tags = [\r\n            { name: \"Message-Type\", values: [IrysMessageType.DATA_STORAGE] },\r\n            { name: \"Service-Category\", values: serviceCategory },\r\n            { name: \"Protocol\", values: protocol },\r\n        ] as GraphQLTag[];\r\n\r\n        if (dataType == IrysDataType.FILE || dataType == IrysDataType.IMAGE) {\r\n            return await this.uploadFileOrImageOnIrys(data, tags);\r\n        }\r\n\r\n        return await this.uploadDataOnIrys(data, tags, IrysMessageType.DATA_STORAGE);\r\n    }\r\n\r\n    async getDataFromAnAgent(agentsWalletPublicKeys: string[] = null, tags: GraphQLTag[] = null, timestamp: IrysTimestamp = null): Promise<DataIrysFetchedFromGQL> {\r\n        try {\r\n            const transactionIdsResponse = await this.getTransactionId(agentsWalletPublicKeys, tags, timestamp);\r\n            if (!transactionIdsResponse.success) return { success: false, data: null, error: \"Error fetching transaction IDs\" };\r\n            const transactionIdsAndResponse = transactionIdsResponse.data.map((node: NodeGQL) => node);\r\n            const dataPromises: Promise<any>[] = transactionIdsAndResponse.map(async (node: NodeGQL) => {\r\n                const fetchDataFromTransactionIdResponse = await this.fetchDataFromTransactionId(node.id);\r\n                if (await fetchDataFromTransactionIdResponse.data.headers.get('content-type') == \"application/octet-stream\") {\r\n                    let data = null;\r\n                    const responseText = await fetchDataFromTransactionIdResponse.data.text();\r\n                    try {\r\n                        data = JSON.parse(responseText);\r\n                    } catch {\r\n                        data = responseText;\r\n                    }\r\n                    return {\r\n                        data: data,\r\n                        address: node.address\r\n                    }\r\n                }\r\n                else {\r\n                    return {\r\n                        data: fetchDataFromTransactionIdResponse.data.url,\r\n                        address: node.address\r\n                    }\r\n                }\r\n            });\r\n            const data = await Promise.all(dataPromises);\r\n            return { success: true, data: data };\r\n        } catch (error) {\r\n            return { success: false, data: null, error: \"Error fetching data from transaction IDs \" + error };\r\n        }\r\n    }\r\n}\r\n\r\nexport default IrysService;","import { Plugin } from \"@elizaos/core\";\r\nimport IrysService from \"./services/irysService\";\r\n\r\nconst irysPlugin: Plugin = {\r\n    name: \"plugin-irys\",\r\n    description: \"Store and retrieve data on Irys to create a decentralized knowledge base and enable multi-agent collaboration\",\r\n    actions: [],\r\n    providers: [],\r\n    evaluators: [],\r\n    clients: [],\r\n    services: [new IrysService()],\r\n}\r\n\r\nexport default irysPlugin;\r\n"],"mappings":"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","names":["response","data"]}