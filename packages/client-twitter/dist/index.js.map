{"version":3,"sources":["../src/index.ts","../src/base.ts","../src/environment.ts","../src/interactions.ts","../src/utils.ts","../src/post.ts","../src/search.ts","../src/spaces.ts","../src/plugins/SttTtsSpacesPlugin.ts"],"sourcesContent":["import { Client, elizaLogger, IAgentRuntime } from \"@elizaos/core\";\r\nimport { ClientBase } from \"./base.ts\";\r\nimport { validateTwitterConfig, TwitterConfig } from \"./environment.ts\";\r\nimport { TwitterInteractionClient } from \"./interactions.ts\";\r\nimport { TwitterPostClient } from \"./post.ts\";\r\nimport { TwitterSearchClient } from \"./search.ts\";\r\nimport { TwitterSpaceClient } from \"./spaces.ts\";\r\n\r\n/**\r\n * A manager that orchestrates all specialized Twitter logic:\r\n * - client: base operations (login, timeline caching, etc.)\r\n * - post: autonomous posting logic\r\n * - search: searching tweets / replying logic\r\n * - interaction: handling mentions, replies\r\n * - space: launching and managing Twitter Spaces (optional)\r\n */\r\nclass TwitterManager {\r\n    client: ClientBase;\r\n    post: TwitterPostClient;\r\n    search: TwitterSearchClient;\r\n    interaction: TwitterInteractionClient;\r\n    space?: TwitterSpaceClient;\r\n\r\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\r\n        // Pass twitterConfig to the base client\r\n        this.client = new ClientBase(runtime, twitterConfig);\r\n\r\n        // Posting logic\r\n        this.post = new TwitterPostClient(this.client, runtime);\r\n\r\n        // Optional search logic (enabled if TWITTER_SEARCH_ENABLE is true)\r\n        if (twitterConfig.TWITTER_SEARCH_ENABLE) {\r\n            elizaLogger.warn(\"Twitter/X client running in a mode that:\");\r\n            elizaLogger.warn(\"1. violates consent of random users\");\r\n            elizaLogger.warn(\"2. burns your rate limit\");\r\n            elizaLogger.warn(\"3. can get your account banned\");\r\n            elizaLogger.warn(\"use at your own risk\");\r\n            this.search = new TwitterSearchClient(this.client, runtime);\r\n        }\r\n\r\n        // Mentions and interactions\r\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\r\n\r\n        // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)\r\n        if (twitterConfig.TWITTER_SPACES_ENABLE) {\r\n            this.space = new TwitterSpaceClient(this.client, runtime);\r\n        }\r\n    }\r\n}\r\n\r\nexport const TwitterClientInterface: Client = {\r\n    async start(runtime: IAgentRuntime) {\r\n        const twitterConfig: TwitterConfig =\r\n            await validateTwitterConfig(runtime);\r\n\r\n        elizaLogger.log(\"Twitter client started\");\r\n\r\n        const manager = new TwitterManager(runtime, twitterConfig);\r\n\r\n        // Initialize login/session\r\n        await manager.client.init();\r\n\r\n        // Start the posting loop\r\n        await manager.post.start();\r\n\r\n        // Start the search logic if it exists\r\n        if (manager.search) {\r\n            await manager.search.start();\r\n        }\r\n\r\n        // Start interactions (mentions, replies)\r\n        await manager.interaction.start();\r\n\r\n        // If Spaces are enabled, start the periodic check\r\n        if (manager.space) {\r\n            manager.space.startPeriodicSpaceCheck();\r\n        }\r\n\r\n        return manager;\r\n    },\r\n\r\n    async stop(_runtime: IAgentRuntime) {\r\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\r\n    },\r\n};\r\n\r\nexport default TwitterClientInterface;\r\n","import {\r\n    Content,\r\n    IAgentRuntime,\r\n    IImageDescriptionService,\r\n    Memory,\r\n    State,\r\n    UUID,\r\n    getEmbeddingZeroVector,\r\n    elizaLogger,\r\n    stringToUuid,\r\n    ActionTimelineType,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    QueryTweetsResponse,\r\n    Scraper,\r\n    SearchMode,\r\n    Tweet,\r\n} from \"agent-twitter-client\";\r\nimport { EventEmitter } from \"events\";\r\nimport { TwitterConfig } from \"./environment.ts\";\r\n\r\nexport function extractAnswer(text: string): string {\r\n    const startIndex = text.indexOf(\"Answer: \") + 8;\r\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\r\n    return text.slice(startIndex, endIndex);\r\n}\r\n\r\ntype TwitterProfile = {\r\n    id: string;\r\n    username: string;\r\n    screenName: string;\r\n    bio: string;\r\n    nicknames: string[];\r\n};\r\n\r\nclass RequestQueue {\r\n    private queue: (() => Promise<any>)[] = [];\r\n    private processing: boolean = false;\r\n\r\n    async add<T>(request: () => Promise<T>): Promise<T> {\r\n        return new Promise((resolve, reject) => {\r\n            this.queue.push(async () => {\r\n                try {\r\n                    const result = await request();\r\n                    resolve(result);\r\n                } catch (error) {\r\n                    reject(error);\r\n                }\r\n            });\r\n            this.processQueue();\r\n        });\r\n    }\r\n\r\n    private async processQueue(): Promise<void> {\r\n        if (this.processing || this.queue.length === 0) {\r\n            return;\r\n        }\r\n        this.processing = true;\r\n\r\n        while (this.queue.length > 0) {\r\n            const request = this.queue.shift()!;\r\n            try {\r\n                await request();\r\n            } catch (error) {\r\n                console.error(\"Error processing request:\", error);\r\n                this.queue.unshift(request);\r\n                await this.exponentialBackoff(this.queue.length);\r\n            }\r\n            await this.randomDelay();\r\n        }\r\n\r\n        this.processing = false;\r\n    }\r\n\r\n    private async exponentialBackoff(retryCount: number): Promise<void> {\r\n        const delay = Math.pow(2, retryCount) * 1000;\r\n        await new Promise((resolve) => setTimeout(resolve, delay));\r\n    }\r\n\r\n    private async randomDelay(): Promise<void> {\r\n        const delay = Math.floor(Math.random() * 2000) + 1500;\r\n        await new Promise((resolve) => setTimeout(resolve, delay));\r\n    }\r\n}\r\n\r\nexport class ClientBase extends EventEmitter {\r\n    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\r\n    twitterClient: Scraper;\r\n    runtime: IAgentRuntime;\r\n    twitterConfig: TwitterConfig;\r\n    directions: string;\r\n    lastCheckedTweetId: bigint | null = null;\r\n    imageDescriptionService: IImageDescriptionService;\r\n    temperature: number = 0.5;\r\n\r\n    requestQueue: RequestQueue = new RequestQueue();\r\n\r\n    profile: TwitterProfile | null;\r\n\r\n    async cacheTweet(tweet: Tweet): Promise<void> {\r\n        if (!tweet) {\r\n            console.warn(\"Tweet is undefined, skipping cache\");\r\n            return;\r\n        }\r\n\r\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\r\n    }\r\n\r\n    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\r\n        const cached = await this.runtime.cacheManager.get<Tweet>(\r\n            `twitter/tweets/${tweetId}`\r\n        );\r\n\r\n        return cached;\r\n    }\r\n\r\n    async getTweet(tweetId: string): Promise<Tweet> {\r\n        const cachedTweet = await this.getCachedTweet(tweetId);\r\n\r\n        if (cachedTweet) {\r\n            return cachedTweet;\r\n        }\r\n\r\n        const tweet = await this.requestQueue.add(() =>\r\n            this.twitterClient.getTweet(tweetId)\r\n        );\r\n\r\n        await this.cacheTweet(tweet);\r\n        return tweet;\r\n    }\r\n\r\n    callback: (self: ClientBase) => any = null;\r\n\r\n    onReady() {\r\n        throw new Error(\r\n            \"Not implemented in base class, please call from subclass\"\r\n        );\r\n    }\r\n\r\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\r\n        super();\r\n        this.runtime = runtime;\r\n        this.twitterConfig = twitterConfig;\r\n        const username = twitterConfig.TWITTER_USERNAME;\r\n        if (ClientBase._twitterClients[username]) {\r\n            this.twitterClient = ClientBase._twitterClients[username];\r\n        } else {\r\n            this.twitterClient = new Scraper();\r\n            ClientBase._twitterClients[username] = this.twitterClient;\r\n        }\r\n\r\n        this.directions =\r\n            \"- \" +\r\n            this.runtime.character.style.all.join(\"\\n- \") +\r\n            \"- \" +\r\n            this.runtime.character.style.post.join();\r\n    }\r\n\r\n    async init() {\r\n        const username = this.twitterConfig.TWITTER_USERNAME;\r\n        const password = this.twitterConfig.TWITTER_PASSWORD;\r\n        const email = this.twitterConfig.TWITTER_EMAIL;\r\n        let retries = this.twitterConfig.TWITTER_RETRY_LIMIT;\r\n        const twitter2faSecret = this.twitterConfig.TWITTER_2FA_SECRET;\r\n\r\n        if (!username) {\r\n            throw new Error(\"Twitter username not configured\");\r\n        }\r\n\r\n        const cachedCookies = await this.getCachedCookies(username);\r\n\r\n        if (cachedCookies) {\r\n            elizaLogger.info(\"Using cached cookies\");\r\n            await this.setCookiesFromArray(cachedCookies);\r\n        }\r\n\r\n        elizaLogger.log(\"Waiting for Twitter login\");\r\n        while (retries > 0) {\r\n            try {\r\n                if (await this.twitterClient.isLoggedIn()) {\r\n                    // cookies are valid, no login required\r\n                    elizaLogger.info(\"Successfully logged in.\");\r\n                    break;\r\n                } else {\r\n                    await this.twitterClient.login(\r\n                        username,\r\n                        password,\r\n                        email,\r\n                        twitter2faSecret\r\n                    );\r\n                    if (await this.twitterClient.isLoggedIn()) {\r\n                        // fresh login, store new cookies\r\n                        elizaLogger.info(\"Successfully logged in.\");\r\n                        elizaLogger.info(\"Caching cookies\");\r\n                        await this.cacheCookies(\r\n                            username,\r\n                            await this.twitterClient.getCookies()\r\n                        );\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(`Login attempt failed: ${error.message}`);\r\n            }\r\n\r\n            retries--;\r\n            elizaLogger.error(\r\n                `Failed to login to Twitter. Retrying... (${retries} attempts left)`\r\n            );\r\n\r\n            if (retries === 0) {\r\n                elizaLogger.error(\r\n                    \"Max retries reached. Exiting login process.\"\r\n                );\r\n                throw new Error(\"Twitter login failed after maximum retries.\");\r\n            }\r\n\r\n            await new Promise((resolve) => setTimeout(resolve, 2000));\r\n        }\r\n        // Initialize Twitter profile\r\n        this.profile = await this.fetchProfile(username);\r\n\r\n        if (this.profile) {\r\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\r\n            elizaLogger.log(\r\n                \"Twitter loaded:\",\r\n                JSON.stringify(this.profile, null, 10)\r\n            );\r\n            // Store profile info for use in responses\r\n            this.runtime.character.twitterProfile = {\r\n                id: this.profile.id,\r\n                username: this.profile.username,\r\n                screenName: this.profile.screenName,\r\n                bio: this.profile.bio,\r\n                nicknames: this.profile.nicknames,\r\n            };\r\n        } else {\r\n            throw new Error(\"Failed to load profile\");\r\n        }\r\n\r\n        await this.loadLatestCheckedTweetId();\r\n        await this.populateTimeline();\r\n    }\r\n\r\n    async fetchOwnPosts(count: number): Promise<Tweet[]> {\r\n        elizaLogger.debug(\"fetching own posts\");\r\n        const homeTimeline = await this.twitterClient.getUserTweets(\r\n            this.profile.id,\r\n            count\r\n        );\r\n        return homeTimeline.tweets;\r\n    }\r\n\r\n    /**\r\n     * Fetch timeline for twitter account, optionally only from followed accounts\r\n     */\r\n    async fetchHomeTimeline(\r\n        count: number,\r\n        following?: boolean\r\n    ): Promise<Tweet[]> {\r\n        elizaLogger.debug(\"fetching home timeline\");\r\n        const homeTimeline = following\r\n            ? await this.twitterClient.fetchFollowingTimeline(count, [])\r\n            : await this.twitterClient.fetchHomeTimeline(count, []);\r\n\r\n        elizaLogger.debug(homeTimeline, { depth: Infinity });\r\n        const processedTimeline = homeTimeline\r\n            .filter((t) => t.__typename !== \"TweetWithVisibilityResults\") // what's this about?\r\n            .map((tweet) => {\r\n                //console.log(\"tweet is\", tweet);\r\n                const obj = {\r\n                    id: tweet.id,\r\n                    name:\r\n                        tweet.name ?? tweet?.user_results?.result?.legacy.name,\r\n                    username:\r\n                        tweet.username ??\r\n                        tweet.core?.user_results?.result?.legacy.screen_name,\r\n                    text: tweet.text ?? tweet.legacy?.full_text,\r\n                    inReplyToStatusId:\r\n                        tweet.inReplyToStatusId ??\r\n                        tweet.legacy?.in_reply_to_status_id_str ??\r\n                        null,\r\n                    timestamp:\r\n                        new Date(tweet.legacy?.created_at).getTime() / 1000,\r\n                    createdAt:\r\n                        tweet.createdAt ??\r\n                        tweet.legacy?.created_at ??\r\n                        tweet.core?.user_results?.result?.legacy.created_at,\r\n                    userId: tweet.userId ?? tweet.legacy?.user_id_str,\r\n                    conversationId:\r\n                        tweet.conversationId ??\r\n                        tweet.legacy?.conversation_id_str,\r\n                    permanentUrl: `https://x.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\r\n                    hashtags: tweet.hashtags ?? tweet.legacy?.entities.hashtags,\r\n                    mentions:\r\n                        tweet.mentions ?? tweet.legacy?.entities.user_mentions,\r\n                    photos:\r\n                        tweet.legacy?.entities?.media\r\n                            ?.filter((media) => media.type === \"photo\")\r\n                            .map((media) => ({\r\n                                id: media.id_str,\r\n                                url: media.media_url_https, // Store media_url_https as url\r\n                                alt_text: media.alt_text,\r\n                            })) || [],\r\n                    thread: tweet.thread || [],\r\n                    urls: tweet.urls ?? tweet.legacy?.entities.urls,\r\n                    videos:\r\n                        tweet.videos ??\r\n                        tweet.legacy?.entities.media?.filter(\r\n                            (media) => media.type === \"video\"\r\n                        ) ??\r\n                        [],\r\n                };\r\n                //console.log(\"obj is\", obj);\r\n                return obj;\r\n            });\r\n        //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\r\n        return processedTimeline;\r\n    }\r\n\r\n    async fetchTimelineForActions(count: number): Promise<Tweet[]> {\r\n        elizaLogger.debug(\"fetching timeline for actions\");\r\n\r\n        const agentUsername = this.twitterConfig.TWITTER_USERNAME;\r\n\r\n        const homeTimeline =\r\n            this.twitterConfig.ACTION_TIMELINE_TYPE ===\r\n            ActionTimelineType.Following\r\n                ? await this.twitterClient.fetchFollowingTimeline(count, [])\r\n                : await this.twitterClient.fetchHomeTimeline(count, []);\r\n\r\n        return homeTimeline\r\n            .map((tweet) => ({\r\n                id: tweet.rest_id,\r\n                name: tweet.core?.user_results?.result?.legacy?.name,\r\n                username: tweet.core?.user_results?.result?.legacy?.screen_name,\r\n                text: tweet.legacy?.full_text,\r\n                inReplyToStatusId: tweet.legacy?.in_reply_to_status_id_str,\r\n                timestamp: new Date(tweet.legacy?.created_at).getTime() / 1000,\r\n                userId: tweet.legacy?.user_id_str,\r\n                conversationId: tweet.legacy?.conversation_id_str,\r\n                permanentUrl: `https://twitter.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\r\n                hashtags: tweet.legacy?.entities?.hashtags || [],\r\n                mentions: tweet.legacy?.entities?.user_mentions || [],\r\n                photos:\r\n                    tweet.legacy?.entities?.media\r\n                        ?.filter((media) => media.type === \"photo\")\r\n                        .map((media) => ({\r\n                            id: media.id_str,\r\n                            url: media.media_url_https, // Store media_url_https as url\r\n                            alt_text: media.alt_text,\r\n                        })) || [],\r\n                thread: tweet.thread || [],\r\n                urls: tweet.legacy?.entities?.urls || [],\r\n                videos:\r\n                    tweet.legacy?.entities?.media?.filter(\r\n                        (media) => media.type === \"video\"\r\n                    ) || [],\r\n            }))\r\n            .filter((tweet) => tweet.username !== agentUsername) // do not perform action on self-tweets\r\n            .slice(0, count);\r\n        // TODO: Once the 'count' parameter is fixed in the 'fetchTimeline' method of the 'agent-twitter-client',\r\n        // this workaround can be removed.\r\n        // Related issue: https://github.com/elizaos/agent-twitter-client/issues/43\r\n    }\r\n\r\n    async fetchSearchTweets(\r\n        query: string,\r\n        maxTweets: number,\r\n        searchMode: SearchMode,\r\n        cursor?: string\r\n    ): Promise<QueryTweetsResponse> {\r\n        try {\r\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\r\n            // if we dont get a response in 5 seconds, something is wrong\r\n            const timeoutPromise = new Promise((resolve) =>\r\n                setTimeout(() => resolve({ tweets: [] }), 15000)\r\n            );\r\n\r\n            try {\r\n                const result = await this.requestQueue.add(\r\n                    async () =>\r\n                        await Promise.race([\r\n                            this.twitterClient.fetchSearchTweets(\r\n                                query,\r\n                                maxTweets,\r\n                                searchMode,\r\n                                cursor\r\n                            ),\r\n                            timeoutPromise,\r\n                        ])\r\n                );\r\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching search tweets:\", error);\r\n                return { tweets: [] };\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error fetching search tweets:\", error);\r\n            return { tweets: [] };\r\n        }\r\n    }\r\n\r\n    private async populateTimeline() {\r\n        elizaLogger.debug(\"populating timeline...\");\r\n\r\n        const cachedTimeline = await this.getCachedTimeline();\r\n\r\n        // Check if the cache file exists\r\n        if (cachedTimeline) {\r\n            // Read the cached search results from the file\r\n\r\n            // Get the existing memories from the database\r\n            const existingMemories =\r\n                await this.runtime.messageManager.getMemoriesByRoomIds({\r\n                    roomIds: cachedTimeline.map((tweet) =>\r\n                        stringToUuid(\r\n                            tweet.conversationId + \"-\" + this.runtime.agentId\r\n                        )\r\n                    ),\r\n                });\r\n\r\n            //TODO: load tweets not in cache?\r\n\r\n            // Create a Set to store the IDs of existing memories\r\n            const existingMemoryIds = new Set(\r\n                existingMemories.map((memory) => memory.id.toString())\r\n            );\r\n\r\n            // Check if any of the cached tweets exist in the existing memories\r\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\r\n                existingMemoryIds.has(\r\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                )\r\n            );\r\n\r\n            if (someCachedTweetsExist) {\r\n                // Filter out the cached tweets that already exist in the database\r\n                const tweetsToSave = cachedTimeline.filter(\r\n                    (tweet) =>\r\n                        !existingMemoryIds.has(\r\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                        )\r\n                );\r\n\r\n                console.log({\r\n                    processingTweets: tweetsToSave\r\n                        .map((tweet) => tweet.id)\r\n                        .join(\",\"),\r\n                });\r\n\r\n                // Save the missing tweets as memories\r\n                for (const tweet of tweetsToSave) {\r\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\r\n\r\n                    const roomId = stringToUuid(\r\n                        tweet.conversationId + \"-\" + this.runtime.agentId\r\n                    );\r\n\r\n                    const userId =\r\n                        tweet.userId === this.profile.id\r\n                            ? this.runtime.agentId\r\n                            : stringToUuid(tweet.userId);\r\n\r\n                    if (tweet.userId === this.profile.id) {\r\n                        await this.runtime.ensureConnection(\r\n                            this.runtime.agentId,\r\n                            roomId,\r\n                            this.profile.username,\r\n                            this.profile.screenName,\r\n                            \"twitter\"\r\n                        );\r\n                    } else {\r\n                        await this.runtime.ensureConnection(\r\n                            userId,\r\n                            roomId,\r\n                            tweet.username,\r\n                            tweet.name,\r\n                            \"twitter\"\r\n                        );\r\n                    }\r\n\r\n                    const content = {\r\n                        text: tweet.text,\r\n                        url: tweet.permanentUrl,\r\n                        source: \"twitter\",\r\n                        inReplyTo: tweet.inReplyToStatusId\r\n                            ? stringToUuid(\r\n                                  tweet.inReplyToStatusId +\r\n                                      \"-\" +\r\n                                      this.runtime.agentId\r\n                              )\r\n                            : undefined,\r\n                    } as Content;\r\n\r\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\r\n\r\n                    // check if it already exists\r\n                    const memory =\r\n                        await this.runtime.messageManager.getMemoryById(\r\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                        );\r\n\r\n                    if (memory) {\r\n                        elizaLogger.log(\r\n                            \"Memory already exists, skipping timeline population\"\r\n                        );\r\n                        break;\r\n                    }\r\n\r\n                    await this.runtime.messageManager.createMemory({\r\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\r\n                        userId,\r\n                        content: content,\r\n                        agentId: this.runtime.agentId,\r\n                        roomId,\r\n                        embedding: getEmbeddingZeroVector(),\r\n                        createdAt: tweet.timestamp * 1000,\r\n                    });\r\n\r\n                    await this.cacheTweet(tweet);\r\n                }\r\n\r\n                elizaLogger.log(\r\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\r\n        const username = this.twitterConfig.TWITTER_USERNAME;\r\n\r\n        // Get the most recent 20 mentions and interactions\r\n        const mentionsAndInteractions = await this.fetchSearchTweets(\r\n            `@${username}`,\r\n            20,\r\n            SearchMode.Latest\r\n        );\r\n\r\n        // Combine the timeline tweets and mentions/interactions\r\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\r\n\r\n        // Create a Set to store unique tweet IDs\r\n        const tweetIdsToCheck = new Set<string>();\r\n        const roomIds = new Set<UUID>();\r\n\r\n        // Add tweet IDs to the Set\r\n        for (const tweet of allTweets) {\r\n            tweetIdsToCheck.add(tweet.id);\r\n            roomIds.add(\r\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\r\n            );\r\n        }\r\n\r\n        // Check the existing memories in the database\r\n        const existingMemories =\r\n            await this.runtime.messageManager.getMemoriesByRoomIds({\r\n                roomIds: Array.from(roomIds),\r\n            });\r\n\r\n        // Create a Set to store the existing memory IDs\r\n        const existingMemoryIds = new Set<UUID>(\r\n            existingMemories.map((memory) => memory.id)\r\n        );\r\n\r\n        // Filter out the tweets that already exist in the database\r\n        const tweetsToSave = allTweets.filter(\r\n            (tweet) =>\r\n                !existingMemoryIds.has(\r\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                )\r\n        );\r\n\r\n        elizaLogger.debug({\r\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\r\n        });\r\n\r\n        await this.runtime.ensureUserExists(\r\n            this.runtime.agentId,\r\n            this.profile.username,\r\n            this.runtime.character.name,\r\n            \"twitter\"\r\n        );\r\n\r\n        // Save the new tweets as memories\r\n        for (const tweet of tweetsToSave) {\r\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\r\n\r\n            const roomId = stringToUuid(\r\n                tweet.conversationId + \"-\" + this.runtime.agentId\r\n            );\r\n            const userId =\r\n                tweet.userId === this.profile.id\r\n                    ? this.runtime.agentId\r\n                    : stringToUuid(tweet.userId);\r\n\r\n            if (tweet.userId === this.profile.id) {\r\n                await this.runtime.ensureConnection(\r\n                    this.runtime.agentId,\r\n                    roomId,\r\n                    this.profile.username,\r\n                    this.profile.screenName,\r\n                    \"twitter\"\r\n                );\r\n            } else {\r\n                await this.runtime.ensureConnection(\r\n                    userId,\r\n                    roomId,\r\n                    tweet.username,\r\n                    tweet.name,\r\n                    \"twitter\"\r\n                );\r\n            }\r\n\r\n            const content = {\r\n                text: tweet.text,\r\n                url: tweet.permanentUrl,\r\n                source: \"twitter\",\r\n                inReplyTo: tweet.inReplyToStatusId\r\n                    ? stringToUuid(tweet.inReplyToStatusId)\r\n                    : undefined,\r\n            } as Content;\r\n\r\n            await this.runtime.messageManager.createMemory({\r\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\r\n                userId,\r\n                content: content,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n                embedding: getEmbeddingZeroVector(),\r\n                createdAt: tweet.timestamp * 1000,\r\n            });\r\n\r\n            await this.cacheTweet(tweet);\r\n        }\r\n\r\n        // Cache\r\n        await this.cacheTimeline(timeline);\r\n        await this.cacheMentions(mentionsAndInteractions.tweets);\r\n    }\r\n\r\n    async setCookiesFromArray(cookiesArray: any[]) {\r\n        const cookieStrings = cookiesArray.map(\r\n            (cookie) =>\r\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\r\n                    cookie.secure ? \"Secure\" : \"\"\r\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\r\n                    cookie.sameSite || \"Lax\"\r\n                }`\r\n        );\r\n        await this.twitterClient.setCookies(cookieStrings);\r\n    }\r\n\r\n    async saveRequestMessage(message: Memory, state: State) {\r\n        if (message.content.text) {\r\n            const recentMessage = await this.runtime.messageManager.getMemories(\r\n                {\r\n                    roomId: message.roomId,\r\n                    count: 1,\r\n                    unique: false,\r\n                }\r\n            );\r\n\r\n            if (\r\n                recentMessage.length > 0 &&\r\n                recentMessage[0].content === message.content\r\n            ) {\r\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\r\n            } else {\r\n                await this.runtime.messageManager.createMemory({\r\n                    ...message,\r\n                    embedding: getEmbeddingZeroVector(),\r\n                });\r\n            }\r\n\r\n            await this.runtime.evaluate(message, {\r\n                ...state,\r\n                twitterClient: this.twitterClient,\r\n            });\r\n        }\r\n    }\r\n\r\n    async loadLatestCheckedTweetId(): Promise<void> {\r\n        const latestCheckedTweetId =\r\n            await this.runtime.cacheManager.get<string>(\r\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\r\n            );\r\n\r\n        if (latestCheckedTweetId) {\r\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\r\n        }\r\n    }\r\n\r\n    async cacheLatestCheckedTweetId() {\r\n        if (this.lastCheckedTweetId) {\r\n            await this.runtime.cacheManager.set(\r\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\r\n                this.lastCheckedTweetId.toString()\r\n            );\r\n        }\r\n    }\r\n\r\n    async getCachedTimeline(): Promise<Tweet[] | undefined> {\r\n        return await this.runtime.cacheManager.get<Tweet[]>(\r\n            `twitter/${this.profile.username}/timeline`\r\n        );\r\n    }\r\n\r\n    async cacheTimeline(timeline: Tweet[]) {\r\n        await this.runtime.cacheManager.set(\r\n            `twitter/${this.profile.username}/timeline`,\r\n            timeline,\r\n            { expires: Date.now() + 10 * 1000 }\r\n        );\r\n    }\r\n\r\n    async cacheMentions(mentions: Tweet[]) {\r\n        await this.runtime.cacheManager.set(\r\n            `twitter/${this.profile.username}/mentions`,\r\n            mentions,\r\n            { expires: Date.now() + 10 * 1000 }\r\n        );\r\n    }\r\n\r\n    async getCachedCookies(username: string) {\r\n        return await this.runtime.cacheManager.get<any[]>(\r\n            `twitter/${username}/cookies`\r\n        );\r\n    }\r\n\r\n    async cacheCookies(username: string, cookies: any[]) {\r\n        await this.runtime.cacheManager.set(\r\n            `twitter/${username}/cookies`,\r\n            cookies\r\n        );\r\n    }\r\n\r\n    async fetchProfile(username: string): Promise<TwitterProfile> {\r\n        try {\r\n            const profile = await this.requestQueue.add(async () => {\r\n                const profile = await this.twitterClient.getProfile(username);\r\n                return {\r\n                    id: profile.userId,\r\n                    username,\r\n                    screenName: profile.name || this.runtime.character.name,\r\n                    bio:\r\n                        profile.biography ||\r\n                        typeof this.runtime.character.bio === \"string\"\r\n                            ? (this.runtime.character.bio as string)\r\n                            : this.runtime.character.bio.length > 0\r\n                              ? this.runtime.character.bio[0]\r\n                              : \"\",\r\n                    nicknames:\r\n                        this.runtime.character.twitterProfile?.nicknames || [],\r\n                } satisfies TwitterProfile;\r\n            });\r\n\r\n            return profile;\r\n        } catch (error) {\r\n            console.error(\"Error fetching Twitter profile:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","import {\r\n    parseBooleanFromText,\r\n    IAgentRuntime,\r\n    ActionTimelineType,\r\n} from \"@elizaos/core\";\r\nimport { z, ZodError } from \"zod\";\r\n\r\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\r\n\r\nconst twitterUsernameSchema = z\r\n    .string()\r\n    .min(1, \"An X/Twitter Username must be at least 1 character long\")\r\n    .max(15, \"An X/Twitter Username cannot exceed 15 characters\")\r\n    .refine((username) => {\r\n        // Allow wildcard '*' as a special case\r\n        if (username === \"*\") return true;\r\n\r\n        // Twitter usernames can:\r\n        // - Start with digits now\r\n        // - Contain letters, numbers, underscores\r\n        // - Must not be empty\r\n        return /^[A-Za-z0-9_]+$/.test(username);\r\n    }, \"An X Username can only contain letters, numbers, and underscores\");\r\n\r\n/**\r\n * This schema defines all required/optional environment settings,\r\n * including new fields like TWITTER_SPACES_ENABLE.\r\n */\r\nexport const twitterEnvSchema = z.object({\r\n    TWITTER_DRY_RUN: z.boolean(),\r\n    TWITTER_USERNAME: z.string().min(1, \"X/Twitter username is required\"),\r\n    TWITTER_PASSWORD: z.string().min(1, \"X/Twitter password is required\"),\r\n    TWITTER_EMAIL: z.string().email(\"Valid X/Twitter email is required\"),\r\n    MAX_TWEET_LENGTH: z.number().int().default(DEFAULT_MAX_TWEET_LENGTH),\r\n    TWITTER_SEARCH_ENABLE: z.boolean().default(false),\r\n    TWITTER_2FA_SECRET: z.string(),\r\n    TWITTER_RETRY_LIMIT: z.number().int(),\r\n    TWITTER_POLL_INTERVAL: z.number().int(),\r\n    TWITTER_TARGET_USERS: z.array(twitterUsernameSchema).default([]),\r\n    // I guess it's possible to do the transformation with zod\r\n    // not sure it's preferable, maybe a readability issue\r\n    // since more people will know js/ts than zod\r\n    /*\r\n        z\r\n        .string()\r\n        .transform((val) => val.trim())\r\n        .pipe(\r\n            z.string()\r\n                .transform((val) =>\r\n                    val ? val.split(',').map((u) => u.trim()).filter(Boolean) : []\r\n                )\r\n                .pipe(\r\n                    z.array(\r\n                        z.string()\r\n                            .min(1)\r\n                            .max(15)\r\n                            .regex(\r\n                                /^[A-Za-z][A-Za-z0-9_]*[A-Za-z0-9]$|^[A-Za-z]$/,\r\n                                'Invalid Twitter username format'\r\n                            )\r\n                    )\r\n                )\r\n                .transform((users) => users.join(','))\r\n        )\r\n        .optional()\r\n        .default(''),\r\n    */\r\n    POST_INTERVAL_MIN: z.number().int(),\r\n    POST_INTERVAL_MAX: z.number().int(),\r\n    ENABLE_ACTION_PROCESSING: z.boolean(),\r\n    ACTION_INTERVAL: z.number().int(),\r\n    POST_IMMEDIATELY: z.boolean(),\r\n    TWITTER_SPACES_ENABLE: z.boolean().default(false),\r\n    MAX_ACTIONS_PROCESSING: z.number().int(),\r\n    ACTION_TIMELINE_TYPE: z\r\n        .nativeEnum(ActionTimelineType)\r\n        .default(ActionTimelineType.ForYou),\r\n});\r\n\r\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\r\n\r\n/**\r\n * Helper to parse a comma-separated list of Twitter usernames\r\n * (already present in your code).\r\n */\r\nfunction parseTargetUsers(targetUsersStr?: string | null): string[] {\r\n    if (!targetUsersStr?.trim()) {\r\n        return [];\r\n    }\r\n    return targetUsersStr\r\n        .split(\",\")\r\n        .map((user) => user.trim())\r\n        .filter(Boolean);\r\n}\r\n\r\nfunction safeParseInt(\r\n    value: string | undefined | null,\r\n    defaultValue: number\r\n): number {\r\n    if (!value) return defaultValue;\r\n    const parsed = parseInt(value, 10);\r\n    return isNaN(parsed) ? defaultValue : Math.max(1, parsed);\r\n}\r\n\r\n/**\r\n * Validates or constructs a TwitterConfig object using zod,\r\n * taking values from the IAgentRuntime or process.env as needed.\r\n */\r\n// This also is organized to serve as a point of documentation for the client\r\n// most of the inputs from the framework (env/character)\r\n\r\n// we also do a lot of typing/parsing here\r\n// so we can do it once and only once per character\r\nexport async function validateTwitterConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<TwitterConfig> {\r\n    try {\r\n        const twitterConfig = {\r\n            TWITTER_DRY_RUN:\r\n                parseBooleanFromText(\r\n                    runtime.getSetting(\"TWITTER_DRY_RUN\") ||\r\n                        process.env.TWITTER_DRY_RUN\r\n                ) ?? false, // parseBooleanFromText return null if \"\", map \"\" to false\r\n\r\n            TWITTER_USERNAME:\r\n                runtime.getSetting(\"TWITTER_USERNAME\") ||\r\n                process.env.TWITTER_USERNAME,\r\n\r\n            TWITTER_PASSWORD:\r\n                runtime.getSetting(\"TWITTER_PASSWORD\") ||\r\n                process.env.TWITTER_PASSWORD,\r\n\r\n            TWITTER_EMAIL:\r\n                runtime.getSetting(\"TWITTER_EMAIL\") ||\r\n                process.env.TWITTER_EMAIL,\r\n\r\n            // number as string?\r\n            MAX_TWEET_LENGTH: safeParseInt(\r\n                runtime.getSetting(\"MAX_TWEET_LENGTH\") ||\r\n                    process.env.MAX_TWEET_LENGTH,\r\n                DEFAULT_MAX_TWEET_LENGTH\r\n            ),\r\n\r\n            TWITTER_SEARCH_ENABLE:\r\n                parseBooleanFromText(\r\n                    runtime.getSetting(\"TWITTER_SEARCH_ENABLE\") ||\r\n                        process.env.TWITTER_SEARCH_ENABLE\r\n                ) ?? false,\r\n\r\n            // string passthru\r\n            TWITTER_2FA_SECRET:\r\n                runtime.getSetting(\"TWITTER_2FA_SECRET\") ||\r\n                process.env.TWITTER_2FA_SECRET ||\r\n                \"\",\r\n\r\n            // int\r\n            TWITTER_RETRY_LIMIT: safeParseInt(\r\n                runtime.getSetting(\"TWITTER_RETRY_LIMIT\") ||\r\n                    process.env.TWITTER_RETRY_LIMIT,\r\n                5\r\n            ),\r\n\r\n            // int in seconds\r\n            TWITTER_POLL_INTERVAL: safeParseInt(\r\n                runtime.getSetting(\"TWITTER_POLL_INTERVAL\") ||\r\n                    process.env.TWITTER_POLL_INTERVAL,\r\n                120 // 2m\r\n            ),\r\n\r\n            // comma separated string\r\n            TWITTER_TARGET_USERS: parseTargetUsers(\r\n                runtime.getSetting(\"TWITTER_TARGET_USERS\") ||\r\n                    process.env.TWITTER_TARGET_USERS\r\n            ),\r\n\r\n            // int in minutes\r\n            POST_INTERVAL_MIN: safeParseInt(\r\n                runtime.getSetting(\"POST_INTERVAL_MIN\") ||\r\n                    process.env.POST_INTERVAL_MIN,\r\n                90 // 1.5 hours\r\n            ),\r\n\r\n            // int in minutes\r\n            POST_INTERVAL_MAX: safeParseInt(\r\n                runtime.getSetting(\"POST_INTERVAL_MAX\") ||\r\n                    process.env.POST_INTERVAL_MAX,\r\n                180 // 3 hours\r\n            ),\r\n\r\n            // bool\r\n            ENABLE_ACTION_PROCESSING:\r\n                parseBooleanFromText(\r\n                    runtime.getSetting(\"ENABLE_ACTION_PROCESSING\") ||\r\n                        process.env.ENABLE_ACTION_PROCESSING\r\n                ) ?? false,\r\n\r\n            // init in minutes (min 1m)\r\n            ACTION_INTERVAL: safeParseInt(\r\n                runtime.getSetting(\"ACTION_INTERVAL\") ||\r\n                    process.env.ACTION_INTERVAL,\r\n                5 // 5 minutes\r\n            ),\r\n\r\n            // bool\r\n            POST_IMMEDIATELY:\r\n                parseBooleanFromText(\r\n                    runtime.getSetting(\"POST_IMMEDIATELY\") ||\r\n                        process.env.POST_IMMEDIATELY\r\n                ) ?? false,\r\n\r\n            TWITTER_SPACES_ENABLE:\r\n                parseBooleanFromText(\r\n                    runtime.getSetting(\"TWITTER_SPACES_ENABLE\") ||\r\n                        process.env.TWITTER_SPACES_ENABLE\r\n                ) ?? false,\r\n\r\n            MAX_ACTIONS_PROCESSING: safeParseInt(\r\n                runtime.getSetting(\"MAX_ACTIONS_PROCESSING\") ||\r\n                    process.env.MAX_ACTIONS_PROCESSING,\r\n                1\r\n            ),\r\n\r\n            ACTION_TIMELINE_TYPE:\r\n                runtime.getSetting(\"ACTION_TIMELINE_TYPE\") ||\r\n                process.env.ACTION_TIMELINE_TYPE,\r\n        };\r\n\r\n        return twitterEnvSchema.parse(twitterConfig);\r\n    } catch (error) {\r\n        if (error instanceof ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `X/Twitter configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n","import { SearchMode, Tweet } from \"agent-twitter-client\";\r\nimport {\r\n    composeContext,\r\n    generateMessageResponse,\r\n    generateShouldRespond,\r\n    messageCompletionFooter,\r\n    shouldRespondFooter,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    stringToUuid,\r\n    elizaLogger,\r\n    getEmbeddingZeroVector,\r\n    IImageDescriptionService,\r\n    ServiceType\r\n} from \"@elizaos/core\";\r\nimport { ClientBase } from \"./base\";\r\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\r\n\r\nexport const twitterMessageHandlerTemplate =\r\n    `\r\n# Areas of Expertise\r\n{{knowledge}}\r\n\r\n# About {{agentName}} (@{{twitterUserName}}):\r\n{{bio}}\r\n{{lore}}\r\n{{topics}}\r\n\r\n{{providers}}\r\n\r\n{{characterPostExamples}}\r\n\r\n{{postDirections}}\r\n\r\nRecent interactions between {{agentName}} and other users:\r\n{{recentPostInteractions}}\r\n\r\n{{recentPosts}}\r\n\r\n# TASK: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\r\n\r\nCurrent Post:\r\n{{currentPost}}\r\nHere is the descriptions of images in the Current post.\r\n{{imageDescriptions}}\r\n\r\nThread of Tweets You Are Replying To:\r\n{{formattedConversation}}\r\n\r\n# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\r\n{{actionNames}}\r\n{{actions}}\r\n\r\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\r\n{{currentPost}}\r\nHere is the descriptions of images in the Current post.\r\n{{imageDescriptions}}\r\n` + messageCompletionFooter;\r\n\r\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\r\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\r\n\r\nResponse options are RESPOND, IGNORE and STOP.\r\n\r\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\r\n\r\nFor other users:\r\n- {{agentName}} should RESPOND to messages directed at them\r\n- {{agentName}} should RESPOND to conversations relevant to their background\r\n- {{agentName}} should IGNORE irrelevant messages\r\n- {{agentName}} should IGNORE very short messages unless directly addressed\r\n- {{agentName}} should STOP if asked to stop\r\n- {{agentName}} should STOP if conversation is concluded\r\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\r\n\r\nIMPORTANT:\r\n- {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\r\n- For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\r\n\r\nRecent Posts:\r\n{{recentPosts}}\r\n\r\nCurrent Post:\r\n{{currentPost}}\r\n\r\nThread of Tweets You Are Replying To:\r\n{{formattedConversation}}\r\n\r\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\r\n` + shouldRespondFooter;\r\n\r\nexport class TwitterInteractionClient {\r\n    client: ClientBase;\r\n    runtime: IAgentRuntime;\r\n    private isDryRun: boolean;\r\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.runtime = runtime;\r\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\r\n    }\r\n\r\n    async start() {\r\n        const handleTwitterInteractionsLoop = () => {\r\n            this.handleTwitterInteractions();\r\n            setTimeout(\r\n                handleTwitterInteractionsLoop,\r\n                // Defaults to 2 minutes\r\n                this.client.twitterConfig.TWITTER_POLL_INTERVAL * 1000\r\n            );\r\n        };\r\n        handleTwitterInteractionsLoop();\r\n    }\r\n\r\n    async handleTwitterInteractions() {\r\n        elizaLogger.log(\"Checking Twitter interactions\");\r\n\r\n        const twitterUsername = this.client.profile.username;\r\n        try {\r\n            // Check for mentions\r\n            const mentionCandidates = (\r\n                await this.client.fetchSearchTweets(\r\n                    `@${twitterUsername}`,\r\n                    20,\r\n                    SearchMode.Latest\r\n                )\r\n            ).tweets;\r\n\r\n            elizaLogger.log(\r\n                \"Completed checking mentioned tweets:\",\r\n                mentionCandidates.length\r\n            );\r\n            let uniqueTweetCandidates = [...mentionCandidates];\r\n            // Only process target users if configured\r\n            if (this.client.twitterConfig.TWITTER_TARGET_USERS.length) {\r\n                const TARGET_USERS =\r\n                    this.client.twitterConfig.TWITTER_TARGET_USERS;\r\n\r\n                elizaLogger.log(\"Processing target users:\", TARGET_USERS);\r\n\r\n                if (TARGET_USERS.length > 0) {\r\n                    // Create a map to store tweets by user\r\n                    const tweetsByUser = new Map<string, Tweet[]>();\r\n\r\n                    // Fetch tweets from all target users\r\n                    for (const username of TARGET_USERS) {\r\n                        try {\r\n                            const userTweets = (\r\n                                await this.client.twitterClient.fetchSearchTweets(\r\n                                    `from:${username}`,\r\n                                    3,\r\n                                    SearchMode.Latest\r\n                                )\r\n                            ).tweets;\r\n\r\n                            // Filter for unprocessed, non-reply, recent tweets\r\n                            const validTweets = userTweets.filter((tweet) => {\r\n                                const isUnprocessed =\r\n                                    !this.client.lastCheckedTweetId ||\r\n                                    parseInt(tweet.id) >\r\n                                        this.client.lastCheckedTweetId;\r\n                                const isRecent =\r\n                                    Date.now() - tweet.timestamp * 1000 <\r\n                                    2 * 60 * 60 * 1000;\r\n\r\n                                elizaLogger.log(`Tweet ${tweet.id} checks:`, {\r\n                                    isUnprocessed,\r\n                                    isRecent,\r\n                                    isReply: tweet.isReply,\r\n                                    isRetweet: tweet.isRetweet,\r\n                                });\r\n\r\n                                return (\r\n                                    isUnprocessed &&\r\n                                    !tweet.isReply &&\r\n                                    !tweet.isRetweet &&\r\n                                    isRecent\r\n                                );\r\n                            });\r\n\r\n                            if (validTweets.length > 0) {\r\n                                tweetsByUser.set(username, validTweets);\r\n                                elizaLogger.log(\r\n                                    `Found ${validTweets.length} valid tweets from ${username}`\r\n                                );\r\n                            }\r\n                        } catch (error) {\r\n                            elizaLogger.error(\r\n                                `Error fetching tweets for ${username}:`,\r\n                                error\r\n                            );\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    // Select one tweet from each user that has tweets\r\n                    const selectedTweets: Tweet[] = [];\r\n                    for (const [username, tweets] of tweetsByUser) {\r\n                        if (tweets.length > 0) {\r\n                            // Randomly select one tweet from this user\r\n                            const randomTweet =\r\n                                tweets[\r\n                                    Math.floor(Math.random() * tweets.length)\r\n                                ];\r\n                            selectedTweets.push(randomTweet);\r\n                            elizaLogger.log(\r\n                                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`\r\n                            );\r\n                        }\r\n                    }\r\n\r\n                    // Add selected tweets to candidates\r\n                    uniqueTweetCandidates = [\r\n                        ...mentionCandidates,\r\n                        ...selectedTweets,\r\n                    ];\r\n                }\r\n            } else {\r\n                elizaLogger.log(\r\n                    \"No target users configured, processing only mentions\"\r\n                );\r\n            }\r\n\r\n            // Sort tweet candidates by ID in ascending order\r\n            uniqueTweetCandidates\r\n                .sort((a, b) => a.id.localeCompare(b.id))\r\n                .filter((tweet) => tweet.userId !== this.client.profile.id);\r\n\r\n            // for each tweet candidate, handle the tweet\r\n            for (const tweet of uniqueTweetCandidates) {\r\n                if (\r\n                    !this.client.lastCheckedTweetId ||\r\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\r\n                ) {\r\n                    // Generate the tweetId UUID the same way it's done in handleTweet\r\n                    const tweetId = stringToUuid(\r\n                        tweet.id + \"-\" + this.runtime.agentId\r\n                    );\r\n\r\n                    // Check if we've already processed this tweet\r\n                    const existingResponse =\r\n                        await this.runtime.messageManager.getMemoryById(\r\n                            tweetId\r\n                        );\r\n\r\n                    if (existingResponse) {\r\n                        elizaLogger.log(\r\n                            `Already responded to tweet ${tweet.id}, skipping`\r\n                        );\r\n                        continue;\r\n                    }\r\n                    elizaLogger.log(\"New Tweet found\", tweet.permanentUrl);\r\n\r\n                    const roomId = stringToUuid(\r\n                        tweet.conversationId + \"-\" + this.runtime.agentId\r\n                    );\r\n\r\n                    const userIdUUID =\r\n                        tweet.userId === this.client.profile.id\r\n                            ? this.runtime.agentId\r\n                            : stringToUuid(tweet.userId!);\r\n\r\n                    await this.runtime.ensureConnection(\r\n                        userIdUUID,\r\n                        roomId,\r\n                        tweet.username,\r\n                        tweet.name,\r\n                        \"twitter\"\r\n                    );\r\n\r\n                    const thread = await buildConversationThread(\r\n                        tweet,\r\n                        this.client\r\n                    );\r\n\r\n                    const message = {\r\n                        content: { text: tweet.text },\r\n                        agentId: this.runtime.agentId,\r\n                        userId: userIdUUID,\r\n                        roomId,\r\n                    };\r\n\r\n                    await this.handleTweet({\r\n                        tweet,\r\n                        message,\r\n                        thread,\r\n                    });\r\n\r\n                    // Update the last checked tweet ID after processing each tweet\r\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\r\n                }\r\n            }\r\n\r\n            // Save the latest checked tweet ID to the file\r\n            await this.client.cacheLatestCheckedTweetId();\r\n\r\n            elizaLogger.log(\"Finished checking Twitter interactions\");\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\r\n        }\r\n    }\r\n\r\n    private async handleTweet({\r\n        tweet,\r\n        message,\r\n        thread,\r\n    }: {\r\n        tweet: Tweet;\r\n        message: Memory;\r\n        thread: Tweet[];\r\n    }) {\r\n        if (tweet.userId === this.client.profile.id) {\r\n            // console.log(\"skipping tweet from bot itself\", tweet.id);\r\n            // Skip processing if the tweet is from the bot itself\r\n            return;\r\n        }\r\n\r\n        if (!message.content.text) {\r\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\r\n            return { text: \"\", action: \"IGNORE\" };\r\n        }\r\n\r\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\r\n        const formatTweet = (tweet: Tweet) => {\r\n            return `  ID: ${tweet.id}\r\n  From: ${tweet.name} (@${tweet.username})\r\n  Text: ${tweet.text}`;\r\n        };\r\n        const currentPost = formatTweet(tweet);\r\n\r\n        elizaLogger.debug(\"Thread: \", thread);\r\n        const formattedConversation = thread\r\n            .map(\r\n                (tweet) => `@${tweet.username} (${new Date(\r\n                    tweet.timestamp * 1000\r\n                ).toLocaleString(\"en-US\", {\r\n                    hour: \"2-digit\",\r\n                    minute: \"2-digit\",\r\n                    month: \"short\",\r\n                    day: \"numeric\",\r\n                })}):\r\n        ${tweet.text}`\r\n            )\r\n            .join(\"\\n\\n\");\r\n\r\n        elizaLogger.debug(\"formattedConversation: \", formattedConversation);\r\n\r\n        const imageDescriptionsArray = [];\r\n        try{\r\n            elizaLogger.debug('Getting images');\r\n            for (const photo of tweet.photos) {\r\n                elizaLogger.debug(photo.url);\r\n                const description = await this.runtime\r\n                    .getService<IImageDescriptionService>(\r\n                        ServiceType.IMAGE_DESCRIPTION\r\n                    )\r\n                    .describeImage(photo.url);\r\n                imageDescriptionsArray.push(description);\r\n            }\r\n        } catch (error) {\r\n    // Handle the error\r\n    elizaLogger.error(\"Error Occured during describing image: \", error);\r\n}\r\n\r\n\r\n\r\n\r\n        let state = await this.runtime.composeState(message, {\r\n            twitterClient: this.client.twitterClient,\r\n            twitterUserName: this.client.twitterConfig.TWITTER_USERNAME,\r\n            currentPost,\r\n            formattedConversation,\r\n            imageDescriptions: imageDescriptionsArray.length > 0\r\n            ? `\\nImages in Tweet:\\n${imageDescriptionsArray.map((desc, i) =>\r\n              `Image ${i + 1}: Title: ${desc.title}\\nDescription: ${desc.description}`).join(\"\\n\\n\")}`:\"\"\r\n        });\r\n\r\n        // check if the tweet exists, save if it doesn't\r\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\r\n        const tweetExists =\r\n            await this.runtime.messageManager.getMemoryById(tweetId);\r\n\r\n        if (!tweetExists) {\r\n            elizaLogger.log(\"tweet does not exist, saving\");\r\n            const userIdUUID = stringToUuid(tweet.userId as string);\r\n            const roomId = stringToUuid(tweet.conversationId);\r\n\r\n            const message = {\r\n                id: tweetId,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: tweet.text,\r\n                    url: tweet.permanentUrl,\r\n                    inReplyTo: tweet.inReplyToStatusId\r\n                        ? stringToUuid(\r\n                              tweet.inReplyToStatusId +\r\n                                  \"-\" +\r\n                                  this.runtime.agentId\r\n                          )\r\n                        : undefined,\r\n                },\r\n                userId: userIdUUID,\r\n                roomId,\r\n                createdAt: tweet.timestamp * 1000,\r\n            };\r\n            this.client.saveRequestMessage(message, state);\r\n        }\r\n\r\n        // get usernames into str\r\n        const validTargetUsersStr =\r\n            this.client.twitterConfig.TWITTER_TARGET_USERS.join(\",\");\r\n\r\n        const shouldRespondContext = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.twitterShouldRespondTemplate ||\r\n                this.runtime.character?.templates?.shouldRespondTemplate ||\r\n                twitterShouldRespondTemplate(validTargetUsersStr),\r\n        });\r\n\r\n        const shouldRespond = await generateShouldRespond({\r\n            runtime: this.runtime,\r\n            context: shouldRespondContext,\r\n            modelClass: ModelClass.MEDIUM,\r\n        });\r\n\r\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\r\n        if (shouldRespond !== \"RESPOND\") {\r\n            elizaLogger.log(\"Not responding to message\");\r\n            return { text: \"Response Decision:\", action: shouldRespond };\r\n        }\r\n\r\n        const context = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.twitterMessageHandlerTemplate ||\r\n                this.runtime.character?.templates?.messageHandlerTemplate ||\r\n                twitterMessageHandlerTemplate,\r\n        });\r\n        elizaLogger.debug(\"Interactions prompt:\\n\" + context);\r\n\r\n        const response = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        const removeQuotes = (str: string) =>\r\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\r\n\r\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\r\n\r\n        response.inReplyTo = stringId;\r\n\r\n        response.text = removeQuotes(response.text);\r\n\r\n        if (response.text) {\r\n            if (this.isDryRun) {\r\n                elizaLogger.info(\r\n                    `Dry run: Selected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`\r\n                );\r\n            } else {\r\n                try {\r\n                    const callback: HandlerCallback = async (\r\n                        response: Content\r\n                    ) => {\r\n                        const memories = await sendTweet(\r\n                            this.client,\r\n                            response,\r\n                            message.roomId,\r\n                            this.client.twitterConfig.TWITTER_USERNAME,\r\n                            tweet.id\r\n                        );\r\n                        return memories;\r\n                    };\r\n\r\n                    const responseMessages = await callback(response);\r\n\r\n                    state = (await this.runtime.updateRecentMessageState(\r\n                        state\r\n                    )) as State;\r\n\r\n                    for (const responseMessage of responseMessages) {\r\n                        if (\r\n                            responseMessage ===\r\n                            responseMessages[responseMessages.length - 1]\r\n                        ) {\r\n                            responseMessage.content.action = response.action;\r\n                        } else {\r\n                            responseMessage.content.action = \"CONTINUE\";\r\n                        }\r\n                        await this.runtime.messageManager.createMemory(\r\n                            responseMessage\r\n                        );\r\n                    }\r\n\r\n                    await this.runtime.processActions(\r\n                        message,\r\n                        responseMessages,\r\n                        state,\r\n                        callback\r\n                    );\r\n\r\n                    const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\r\n\r\n                    await this.runtime.cacheManager.set(\r\n                        `twitter/tweet_generation_${tweet.id}.txt`,\r\n                        responseInfo\r\n                    );\r\n                    await wait();\r\n                } catch (error) {\r\n                    elizaLogger.error(`Error sending response tweet: ${error}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async buildConversationThread(\r\n        tweet: Tweet,\r\n        maxReplies: number = 10\r\n    ): Promise<Tweet[]> {\r\n        const thread: Tweet[] = [];\r\n        const visited: Set<string> = new Set();\r\n\r\n        async function processThread(currentTweet: Tweet, depth: number = 0) {\r\n            elizaLogger.log(\"Processing tweet:\", {\r\n                id: currentTweet.id,\r\n                inReplyToStatusId: currentTweet.inReplyToStatusId,\r\n                depth: depth,\r\n            });\r\n\r\n            if (!currentTweet) {\r\n                elizaLogger.log(\"No current tweet found for thread building\");\r\n                return;\r\n            }\r\n\r\n            if (depth >= maxReplies) {\r\n                elizaLogger.log(\"Reached maximum reply depth\", depth);\r\n                return;\r\n            }\r\n\r\n            // Handle memory storage\r\n            const memory = await this.runtime.messageManager.getMemoryById(\r\n                stringToUuid(currentTweet.id + \"-\" + this.runtime.agentId)\r\n            );\r\n            if (!memory) {\r\n                const roomId = stringToUuid(\r\n                    currentTweet.conversationId + \"-\" + this.runtime.agentId\r\n                );\r\n                const userId = stringToUuid(currentTweet.userId);\r\n\r\n                await this.runtime.ensureConnection(\r\n                    userId,\r\n                    roomId,\r\n                    currentTweet.username,\r\n                    currentTweet.name,\r\n                    \"twitter\"\r\n                );\r\n\r\n                this.runtime.messageManager.createMemory({\r\n                    id: stringToUuid(\r\n                        currentTweet.id + \"-\" + this.runtime.agentId\r\n                    ),\r\n                    agentId: this.runtime.agentId,\r\n                    content: {\r\n                        text: currentTweet.text,\r\n                        source: \"twitter\",\r\n                        url: currentTweet.permanentUrl,\r\n                        inReplyTo: currentTweet.inReplyToStatusId\r\n                            ? stringToUuid(\r\n                                  currentTweet.inReplyToStatusId +\r\n                                      \"-\" +\r\n                                      this.runtime.agentId\r\n                              )\r\n                            : undefined,\r\n                    },\r\n                    createdAt: currentTweet.timestamp * 1000,\r\n                    roomId,\r\n                    userId:\r\n                        currentTweet.userId === this.twitterUserId\r\n                            ? this.runtime.agentId\r\n                            : stringToUuid(currentTweet.userId),\r\n                    embedding: getEmbeddingZeroVector(),\r\n                });\r\n            }\r\n\r\n            if (visited.has(currentTweet.id)) {\r\n                elizaLogger.log(\"Already visited tweet:\", currentTweet.id);\r\n                return;\r\n            }\r\n\r\n            visited.add(currentTweet.id);\r\n            thread.unshift(currentTweet);\r\n\r\n            elizaLogger.debug(\"Current thread state:\", {\r\n                length: thread.length,\r\n                currentDepth: depth,\r\n                tweetId: currentTweet.id,\r\n            });\r\n\r\n            if (currentTweet.inReplyToStatusId) {\r\n                elizaLogger.log(\r\n                    \"Fetching parent tweet:\",\r\n                    currentTweet.inReplyToStatusId\r\n                );\r\n                try {\r\n                    const parentTweet = await this.twitterClient.getTweet(\r\n                        currentTweet.inReplyToStatusId\r\n                    );\r\n\r\n                    if (parentTweet) {\r\n                        elizaLogger.log(\"Found parent tweet:\", {\r\n                            id: parentTweet.id,\r\n                            text: parentTweet.text?.slice(0, 50),\r\n                        });\r\n                        await processThread(parentTweet, depth + 1);\r\n                    } else {\r\n                        elizaLogger.log(\r\n                            \"No parent tweet found for:\",\r\n                            currentTweet.inReplyToStatusId\r\n                        );\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.log(\"Error fetching parent tweet:\", {\r\n                        tweetId: currentTweet.inReplyToStatusId,\r\n                        error,\r\n                    });\r\n                }\r\n            } else {\r\n                elizaLogger.log(\r\n                    \"Reached end of reply chain at:\",\r\n                    currentTweet.id\r\n                );\r\n            }\r\n        }\r\n\r\n        // Need to bind this context for the inner function\r\n        await processThread.bind(this)(tweet, 0);\r\n\r\n        elizaLogger.debug(\"Final thread built:\", {\r\n            totalTweets: thread.length,\r\n            tweetIds: thread.map((t) => ({\r\n                id: t.id,\r\n                text: t.text?.slice(0, 50),\r\n            })),\r\n        });\r\n\r\n        return thread;\r\n    }\r\n}","import { Tweet } from \"agent-twitter-client\";\r\nimport { getEmbeddingZeroVector } from \"@elizaos/core\";\r\nimport { Content, Memory, UUID } from \"@elizaos/core\";\r\nimport { stringToUuid } from \"@elizaos/core\";\r\nimport { ClientBase } from \"./base\";\r\nimport { elizaLogger } from \"@elizaos/core\";\r\nimport { Media } from \"@elizaos/core\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\n\r\nexport const wait = (minTime: number = 1000, maxTime: number = 3000) => {\r\n    const waitTime =\r\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\r\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\r\n};\r\n\r\nexport const isValidTweet = (tweet: Tweet): boolean => {\r\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\r\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\r\n    const atCount = (tweet.text?.match(/@/g) || []).length;\r\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\r\n    const totalCount = hashtagCount + atCount + dollarSignCount;\r\n\r\n    return (\r\n        hashtagCount <= 1 &&\r\n        atCount <= 2 &&\r\n        dollarSignCount <= 1 &&\r\n        totalCount <= 3\r\n    );\r\n};\r\n\r\nexport async function buildConversationThread(\r\n    tweet: Tweet,\r\n    client: ClientBase,\r\n    maxReplies: number = 10\r\n): Promise<Tweet[]> {\r\n    const thread: Tweet[] = [];\r\n    const visited: Set<string> = new Set();\r\n\r\n    async function processThread(currentTweet: Tweet, depth: number = 0) {\r\n        elizaLogger.debug(\"Processing tweet:\", {\r\n            id: currentTweet.id,\r\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\r\n            depth: depth,\r\n        });\r\n\r\n        if (!currentTweet) {\r\n            elizaLogger.debug(\"No current tweet found for thread building\");\r\n            return;\r\n        }\r\n\r\n        // Stop if we've reached our reply limit\r\n        if (depth >= maxReplies) {\r\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\r\n            return;\r\n        }\r\n\r\n        // Handle memory storage\r\n        const memory = await client.runtime.messageManager.getMemoryById(\r\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\r\n        );\r\n        if (!memory) {\r\n            const roomId = stringToUuid(\r\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\r\n            );\r\n            const userId = stringToUuid(currentTweet.userId);\r\n\r\n            await client.runtime.ensureConnection(\r\n                userId,\r\n                roomId,\r\n                currentTweet.username,\r\n                currentTweet.name,\r\n                \"twitter\"\r\n            );\r\n\r\n            await client.runtime.messageManager.createMemory({\r\n                id: stringToUuid(\r\n                    currentTweet.id + \"-\" + client.runtime.agentId\r\n                ),\r\n                agentId: client.runtime.agentId,\r\n                content: {\r\n                    text: currentTweet.text,\r\n                    source: \"twitter\",\r\n                    url: currentTweet.permanentUrl,\r\n                    inReplyTo: currentTweet.inReplyToStatusId\r\n                        ? stringToUuid(\r\n                              currentTweet.inReplyToStatusId +\r\n                                  \"-\" +\r\n                                  client.runtime.agentId\r\n                          )\r\n                        : undefined,\r\n                },\r\n                createdAt: currentTweet.timestamp * 1000,\r\n                roomId,\r\n                userId:\r\n                    currentTweet.userId === client.profile.id\r\n                        ? client.runtime.agentId\r\n                        : stringToUuid(currentTweet.userId),\r\n                embedding: getEmbeddingZeroVector(),\r\n            });\r\n        }\r\n\r\n        if (visited.has(currentTweet.id)) {\r\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\r\n            return;\r\n        }\r\n\r\n        visited.add(currentTweet.id);\r\n        thread.unshift(currentTweet);\r\n\r\n        elizaLogger.debug(\"Current thread state:\", {\r\n            length: thread.length,\r\n            currentDepth: depth,\r\n            tweetId: currentTweet.id,\r\n        });\r\n\r\n        // If there's a parent tweet, fetch and process it\r\n        if (currentTweet.inReplyToStatusId) {\r\n            elizaLogger.debug(\r\n                \"Fetching parent tweet:\",\r\n                currentTweet.inReplyToStatusId\r\n            );\r\n            try {\r\n                const parentTweet = await client.twitterClient.getTweet(\r\n                    currentTweet.inReplyToStatusId\r\n                );\r\n\r\n                if (parentTweet) {\r\n                    elizaLogger.debug(\"Found parent tweet:\", {\r\n                        id: parentTweet.id,\r\n                        text: parentTweet.text?.slice(0, 50),\r\n                    });\r\n                    await processThread(parentTweet, depth + 1);\r\n                } else {\r\n                    elizaLogger.debug(\r\n                        \"No parent tweet found for:\",\r\n                        currentTweet.inReplyToStatusId\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching parent tweet:\", {\r\n                    tweetId: currentTweet.inReplyToStatusId,\r\n                    error,\r\n                });\r\n            }\r\n        } else {\r\n            elizaLogger.debug(\r\n                \"Reached end of reply chain at:\",\r\n                currentTweet.id\r\n            );\r\n        }\r\n    }\r\n\r\n    await processThread(tweet, 0);\r\n\r\n    elizaLogger.debug(\"Final thread built:\", {\r\n        totalTweets: thread.length,\r\n        tweetIds: thread.map((t) => ({\r\n            id: t.id,\r\n            text: t.text?.slice(0, 50),\r\n        })),\r\n    });\r\n\r\n    return thread;\r\n}\r\n\r\nexport async function sendTweet(\r\n    client: ClientBase,\r\n    content: Content,\r\n    roomId: UUID,\r\n    twitterUsername: string,\r\n    inReplyTo: string\r\n): Promise<Memory[]> {\r\n    const maxTweetLength = client.twitterConfig.MAX_TWEET_LENGTH;\r\n    const isLongTweet = maxTweetLength > 280;\r\n\r\n    const tweetChunks = splitTweetContent(content.text, maxTweetLength);\r\n    const sentTweets: Tweet[] = [];\r\n    let previousTweetId = inReplyTo;\r\n\r\n    for (const chunk of tweetChunks) {\r\n        let mediaData: { data: Buffer; mediaType: string }[] | undefined;\r\n\r\n        if (content.attachments && content.attachments.length > 0) {\r\n            mediaData = await Promise.all(\r\n                content.attachments.map(async (attachment: Media) => {\r\n                    if (/^(http|https):\\/\\//.test(attachment.url)) {\r\n                        // Handle HTTP URLs\r\n                        const response = await fetch(attachment.url);\r\n                        if (!response.ok) {\r\n                            throw new Error(\r\n                                `Failed to fetch file: ${attachment.url}`\r\n                            );\r\n                        }\r\n                        const mediaBuffer = Buffer.from(\r\n                            await response.arrayBuffer()\r\n                        );\r\n                        const mediaType = attachment.contentType;\r\n                        return { data: mediaBuffer, mediaType };\r\n                    } else if (fs.existsSync(attachment.url)) {\r\n                        // Handle local file paths\r\n                        const mediaBuffer = await fs.promises.readFile(\r\n                            path.resolve(attachment.url)\r\n                        );\r\n                        const mediaType = attachment.contentType;\r\n                        return { data: mediaBuffer, mediaType };\r\n                    } else {\r\n                        throw new Error(\r\n                            `File not found: ${attachment.url}. Make sure the path is correct.`\r\n                        );\r\n                    }\r\n                })\r\n            );\r\n        }\r\n\r\n        const cleanChunk = deduplicateMentions(chunk.trim())\r\n\r\n        const result = await client.requestQueue.add(async () =>\r\n            isLongTweet\r\n                ? client.twitterClient.sendLongTweet(\r\n                      cleanChunk,\r\n                      previousTweetId,\r\n                      mediaData\r\n                  )\r\n                : client.twitterClient.sendTweet(\r\n                      cleanChunk,\r\n                      previousTweetId,\r\n                      mediaData\r\n                  )\r\n        );\r\n\r\n        const body = await result.json();\r\n        const tweetResult = isLongTweet\r\n            ? body?.data?.notetweet_create?.tweet_results?.result\r\n            : body?.data?.create_tweet?.tweet_results?.result;\r\n\r\n        // if we have a response\r\n        if (tweetResult) {\r\n            // Parse the response\r\n            const finalTweet: Tweet = {\r\n                id: tweetResult.rest_id,\r\n                text: tweetResult.legacy.full_text,\r\n                conversationId: tweetResult.legacy.conversation_id_str,\r\n                timestamp:\r\n                    new Date(tweetResult.legacy.created_at).getTime() / 1000,\r\n                userId: tweetResult.legacy.user_id_str,\r\n                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\r\n                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\r\n                hashtags: [],\r\n                mentions: [],\r\n                photos: [],\r\n                thread: [],\r\n                urls: [],\r\n                videos: [],\r\n            };\r\n            sentTweets.push(finalTweet);\r\n            previousTweetId = finalTweet.id;\r\n        } else {\r\n            elizaLogger.error(\"Error sending tweet chunk:\", {\r\n                chunk,\r\n                response: body,\r\n            });\r\n        }\r\n\r\n        // Wait a bit between tweets to avoid rate limiting issues\r\n        await wait(1000, 2000);\r\n    }\r\n\r\n    const memories: Memory[] = sentTweets.map((tweet) => ({\r\n        id: stringToUuid(tweet.id + \"-\" + client.runtime.agentId),\r\n        agentId: client.runtime.agentId,\r\n        userId: client.runtime.agentId,\r\n        content: {\r\n            text: tweet.text,\r\n            source: \"twitter\",\r\n            url: tweet.permanentUrl,\r\n            inReplyTo: tweet.inReplyToStatusId\r\n                ? stringToUuid(\r\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\r\n                  )\r\n                : undefined,\r\n        },\r\n        roomId,\r\n        embedding: getEmbeddingZeroVector(),\r\n        createdAt: tweet.timestamp * 1000,\r\n    }));\r\n\r\n    return memories;\r\n}\r\n\r\nfunction splitTweetContent(content: string, maxLength: number): string[] {\r\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\r\n    const tweets: string[] = [];\r\n    let currentTweet = \"\";\r\n\r\n    for (const paragraph of paragraphs) {\r\n        if (!paragraph) continue;\r\n\r\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\r\n            if (currentTweet) {\r\n                currentTweet += \"\\n\\n\" + paragraph;\r\n            } else {\r\n                currentTweet = paragraph;\r\n            }\r\n        } else {\r\n            if (currentTweet) {\r\n                tweets.push(currentTweet.trim());\r\n            }\r\n            if (paragraph.length <= maxLength) {\r\n                currentTweet = paragraph;\r\n            } else {\r\n                // Split long paragraph into smaller chunks\r\n                const chunks = splitParagraph(paragraph, maxLength);\r\n                tweets.push(...chunks.slice(0, -1));\r\n                currentTweet = chunks[chunks.length - 1];\r\n            }\r\n        }\r\n    }\r\n\r\n    if (currentTweet) {\r\n        tweets.push(currentTweet.trim());\r\n    }\r\n\r\n    return tweets;\r\n}\r\n\r\nfunction extractUrls(paragraph: string): {\r\n    textWithPlaceholders: string;\r\n    placeholderMap: Map<string, string>;\r\n} {\r\n    // replace https urls with placeholder\r\n    const urlRegex = /https?:\\/\\/[^\\s]+/g;\r\n    const placeholderMap = new Map<string, string>();\r\n\r\n    let urlIndex = 0;\r\n    const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {\r\n        // twitter url would be considered as 23 characters\r\n        // <<URL_CONSIDERER_23_1>> is also 23 characters\r\n        const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc\r\n        placeholderMap.set(placeholder, match);\r\n        urlIndex++;\r\n        return placeholder;\r\n    });\r\n\r\n    return { textWithPlaceholders, placeholderMap };\r\n}\r\n\r\nfunction splitSentencesAndWords(text: string, maxLength: number): string[] {\r\n    // Split by periods, question marks and exclamation marks\r\n    // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots\r\n    const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];\r\n    const chunks: string[] = [];\r\n    let currentChunk = \"\";\r\n\r\n    for (const sentence of sentences) {\r\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\r\n            if (currentChunk) {\r\n                currentChunk += \" \" + sentence;\r\n            } else {\r\n                currentChunk = sentence;\r\n            }\r\n        } else {\r\n            // Can't fit more, push currentChunk to results\r\n            if (currentChunk) {\r\n                chunks.push(currentChunk.trim());\r\n            }\r\n\r\n            // If current sentence itself is less than or equal to maxLength\r\n            if (sentence.length <= maxLength) {\r\n                currentChunk = sentence;\r\n            } else {\r\n                // Need to split sentence by spaces\r\n                const words = sentence.split(\" \");\r\n                currentChunk = \"\";\r\n                for (const word of words) {\r\n                    if (\r\n                        (currentChunk + \" \" + word).trim().length <= maxLength\r\n                    ) {\r\n                        if (currentChunk) {\r\n                            currentChunk += \" \" + word;\r\n                        } else {\r\n                            currentChunk = word;\r\n                        }\r\n                    } else {\r\n                        if (currentChunk) {\r\n                            chunks.push(currentChunk.trim());\r\n                        }\r\n                        currentChunk = word;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Handle remaining content\r\n    if (currentChunk) {\r\n        chunks.push(currentChunk.trim());\r\n    }\r\n\r\n    return chunks;\r\n}\r\n\r\nfunction deduplicateMentions(paragraph: string) {\r\n    // Regex to match mentions at the beginning of the string\r\n  const mentionRegex = /^@(\\w+)(?:\\s+@(\\w+))*(\\s+|$)/;\r\n\r\n  // Find all matches\r\n  const matches = paragraph.match(mentionRegex);\r\n\r\n  if (!matches) {\r\n    return paragraph; // If no matches, return the original string\r\n  }\r\n\r\n  // Extract mentions from the match groups\r\n  let mentions = matches.slice(0, 1)[0].trim().split(' ')\r\n\r\n  // Deduplicate mentions\r\n  mentions = [...new Set(mentions)];\r\n\r\n  // Reconstruct the string with deduplicated mentions\r\n  const uniqueMentionsString = mentions.join(' ');\r\n\r\n  // Find where the mentions end in the original string\r\n  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;\r\n\r\n  // Construct the result by combining unique mentions with the rest of the string\r\n  return uniqueMentionsString + ' ' + paragraph.slice(endOfMentions);\r\n}\r\n\r\nfunction restoreUrls(\r\n    chunks: string[],\r\n    placeholderMap: Map<string, string>\r\n): string[] {\r\n    return chunks.map((chunk) => {\r\n        // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex\r\n        return chunk.replace(/<<URL_CONSIDERER_23_(\\d+)>>/g, (match) => {\r\n            const original = placeholderMap.get(match);\r\n            return original || match; // Return placeholder if not found (theoretically won't happen)\r\n        });\r\n    });\r\n}\r\n\r\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\r\n    // 1) Extract URLs and replace with placeholders\r\n    const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);\r\n\r\n    // 2) Use first section's logic to split by sentences first, then do secondary split\r\n    const splittedChunks = splitSentencesAndWords(\r\n        textWithPlaceholders,\r\n        maxLength\r\n    );\r\n\r\n    // 3) Replace placeholders back to original URLs\r\n    const restoredChunks = restoreUrls(splittedChunks, placeholderMap);\r\n\r\n    return restoredChunks;\r\n}\r\n","import { Tweet } from \"agent-twitter-client\";\r\nimport {\r\n    composeContext,\r\n    generateText,\r\n    getEmbeddingZeroVector,\r\n    IAgentRuntime,\r\n    ModelClass,\r\n    stringToUuid,\r\n    TemplateType,\r\n    UUID,\r\n    truncateToCompleteSentence,\r\n} from \"@elizaos/core\";\r\nimport { elizaLogger } from \"@elizaos/core\";\r\nimport { ClientBase } from \"./base.ts\";\r\nimport { postActionResponseFooter } from \"@elizaos/core\";\r\nimport { generateTweetActions } from \"@elizaos/core\";\r\nimport { IImageDescriptionService, ServiceType } from \"@elizaos/core\";\r\nimport { buildConversationThread } from \"./utils.ts\";\r\nimport { twitterMessageHandlerTemplate } from \"./interactions.ts\";\r\nimport { DEFAULT_MAX_TWEET_LENGTH } from \"./environment.ts\";\r\nimport {\r\n    Client,\r\n    Events,\r\n    GatewayIntentBits,\r\n    TextChannel,\r\n    Partials,\r\n} from \"discord.js\";\r\nimport { State } from \"@elizaos/core\";\r\nimport { ActionResponse } from \"@elizaos/core\";\r\n\r\nconst MAX_TIMELINES_TO_FETCH = 15;\r\n\r\nconst twitterPostTemplate = `\r\n# Areas of Expertise\r\n{{knowledge}}\r\n\r\n# About {{agentName}} (@{{twitterUserName}}):\r\n{{bio}}\r\n{{lore}}\r\n{{topics}}\r\n\r\n{{providers}}\r\n\r\n{{characterPostExamples}}\r\n\r\n{{postDirections}}\r\n\r\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\r\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\r\nYour response should be 1, 2, or 3 sentences (choose the length at random).\r\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.`;\r\n\r\nexport const twitterActionTemplate =\r\n    `\r\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\r\n{{bio}}\r\n{{postDirections}}\r\n\r\nGuidelines:\r\n- ONLY engage with content that DIRECTLY relates to character's core interests\r\n- Direct mentions are priority IF they are on-topic\r\n- Skip ALL content that is:\r\n  - Off-topic or tangentially related\r\n  - From high-profile accounts unless explicitly relevant\r\n  - Generic/viral content without specific relevance\r\n  - Political/controversial unless central to character\r\n  - Promotional/marketing unless directly relevant\r\n\r\nActions (respond only with tags):\r\n[LIKE] - Perfect topic match AND aligns with character (9.8/10)\r\n[RETWEET] - Exceptional content that embodies character's expertise (9.5/10)\r\n[QUOTE] - Can add substantial domain expertise (9.5/10)\r\n[REPLY] - Can contribute meaningful, expert-level insight (9.5/10)\r\n\r\nTweet:\r\n{{currentTweet}}\r\n\r\n# Respond with qualifying action tags only. Default to NO action unless extremely confident of relevance.` +\r\n    postActionResponseFooter;\r\n\r\ninterface PendingTweet {\r\n    cleanedContent: string;\r\n    roomId: UUID;\r\n    newTweetContent: string;\r\n    discordMessageId: string;\r\n    channelId: string;\r\n    timestamp: number;\r\n}\r\n\r\ntype PendingTweetApprovalStatus = \"PENDING\" | \"APPROVED\" | \"REJECTED\";\r\n\r\nexport class TwitterPostClient {\r\n    client: ClientBase;\r\n    runtime: IAgentRuntime;\r\n    twitterUsername: string;\r\n    private isProcessing: boolean = false;\r\n    private lastProcessTime: number = 0;\r\n    private stopProcessingActions: boolean = false;\r\n    private isDryRun: boolean;\r\n    private discordClientForApproval: Client;\r\n    private approvalRequired: boolean = false;\r\n    private discordApprovalChannelId: string;\r\n    private approvalCheckInterval: number;\r\n\r\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.runtime = runtime;\r\n        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\r\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\r\n\r\n        // Log configuration on initialization\r\n        elizaLogger.log(\"Twitter Client Configuration:\");\r\n        elizaLogger.log(`- Username: ${this.twitterUsername}`);\r\n        elizaLogger.log(\r\n            `- Dry Run Mode: ${this.isDryRun ? \"enabled\" : \"disabled\"}`\r\n        );\r\n        elizaLogger.log(\r\n            `- Post Interval: ${this.client.twitterConfig.POST_INTERVAL_MIN}-${this.client.twitterConfig.POST_INTERVAL_MAX} minutes`\r\n        );\r\n        elizaLogger.log(\r\n            `- Action Processing: ${this.client.twitterConfig.ENABLE_ACTION_PROCESSING ? \"enabled\" : \"disabled\"}`\r\n        );\r\n        elizaLogger.log(\r\n            `- Action Interval: ${this.client.twitterConfig.ACTION_INTERVAL} minutes`\r\n        );\r\n        elizaLogger.log(\r\n            `- Post Immediately: ${this.client.twitterConfig.POST_IMMEDIATELY ? \"enabled\" : \"disabled\"}`\r\n        );\r\n        elizaLogger.log(\r\n            `- Search Enabled: ${this.client.twitterConfig.TWITTER_SEARCH_ENABLE ? \"enabled\" : \"disabled\"}`\r\n        );\r\n\r\n        const targetUsers = this.client.twitterConfig.TWITTER_TARGET_USERS;\r\n        if (targetUsers) {\r\n            elizaLogger.log(`- Target Users: ${targetUsers}`);\r\n        }\r\n\r\n        if (this.isDryRun) {\r\n            elizaLogger.log(\r\n                \"Twitter client initialized in dry run mode - no actual tweets should be posted\"\r\n            );\r\n        }\r\n\r\n        // Initialize Discord webhook\r\n        const approvalRequired: boolean =\r\n            this.runtime\r\n                .getSetting(\"TWITTER_APPROVAL_ENABLED\")\r\n                ?.toLocaleLowerCase() === \"true\";\r\n        if (approvalRequired) {\r\n            const discordToken = this.runtime.getSetting(\r\n                \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\"\r\n            );\r\n            const approvalChannelId = this.runtime.getSetting(\r\n                \"TWITTER_APPROVAL_DISCORD_CHANNEL_ID\"\r\n            );\r\n\r\n            const APPROVAL_CHECK_INTERVAL =\r\n                parseInt(\r\n                    this.runtime.getSetting(\"TWITTER_APPROVAL_CHECK_INTERVAL\")\r\n                ) || 5 * 60 * 1000; // 5 minutes\r\n\r\n            this.approvalCheckInterval = APPROVAL_CHECK_INTERVAL;\r\n\r\n            if (!discordToken || !approvalChannelId) {\r\n                throw new Error(\r\n                    \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN and TWITTER_APPROVAL_DISCORD_CHANNEL_ID are required for approval workflow\"\r\n                );\r\n            }\r\n\r\n            this.approvalRequired = true;\r\n            this.discordApprovalChannelId = approvalChannelId;\r\n\r\n            // Set up Discord client event handlers\r\n            this.setupDiscordClient();\r\n        }\r\n    }\r\n\r\n    private setupDiscordClient() {\r\n        this.discordClientForApproval = new Client({\r\n            intents: [\r\n                GatewayIntentBits.Guilds,\r\n                GatewayIntentBits.GuildMessages,\r\n                GatewayIntentBits.MessageContent,\r\n                GatewayIntentBits.GuildMessageReactions,\r\n            ],\r\n            partials: [Partials.Channel, Partials.Message, Partials.Reaction],\r\n        });\r\n        this.discordClientForApproval.once(\r\n            Events.ClientReady,\r\n            (readyClient) => {\r\n                elizaLogger.log(\r\n                    `Discord bot is ready as ${readyClient.user.tag}!`\r\n                );\r\n\r\n                // Generate invite link with required permissions\r\n                const invite = `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user.id}&permissions=274877991936&scope=bot`;\r\n                // 274877991936 includes permissions for:\r\n                // - Send Messages\r\n                // - Read Messages/View Channels\r\n                // - Read Message History\r\n\r\n                elizaLogger.log(\r\n                    `Use this link to properly invite the Twitter Post Approval Discord bot: ${invite}`\r\n                );\r\n            }\r\n        );\r\n        // Login to Discord\r\n        this.discordClientForApproval.login(\r\n            this.runtime.getSetting(\"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\")\r\n        );\r\n    }\r\n\r\n    async start() {\r\n        if (!this.client.profile) {\r\n            await this.client.init();\r\n        }\r\n\r\n        const generateNewTweetLoop = async () => {\r\n            // Check for pending tweets first\r\n            if (this.approvalRequired) await this.handlePendingTweet();\r\n\r\n            const lastPost = await this.runtime.cacheManager.get<{\r\n                timestamp: number;\r\n            }>(\"twitter/\" + this.twitterUsername + \"/lastPost\");\r\n\r\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\r\n            const minMinutes = this.client.twitterConfig.POST_INTERVAL_MIN;\r\n            const maxMinutes = this.client.twitterConfig.POST_INTERVAL_MAX;\r\n            const randomMinutes =\r\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\r\n                minMinutes;\r\n            const delay = randomMinutes * 60 * 1000;\r\n\r\n            if (Date.now() > lastPostTimestamp + delay) {\r\n                await this.generateNewTweet();\r\n            }\r\n\r\n            setTimeout(() => {\r\n                generateNewTweetLoop(); // Set up next iteration\r\n            }, delay);\r\n\r\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\r\n        };\r\n\r\n        const processActionsLoop = async () => {\r\n            const actionInterval = this.client.twitterConfig.ACTION_INTERVAL; // Defaults to 5 minutes\r\n\r\n            while (!this.stopProcessingActions) {\r\n                try {\r\n                    const results = await this.processTweetActions();\r\n                    if (results) {\r\n                        elizaLogger.log(`Processed ${results.length} tweets`);\r\n                        elizaLogger.log(\r\n                            `Next action processing scheduled in ${actionInterval} minutes`\r\n                        );\r\n                        // Wait for the full interval before next processing\r\n                        await new Promise(\r\n                            (resolve) =>\r\n                                setTimeout(resolve, actionInterval * 60 * 1000) // now in minutes\r\n                        );\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.error(\r\n                        \"Error in action processing loop:\",\r\n                        error\r\n                    );\r\n                    // Add exponential backoff on error\r\n                    await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this.client.twitterConfig.POST_IMMEDIATELY) {\r\n            await this.generateNewTweet();\r\n        }\r\n\r\n        // Only start tweet generation loop if not in dry run mode\r\n        generateNewTweetLoop();\r\n        elizaLogger.log(\"Tweet generation loop started\");\r\n\r\n        if (this.client.twitterConfig.ENABLE_ACTION_PROCESSING) {\r\n            processActionsLoop().catch((error) => {\r\n                elizaLogger.error(\r\n                    \"Fatal error in process actions loop:\",\r\n                    error\r\n                );\r\n            });\r\n        }\r\n\r\n        // Start the pending tweet check loop if enabled\r\n        if (this.approvalRequired) this.runPendingTweetCheckLoop();\r\n    }\r\n\r\n    private runPendingTweetCheckLoop() {\r\n        setInterval(async () => {\r\n            await this.handlePendingTweet();\r\n        }, this.approvalCheckInterval);\r\n    }\r\n\r\n    createTweetObject(\r\n        tweetResult: any,\r\n        client: any,\r\n        twitterUsername: string\r\n    ): Tweet {\r\n        return {\r\n            id: tweetResult.rest_id,\r\n            name: client.profile.screenName,\r\n            username: client.profile.username,\r\n            text: tweetResult.legacy.full_text,\r\n            conversationId: tweetResult.legacy.conversation_id_str,\r\n            createdAt: tweetResult.legacy.created_at,\r\n            timestamp: new Date(tweetResult.legacy.created_at).getTime(),\r\n            userId: client.profile.id,\r\n            inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\r\n            permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\r\n            hashtags: [],\r\n            mentions: [],\r\n            photos: [],\r\n            thread: [],\r\n            urls: [],\r\n            videos: [],\r\n        } as Tweet;\r\n    }\r\n\r\n    async processAndCacheTweet(\r\n        runtime: IAgentRuntime,\r\n        client: ClientBase,\r\n        tweet: Tweet,\r\n        roomId: UUID,\r\n        newTweetContent: string\r\n    ) {\r\n        // Cache the last post details\r\n        await runtime.cacheManager.set(\r\n            `twitter/${client.profile.username}/lastPost`,\r\n            {\r\n                id: tweet.id,\r\n                timestamp: Date.now(),\r\n            }\r\n        );\r\n\r\n        // Cache the tweet\r\n        await client.cacheTweet(tweet);\r\n\r\n        // Log the posted tweet\r\n        elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\r\n\r\n        // Ensure the room and participant exist\r\n        await runtime.ensureRoomExists(roomId);\r\n        await runtime.ensureParticipantInRoom(runtime.agentId, roomId);\r\n\r\n        // Create a memory for the tweet\r\n        await runtime.messageManager.createMemory({\r\n            id: stringToUuid(tweet.id + \"-\" + runtime.agentId),\r\n            userId: runtime.agentId,\r\n            agentId: runtime.agentId,\r\n            content: {\r\n                text: newTweetContent.trim(),\r\n                url: tweet.permanentUrl,\r\n                source: \"twitter\",\r\n            },\r\n            roomId,\r\n            embedding: getEmbeddingZeroVector(),\r\n            createdAt: tweet.timestamp,\r\n        });\r\n    }\r\n\r\n    async handleNoteTweet(\r\n        client: ClientBase,\r\n        content: string,\r\n        tweetId?: string\r\n    ) {\r\n        try {\r\n            const noteTweetResult = await client.requestQueue.add(\r\n                async () =>\r\n                    await client.twitterClient.sendNoteTweet(content, tweetId)\r\n            );\r\n\r\n            if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {\r\n                // Note Tweet failed due to authorization. Falling back to standard Tweet.\r\n                const truncateContent = truncateToCompleteSentence(\r\n                    content,\r\n                    this.client.twitterConfig.MAX_TWEET_LENGTH\r\n                );\r\n                return await this.sendStandardTweet(\r\n                    client,\r\n                    truncateContent,\r\n                    tweetId\r\n                );\r\n            } else {\r\n                return noteTweetResult.data.notetweet_create.tweet_results\r\n                    .result;\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Note Tweet failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    async sendStandardTweet(\r\n        client: ClientBase,\r\n        content: string,\r\n        tweetId?: string\r\n    ) {\r\n        try {\r\n            const standardTweetResult = await client.requestQueue.add(\r\n                async () =>\r\n                    await client.twitterClient.sendTweet(content, tweetId)\r\n            );\r\n            const body = await standardTweetResult.json();\r\n            if (!body?.data?.create_tweet?.tweet_results?.result) {\r\n                console.error(\"Error sending tweet; Bad response:\", body);\r\n                return;\r\n            }\r\n            return body.data.create_tweet.tweet_results.result;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error sending standard Tweet:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async postTweet(\r\n        runtime: IAgentRuntime,\r\n        client: ClientBase,\r\n        cleanedContent: string,\r\n        roomId: UUID,\r\n        newTweetContent: string,\r\n        twitterUsername: string\r\n    ) {\r\n        try {\r\n            elizaLogger.log(`Posting new tweet:\\n`);\r\n\r\n            let result;\r\n\r\n            if (cleanedContent.length > DEFAULT_MAX_TWEET_LENGTH) {\r\n                result = await this.handleNoteTweet(client, cleanedContent);\r\n            } else {\r\n                result = await this.sendStandardTweet(client, cleanedContent);\r\n            }\r\n\r\n            const tweet = this.createTweetObject(\r\n                result,\r\n                client,\r\n                twitterUsername\r\n            );\r\n\r\n            await this.processAndCacheTweet(\r\n                runtime,\r\n                client,\r\n                tweet,\r\n                roomId,\r\n                newTweetContent\r\n            );\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error sending tweet:\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates and posts a new tweet. If isDryRun is true, only logs what would have been posted.\r\n     */\r\n    async generateNewTweet() {\r\n        elizaLogger.log(\"Generating new tweet\");\r\n\r\n        try {\r\n            const roomId = stringToUuid(\r\n                \"twitter_generate_room-\" + this.client.profile.username\r\n            );\r\n            await this.runtime.ensureUserExists(\r\n                this.runtime.agentId,\r\n                this.client.profile.username,\r\n                this.runtime.character.name,\r\n                \"twitter\"\r\n            );\r\n\r\n            const topics = this.runtime.character.topics.join(\", \");\r\n\r\n            const state = await this.runtime.composeState(\r\n                {\r\n                    userId: this.runtime.agentId,\r\n                    roomId: roomId,\r\n                    agentId: this.runtime.agentId,\r\n                    content: {\r\n                        text: topics || \"\",\r\n                        action: \"TWEET\",\r\n                    },\r\n                },\r\n                {\r\n                    twitterUserName: this.client.profile.username,\r\n                }\r\n            );\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.twitterPostTemplate ||\r\n                    twitterPostTemplate,\r\n            });\r\n\r\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\r\n\r\n            const newTweetContent = await generateText({\r\n                runtime: this.runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            // First attempt to clean content\r\n            let cleanedContent = \"\";\r\n\r\n            // Try parsing as JSON first\r\n            try {\r\n                const parsedResponse = JSON.parse(newTweetContent);\r\n                if (parsedResponse.text) {\r\n                    cleanedContent = parsedResponse.text;\r\n                } else if (typeof parsedResponse === \"string\") {\r\n                    cleanedContent = parsedResponse;\r\n                }\r\n            } catch (error) {\r\n                error.linted = true; // make linter happy since catch needs a variable\r\n                // If not JSON, clean the raw content\r\n                cleanedContent = newTweetContent\r\n                    .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\r\n                    .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\r\n                    .replace(/\\\\\"/g, '\"') // Unescape quotes\r\n                    .replace(/\\\\n/g, \"\\n\\n\") // Unescape newlines, ensures double spaces\r\n                    .trim();\r\n            }\r\n\r\n            if (!cleanedContent) {\r\n                elizaLogger.error(\r\n                    \"Failed to extract valid content from response:\",\r\n                    {\r\n                        rawResponse: newTweetContent,\r\n                        attempted: \"JSON parsing\",\r\n                    }\r\n                );\r\n                return;\r\n            }\r\n\r\n            // Truncate the content to the maximum tweet length specified in the environment settings, ensuring the truncation respects sentence boundaries.\r\n            const maxTweetLength = this.client.twitterConfig.MAX_TWEET_LENGTH;\r\n            if (maxTweetLength) {\r\n                cleanedContent = truncateToCompleteSentence(\r\n                    cleanedContent,\r\n                    maxTweetLength\r\n                );\r\n            }\r\n\r\n            const removeQuotes = (str: string) =>\r\n                str.replace(/^['\"](.*)['\"]$/, \"$1\");\r\n\r\n            const fixNewLines = (str: string) => str.replaceAll(/\\\\n/g, \"\\n\\n\"); //ensures double spaces\r\n\r\n            // Final cleaning\r\n            cleanedContent = removeQuotes(fixNewLines(cleanedContent));\r\n\r\n            if (this.isDryRun) {\r\n                elizaLogger.info(\r\n                    `Dry run: would have posted tweet: ${cleanedContent}`\r\n                );\r\n                return;\r\n            }\r\n\r\n            try {\r\n                if (this.approvalRequired) {\r\n                    // Send for approval instead of posting directly\r\n                    elizaLogger.log(\r\n                        `Sending Tweet For Approval:\\n ${cleanedContent}`\r\n                    );\r\n                    await this.sendForApproval(\r\n                        cleanedContent,\r\n                        roomId,\r\n                        newTweetContent\r\n                    );\r\n                    elizaLogger.log(\"Tweet sent for approval\");\r\n                } else {\r\n                    elizaLogger.log(`Posting new tweet:\\n ${cleanedContent}`);\r\n                    this.postTweet(\r\n                        this.runtime,\r\n                        this.client,\r\n                        cleanedContent,\r\n                        roomId,\r\n                        newTweetContent,\r\n                        this.twitterUsername\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error sending tweet:\", error);\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error generating new tweet:\", error);\r\n        }\r\n    }\r\n\r\n    private async generateTweetContent(\r\n        tweetState: any,\r\n        options?: {\r\n            template?: TemplateType;\r\n            context?: string;\r\n        }\r\n    ): Promise<string> {\r\n        const context = composeContext({\r\n            state: tweetState,\r\n            template:\r\n                options?.template ||\r\n                this.runtime.character.templates?.twitterPostTemplate ||\r\n                twitterPostTemplate,\r\n        });\r\n\r\n        const response = await generateText({\r\n            runtime: this.runtime,\r\n            context: options?.context || context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        elizaLogger.debug(\"generate tweet content response:\\n\" + response);\r\n\r\n        // First clean up any markdown and newlines\r\n        const cleanedResponse = response\r\n            .replace(/```json\\s*/g, \"\") // Remove ```json\r\n            .replace(/```\\s*/g, \"\") // Remove any remaining ```\r\n            .replaceAll(/\\\\n/g, \"\\n\")\r\n            .trim();\r\n\r\n        // Try to parse as JSON first\r\n        try {\r\n            const jsonResponse = JSON.parse(cleanedResponse);\r\n            if (jsonResponse.text) {\r\n                return this.trimTweetLength(jsonResponse.text);\r\n            }\r\n            if (typeof jsonResponse === \"object\") {\r\n                const possibleContent =\r\n                    jsonResponse.content ||\r\n                    jsonResponse.message ||\r\n                    jsonResponse.response;\r\n                if (possibleContent) {\r\n                    return this.trimTweetLength(possibleContent);\r\n                }\r\n            }\r\n        } catch (error) {\r\n            error.linted = true; // make linter happy since catch needs a variable\r\n\r\n            // If JSON parsing fails, treat as plain text\r\n            elizaLogger.debug(\"Response is not JSON, treating as plain text\");\r\n        }\r\n\r\n        // If not JSON or no valid content found, clean the raw text\r\n        return this.trimTweetLength(cleanedResponse);\r\n    }\r\n\r\n    // Helper method to ensure tweet length compliance\r\n    private trimTweetLength(text: string, maxLength: number = 280): string {\r\n        if (text.length <= maxLength) return text;\r\n\r\n        // Try to cut at last sentence\r\n        const lastSentence = text.slice(0, maxLength).lastIndexOf(\".\");\r\n        if (lastSentence > 0) {\r\n            return text.slice(0, lastSentence + 1).trim();\r\n        }\r\n\r\n        // Fallback to word boundary\r\n        return (\r\n            text.slice(0, text.lastIndexOf(\" \", maxLength - 3)).trim() + \"...\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Processes tweet actions (likes, retweets, quotes, replies). If isDryRun is true,\r\n     * only simulates and logs actions without making API calls.\r\n     */\r\n    private async processTweetActions() {\r\n        if (this.isProcessing) {\r\n            elizaLogger.log(\"Already processing tweet actions, skipping\");\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            this.isProcessing = true;\r\n            this.lastProcessTime = Date.now();\r\n\r\n            elizaLogger.log(\"Processing tweet actions\");\r\n\r\n            await this.runtime.ensureUserExists(\r\n                this.runtime.agentId,\r\n                this.twitterUsername,\r\n                this.runtime.character.name,\r\n                \"twitter\"\r\n            );\r\n\r\n            const timelines = await this.client.fetchTimelineForActions(\r\n                MAX_TIMELINES_TO_FETCH\r\n            );\r\n            const maxActionsProcessing =\r\n                this.client.twitterConfig.MAX_ACTIONS_PROCESSING;\r\n            const processedTimelines = [];\r\n\r\n            for (const tweet of timelines) {\r\n                try {\r\n                    // Skip if we've already processed this tweet\r\n                    const memory =\r\n                        await this.runtime.messageManager.getMemoryById(\r\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                        );\r\n                    if (memory) {\r\n                        elizaLogger.log(\r\n                            `Already processed tweet ID: ${tweet.id}`\r\n                        );\r\n                        continue;\r\n                    }\r\n\r\n                    const roomId = stringToUuid(\r\n                        tweet.conversationId + \"-\" + this.runtime.agentId\r\n                    );\r\n\r\n                    const tweetState = await this.runtime.composeState(\r\n                        {\r\n                            userId: this.runtime.agentId,\r\n                            roomId,\r\n                            agentId: this.runtime.agentId,\r\n                            content: { text: \"\", action: \"\" },\r\n                        },\r\n                        {\r\n                            twitterUserName: this.twitterUsername,\r\n                            currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\r\n                        }\r\n                    );\r\n\r\n                    const actionContext = composeContext({\r\n                        state: tweetState,\r\n                        template:\r\n                            this.runtime.character.templates\r\n                                ?.twitterActionTemplate ||\r\n                            twitterActionTemplate,\r\n                    });\r\n\r\n                    const actionResponse = await generateTweetActions({\r\n                        runtime: this.runtime,\r\n                        context: actionContext,\r\n                        modelClass: ModelClass.SMALL,\r\n                    });\r\n\r\n                    if (!actionResponse) {\r\n                        elizaLogger.log(\r\n                            `No valid actions generated for tweet ${tweet.id}`\r\n                        );\r\n                        continue;\r\n                    }\r\n                    processedTimelines.push({\r\n                        tweet: tweet,\r\n                        actionResponse: actionResponse,\r\n                        tweetState: tweetState,\r\n                        roomId: roomId,\r\n                    });\r\n                } catch (error) {\r\n                    elizaLogger.error(\r\n                        `Error processing tweet ${tweet.id}:`,\r\n                        error\r\n                    );\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const sortProcessedTimeline = (arr: typeof processedTimelines) => {\r\n                return arr.sort((a, b) => {\r\n                    // Count the number of true values in the actionResponse object\r\n                    const countTrue = (obj: typeof a.actionResponse) =>\r\n                        Object.values(obj).filter(Boolean).length;\r\n\r\n                    const countA = countTrue(a.actionResponse);\r\n                    const countB = countTrue(b.actionResponse);\r\n\r\n                    // Primary sort by number of true values\r\n                    if (countA !== countB) {\r\n                        return countB - countA;\r\n                    }\r\n\r\n                    // Secondary sort by the \"like\" property\r\n                    if (a.actionResponse.like !== b.actionResponse.like) {\r\n                        return a.actionResponse.like ? -1 : 1;\r\n                    }\r\n\r\n                    // Tertiary sort keeps the remaining objects with equal weight\r\n                    return 0;\r\n                });\r\n            };\r\n            // Sort the timeline based on the action decision score,\r\n            // then slice the results according to the environment variable to limit the number of actions per cycle.\r\n            const sortedTimelines = sortProcessedTimeline(\r\n                processedTimelines\r\n            ).slice(0, maxActionsProcessing);\r\n\r\n            return this.processTimelineActions(sortedTimelines); // Return results array to indicate completion\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in processTweetActions:\", error);\r\n            throw error;\r\n        } finally {\r\n            this.isProcessing = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes a list of timelines by executing the corresponding tweet actions.\r\n     * Each timeline includes the tweet, action response, tweet state, and room context.\r\n     * Results are returned for tracking completed actions.\r\n     *\r\n     * @param timelines - Array of objects containing tweet details, action responses, and state information.\r\n     * @returns A promise that resolves to an array of results with details of executed actions.\r\n     */\r\n    private async processTimelineActions(\r\n        timelines: {\r\n            tweet: Tweet;\r\n            actionResponse: ActionResponse;\r\n            tweetState: State;\r\n            roomId: UUID;\r\n        }[]\r\n    ): Promise<\r\n        {\r\n            tweetId: string;\r\n            actionResponse: ActionResponse;\r\n            executedActions: string[];\r\n        }[]\r\n    > {\r\n        const results = [];\r\n        for (const timeline of timelines) {\r\n            const { actionResponse, tweetState, roomId, tweet } = timeline;\r\n            try {\r\n                const executedActions: string[] = [];\r\n                // Execute actions\r\n                if (actionResponse.like) {\r\n                    if (this.isDryRun) {\r\n                        elizaLogger.info(\r\n                            `Dry run: would have liked tweet ${tweet.id}`\r\n                        );\r\n                        executedActions.push(\"like (dry run)\");\r\n                    } else {\r\n                        try {\r\n                            await this.client.twitterClient.likeTweet(tweet.id);\r\n                            executedActions.push(\"like\");\r\n                            elizaLogger.log(`Liked tweet ${tweet.id}`);\r\n                        } catch (error) {\r\n                            elizaLogger.error(\r\n                                `Error liking tweet ${tweet.id}:`,\r\n                                error\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (actionResponse.retweet) {\r\n                    if (this.isDryRun) {\r\n                        elizaLogger.info(\r\n                            `Dry run: would have retweeted tweet ${tweet.id}`\r\n                        );\r\n                        executedActions.push(\"retweet (dry run)\");\r\n                    } else {\r\n                        try {\r\n                            await this.client.twitterClient.retweet(tweet.id);\r\n                            executedActions.push(\"retweet\");\r\n                            elizaLogger.log(`Retweeted tweet ${tweet.id}`);\r\n                        } catch (error) {\r\n                            elizaLogger.error(\r\n                                `Error retweeting tweet ${tweet.id}:`,\r\n                                error\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (actionResponse.quote) {\r\n                    try {\r\n                        // Build conversation thread for context\r\n                        const thread = await buildConversationThread(\r\n                            tweet,\r\n                            this.client\r\n                        );\r\n                        const formattedConversation = thread\r\n                            .map(\r\n                                (t) =>\r\n                                    `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\r\n                            )\r\n                            .join(\"\\n\\n\");\r\n\r\n                        // Generate image descriptions if present\r\n                        const imageDescriptions = [];\r\n                        if (tweet.photos?.length > 0) {\r\n                            elizaLogger.log(\r\n                                \"Processing images in tweet for context\"\r\n                            );\r\n                            for (const photo of tweet.photos) {\r\n                                const description = await this.runtime\r\n                                    .getService<IImageDescriptionService>(\r\n                                        ServiceType.IMAGE_DESCRIPTION\r\n                                    )\r\n                                    .describeImage(photo.url);\r\n                                imageDescriptions.push(description);\r\n                            }\r\n                        }\r\n\r\n                        // Handle quoted tweet if present\r\n                        let quotedContent = \"\";\r\n                        if (tweet.quotedStatusId) {\r\n                            try {\r\n                                const quotedTweet =\r\n                                    await this.client.twitterClient.getTweet(\r\n                                        tweet.quotedStatusId\r\n                                    );\r\n                                if (quotedTweet) {\r\n                                    quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\r\n                                }\r\n                            } catch (error) {\r\n                                elizaLogger.error(\r\n                                    \"Error fetching quoted tweet:\",\r\n                                    error\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        // Compose rich state with all context\r\n                        const enrichedState = await this.runtime.composeState(\r\n                            {\r\n                                userId: this.runtime.agentId,\r\n                                roomId: stringToUuid(\r\n                                    tweet.conversationId +\r\n                                        \"-\" +\r\n                                        this.runtime.agentId\r\n                                ),\r\n                                agentId: this.runtime.agentId,\r\n                                content: {\r\n                                    text: tweet.text,\r\n                                    action: \"QUOTE\",\r\n                                },\r\n                            },\r\n                            {\r\n                                twitterUserName: this.twitterUsername,\r\n                                currentPost: `From @${tweet.username}: ${tweet.text}`,\r\n                                formattedConversation,\r\n                                imageContext:\r\n                                    imageDescriptions.length > 0\r\n                                        ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\r\n                                        : \"\",\r\n                                quotedContent,\r\n                            }\r\n                        );\r\n\r\n                        const quoteContent = await this.generateTweetContent(\r\n                            enrichedState,\r\n                            {\r\n                                template:\r\n                                    this.runtime.character.templates\r\n                                        ?.twitterMessageHandlerTemplate ||\r\n                                    twitterMessageHandlerTemplate,\r\n                            }\r\n                        );\r\n\r\n                        if (!quoteContent) {\r\n                            elizaLogger.error(\r\n                                \"Failed to generate valid quote tweet content\"\r\n                            );\r\n                            return;\r\n                        }\r\n\r\n                        elizaLogger.log(\r\n                            \"Generated quote tweet content:\",\r\n                            quoteContent\r\n                        );\r\n                        // Check for dry run mode\r\n                        if (this.isDryRun) {\r\n                            elizaLogger.info(\r\n                                `Dry run: A quote tweet for tweet ID ${tweet.id} would have been posted with the following content: \"${quoteContent}\".`\r\n                            );\r\n                            executedActions.push(\"quote (dry run)\");\r\n                        } else {\r\n                            // Send the tweet through request queue\r\n                            const result = await this.client.requestQueue.add(\r\n                                async () =>\r\n                                    await this.client.twitterClient.sendQuoteTweet(\r\n                                        quoteContent,\r\n                                        tweet.id\r\n                                    )\r\n                            );\r\n\r\n                            const body = await result.json();\r\n\r\n                            if (\r\n                                body?.data?.create_tweet?.tweet_results?.result\r\n                            ) {\r\n                                elizaLogger.log(\r\n                                    \"Successfully posted quote tweet\"\r\n                                );\r\n                                executedActions.push(\"quote\");\r\n\r\n                                // Cache generation context for debugging\r\n                                await this.runtime.cacheManager.set(\r\n                                    `twitter/quote_generation_${tweet.id}.txt`,\r\n                                    `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`\r\n                                );\r\n                            } else {\r\n                                elizaLogger.error(\r\n                                    \"Quote tweet creation failed:\",\r\n                                    body\r\n                                );\r\n                            }\r\n                        }\r\n                    } catch (error) {\r\n                        elizaLogger.error(\r\n                            \"Error in quote tweet generation:\",\r\n                            error\r\n                        );\r\n                    }\r\n                }\r\n\r\n                if (actionResponse.reply) {\r\n                    try {\r\n                        await this.handleTextOnlyReply(\r\n                            tweet,\r\n                            tweetState,\r\n                            executedActions\r\n                        );\r\n                    } catch (error) {\r\n                        elizaLogger.error(\r\n                            `Error replying to tweet ${tweet.id}:`,\r\n                            error\r\n                        );\r\n                    }\r\n                }\r\n\r\n                // Add these checks before creating memory\r\n                await this.runtime.ensureRoomExists(roomId);\r\n                await this.runtime.ensureUserExists(\r\n                    stringToUuid(tweet.userId),\r\n                    tweet.username,\r\n                    tweet.name,\r\n                    \"twitter\"\r\n                );\r\n                await this.runtime.ensureParticipantInRoom(\r\n                    this.runtime.agentId,\r\n                    roomId\r\n                );\r\n\r\n                if (!this.isDryRun) {\r\n                    // Then create the memory\r\n                    await this.runtime.messageManager.createMemory({\r\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\r\n                        userId: stringToUuid(tweet.userId),\r\n                        content: {\r\n                            text: tweet.text,\r\n                            url: tweet.permanentUrl,\r\n                            source: \"twitter\",\r\n                            action: executedActions.join(\",\"),\r\n                        },\r\n                        agentId: this.runtime.agentId,\r\n                        roomId,\r\n                        embedding: getEmbeddingZeroVector(),\r\n                        createdAt: tweet.timestamp * 1000,\r\n                    });\r\n                }\r\n\r\n                results.push({\r\n                    tweetId: tweet.id,\r\n                    actionResponse: actionResponse,\r\n                    executedActions,\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Handles text-only replies to tweets. If isDryRun is true, only logs what would\r\n     * have been replied without making API calls.\r\n     */\r\n    private async handleTextOnlyReply(\r\n        tweet: Tweet,\r\n        tweetState: any,\r\n        executedActions: string[]\r\n    ) {\r\n        try {\r\n            // Build conversation thread for context\r\n            const thread = await buildConversationThread(tweet, this.client);\r\n            const formattedConversation = thread\r\n                .map(\r\n                    (t) =>\r\n                        `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\r\n                )\r\n                .join(\"\\n\\n\");\r\n\r\n            // Generate image descriptions if present\r\n            const imageDescriptions = [];\r\n            if (tweet.photos?.length > 0) {\r\n                elizaLogger.log(\"Processing images in tweet for context\");\r\n                for (const photo of tweet.photos) {\r\n                    const description = await this.runtime\r\n                        .getService<IImageDescriptionService>(\r\n                            ServiceType.IMAGE_DESCRIPTION\r\n                        )\r\n                        .describeImage(photo.url);\r\n                    imageDescriptions.push(description);\r\n                }\r\n            }\r\n\r\n            // Handle quoted tweet if present\r\n            let quotedContent = \"\";\r\n            if (tweet.quotedStatusId) {\r\n                try {\r\n                    const quotedTweet =\r\n                        await this.client.twitterClient.getTweet(\r\n                            tweet.quotedStatusId\r\n                        );\r\n                    if (quotedTweet) {\r\n                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.error(\"Error fetching quoted tweet:\", error);\r\n                }\r\n            }\r\n\r\n            // Compose rich state with all context\r\n            const enrichedState = await this.runtime.composeState(\r\n                {\r\n                    userId: this.runtime.agentId,\r\n                    roomId: stringToUuid(\r\n                        tweet.conversationId + \"-\" + this.runtime.agentId\r\n                    ),\r\n                    agentId: this.runtime.agentId,\r\n                    content: { text: tweet.text, action: \"\" },\r\n                },\r\n                {\r\n                    twitterUserName: this.twitterUsername,\r\n                    currentPost: `From @${tweet.username}: ${tweet.text}`,\r\n                    formattedConversation,\r\n                    imageContext:\r\n                        imageDescriptions.length > 0\r\n                            ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\r\n                            : \"\",\r\n                    quotedContent,\r\n                }\r\n            );\r\n\r\n            // Generate and clean the reply content\r\n            const replyText = await this.generateTweetContent(enrichedState, {\r\n                template:\r\n                    this.runtime.character.templates\r\n                        ?.twitterMessageHandlerTemplate ||\r\n                    twitterMessageHandlerTemplate,\r\n            });\r\n\r\n            if (!replyText) {\r\n                elizaLogger.error(\"Failed to generate valid reply content\");\r\n                return;\r\n            }\r\n\r\n            if (this.isDryRun) {\r\n                elizaLogger.info(\r\n                    `Dry run: reply to tweet ${tweet.id} would have been: ${replyText}`\r\n                );\r\n                executedActions.push(\"reply (dry run)\");\r\n                return;\r\n            }\r\n\r\n            elizaLogger.debug(\"Final reply text to be sent:\", replyText);\r\n\r\n            let result;\r\n\r\n            if (replyText.length > DEFAULT_MAX_TWEET_LENGTH) {\r\n                result = await this.handleNoteTweet(\r\n                    this.client,\r\n                    replyText,\r\n                    tweet.id\r\n                );\r\n            } else {\r\n                result = await this.sendStandardTweet(\r\n                    this.client,\r\n                    replyText,\r\n                    tweet.id\r\n                );\r\n            }\r\n\r\n            if (result) {\r\n                elizaLogger.log(\"Successfully posted reply tweet\");\r\n                executedActions.push(\"reply\");\r\n\r\n                // Cache generation context for debugging\r\n                await this.runtime.cacheManager.set(\r\n                    `twitter/reply_generation_${tweet.id}.txt`,\r\n                    `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`\r\n                );\r\n            } else {\r\n                elizaLogger.error(\"Tweet reply creation failed\");\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in handleTextOnlyReply:\", error);\r\n        }\r\n    }\r\n\r\n    async stop() {\r\n        this.stopProcessingActions = true;\r\n    }\r\n\r\n    private async sendForApproval(\r\n        cleanedContent: string,\r\n        roomId: UUID,\r\n        newTweetContent: string\r\n    ): Promise<string | null> {\r\n        try {\r\n            const embed = {\r\n                title: \"New Tweet Pending Approval\",\r\n                description: cleanedContent,\r\n                fields: [\r\n                    {\r\n                        name: \"Character\",\r\n                        value: this.client.profile.username,\r\n                        inline: true,\r\n                    },\r\n                    {\r\n                        name: \"Length\",\r\n                        value: cleanedContent.length.toString(),\r\n                        inline: true,\r\n                    },\r\n                ],\r\n                footer: {\r\n                    text: \"Reply with '👍' to post or '❌' to discard, This will automatically expire and remove after 24 hours if no response received\",\r\n                },\r\n                timestamp: new Date().toISOString(),\r\n            };\r\n\r\n            const channel = await this.discordClientForApproval.channels.fetch(\r\n                this.discordApprovalChannelId\r\n            );\r\n\r\n            if (!channel || !(channel instanceof TextChannel)) {\r\n                throw new Error(\"Invalid approval channel\");\r\n            }\r\n\r\n            const message = await channel.send({ embeds: [embed] });\r\n\r\n            // Store the pending tweet\r\n            const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\r\n            const currentPendingTweets =\r\n                (await this.runtime.cacheManager.get<PendingTweet[]>(\r\n                    pendingTweetsKey\r\n                )) || [];\r\n            // Add new pending tweet\r\n            currentPendingTweets.push({\r\n                cleanedContent,\r\n                roomId,\r\n                newTweetContent,\r\n                discordMessageId: message.id,\r\n                channelId: this.discordApprovalChannelId,\r\n                timestamp: Date.now(),\r\n            });\r\n\r\n            // Store updated array\r\n            await this.runtime.cacheManager.set(\r\n                pendingTweetsKey,\r\n                currentPendingTweets\r\n            );\r\n\r\n            return message.id;\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Error Sending Twitter Post Approval Request:\",\r\n                error\r\n            );\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private async checkApprovalStatus(\r\n        discordMessageId: string\r\n    ): Promise<PendingTweetApprovalStatus> {\r\n        try {\r\n            // Fetch message and its replies from Discord\r\n            const channel = await this.discordClientForApproval.channels.fetch(\r\n                this.discordApprovalChannelId\r\n            );\r\n\r\n            elizaLogger.log(`channel ${JSON.stringify(channel)}`);\r\n\r\n            if (!(channel instanceof TextChannel)) {\r\n                elizaLogger.error(\"Invalid approval channel\");\r\n                return \"PENDING\";\r\n            }\r\n\r\n            // Fetch the original message and its replies\r\n            const message = await channel.messages.fetch(discordMessageId);\r\n\r\n            // Look for thumbs up reaction ('👍')\r\n            const thumbsUpReaction = message.reactions.cache.find(\r\n                (reaction) => reaction.emoji.name === \"👍\"\r\n            );\r\n\r\n            // Look for reject reaction ('❌')\r\n            const rejectReaction = message.reactions.cache.find(\r\n                (reaction) => reaction.emoji.name === \"❌\"\r\n            );\r\n\r\n            // Check if the reaction exists and has reactions\r\n            if (rejectReaction) {\r\n                const count = rejectReaction.count;\r\n                if (count > 0) {\r\n                    return \"REJECTED\";\r\n                }\r\n            }\r\n\r\n            // Check if the reaction exists and has reactions\r\n            if (thumbsUpReaction) {\r\n                // You might want to check for specific users who can approve\r\n                // For now, we'll return true if anyone used thumbs up\r\n                const count = thumbsUpReaction.count;\r\n                if (count > 0) {\r\n                    return \"APPROVED\";\r\n                }\r\n            }\r\n\r\n            return \"PENDING\";\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error checking approval status:\", error);\r\n            return \"PENDING\";\r\n        }\r\n    }\r\n\r\n    private async cleanupPendingTweet(discordMessageId: string) {\r\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\r\n        const currentPendingTweets =\r\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\r\n                pendingTweetsKey\r\n            )) || [];\r\n\r\n        // Remove the specific tweet\r\n        const updatedPendingTweets = currentPendingTweets.filter(\r\n            (tweet) => tweet.discordMessageId !== discordMessageId\r\n        );\r\n\r\n        if (updatedPendingTweets.length === 0) {\r\n            await this.runtime.cacheManager.delete(pendingTweetsKey);\r\n        } else {\r\n            await this.runtime.cacheManager.set(\r\n                pendingTweetsKey,\r\n                updatedPendingTweets\r\n            );\r\n        }\r\n    }\r\n\r\n    private async handlePendingTweet() {\r\n        elizaLogger.log(\"Checking Pending Tweets...\");\r\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\r\n        const pendingTweets =\r\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\r\n                pendingTweetsKey\r\n            )) || [];\r\n\r\n        for (const pendingTweet of pendingTweets) {\r\n            // Check if tweet is older than 24 hours\r\n            const isExpired =\r\n                Date.now() - pendingTweet.timestamp > 24 * 60 * 60 * 1000;\r\n\r\n            if (isExpired) {\r\n                elizaLogger.log(\"Pending tweet expired, cleaning up\");\r\n\r\n                // Notify on Discord about expiration\r\n                try {\r\n                    const channel =\r\n                        await this.discordClientForApproval.channels.fetch(\r\n                            pendingTweet.channelId\r\n                        );\r\n                    if (channel instanceof TextChannel) {\r\n                        const originalMessage = await channel.messages.fetch(\r\n                            pendingTweet.discordMessageId\r\n                        );\r\n                        await originalMessage.reply(\r\n                            \"This tweet approval request has expired (24h timeout).\"\r\n                        );\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.error(\r\n                        \"Error sending expiration notification:\",\r\n                        error\r\n                    );\r\n                }\r\n\r\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\r\n                return;\r\n            }\r\n\r\n            // Check approval status\r\n            elizaLogger.log(\"Checking approval status...\");\r\n            const approvalStatus: PendingTweetApprovalStatus =\r\n                await this.checkApprovalStatus(pendingTweet.discordMessageId);\r\n\r\n            if (approvalStatus === \"APPROVED\") {\r\n                elizaLogger.log(\"Tweet Approved, Posting\");\r\n                await this.postTweet(\r\n                    this.runtime,\r\n                    this.client,\r\n                    pendingTweet.cleanedContent,\r\n                    pendingTweet.roomId,\r\n                    pendingTweet.newTweetContent,\r\n                    this.twitterUsername\r\n                );\r\n\r\n                // Notify on Discord about posting\r\n                try {\r\n                    const channel =\r\n                        await this.discordClientForApproval.channels.fetch(\r\n                            pendingTweet.channelId\r\n                        );\r\n                    if (channel instanceof TextChannel) {\r\n                        const originalMessage = await channel.messages.fetch(\r\n                            pendingTweet.discordMessageId\r\n                        );\r\n                        await originalMessage.reply(\r\n                            \"Tweet has been posted successfully! ✅\"\r\n                        );\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.error(\r\n                        \"Error sending post notification:\",\r\n                        error\r\n                    );\r\n                }\r\n\r\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\r\n            } else if (approvalStatus === \"REJECTED\") {\r\n                elizaLogger.log(\"Tweet Rejected, Cleaning Up\");\r\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\r\n                // Notify about Rejection of Tweet\r\n                try {\r\n                    const channel =\r\n                        await this.discordClientForApproval.channels.fetch(\r\n                            pendingTweet.channelId\r\n                        );\r\n                    if (channel instanceof TextChannel) {\r\n                        const originalMessage = await channel.messages.fetch(\r\n                            pendingTweet.discordMessageId\r\n                        );\r\n                        await originalMessage.reply(\r\n                            \"Tweet has been rejected! ❌\"\r\n                        );\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.error(\r\n                        \"Error sending rejection notification:\",\r\n                        error\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { SearchMode } from \"agent-twitter-client\";\r\nimport { composeContext, elizaLogger } from \"@elizaos/core\";\r\nimport { generateMessageResponse, generateText } from \"@elizaos/core\";\r\nimport { messageCompletionFooter } from \"@elizaos/core\";\r\nimport {\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    IImageDescriptionService,\r\n    ModelClass,\r\n    ServiceType,\r\n    State,\r\n} from \"@elizaos/core\";\r\nimport { stringToUuid } from \"@elizaos/core\";\r\nimport { ClientBase } from \"./base\";\r\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\r\n\r\nconst twitterSearchTemplate =\r\n    `{{timeline}}\r\n\r\n{{providers}}\r\n\r\nRecent interactions between {{agentName}} and other users:\r\n{{recentPostInteractions}}\r\n\r\nAbout {{agentName}} (@{{twitterUserName}}):\r\n{{bio}}\r\n{{lore}}\r\n{{topics}}\r\n\r\n{{postDirections}}\r\n\r\n{{recentPosts}}\r\n\r\n# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.\r\n{{currentPost}}\r\n\r\nIMPORTANT: Your response CANNOT be longer than 20 words.\r\nAim for 1-2 short sentences maximum. Be concise and direct.\r\n\r\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.\r\n\r\n` + messageCompletionFooter;\r\n\r\nexport class TwitterSearchClient {\r\n    client: ClientBase;\r\n    runtime: IAgentRuntime;\r\n    twitterUsername: string;\r\n    private respondedTweets: Set<string> = new Set();\r\n\r\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.runtime = runtime;\r\n        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\r\n    }\r\n\r\n    async start() {\r\n        this.engageWithSearchTermsLoop();\r\n    }\r\n\r\n    private engageWithSearchTermsLoop() {\r\n        this.engageWithSearchTerms().then();\r\n        const randomMinutes = Math.floor(Math.random() * (120 - 60 + 1)) + 60;\r\n        elizaLogger.log(\r\n            `Next twitter search scheduled in ${randomMinutes} minutes`\r\n        );\r\n        setTimeout(\r\n            () => this.engageWithSearchTermsLoop(),\r\n            randomMinutes * 60 * 1000\r\n        );\r\n    }\r\n\r\n    private async engageWithSearchTerms() {\r\n        elizaLogger.log(\"Engaging with search terms\");\r\n        try {\r\n            const searchTerm = [...this.runtime.character.topics][\r\n                Math.floor(Math.random() * this.runtime.character.topics.length)\r\n            ];\r\n\r\n            elizaLogger.log(\"Fetching search tweets\");\r\n            // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue\r\n            await new Promise((resolve) => setTimeout(resolve, 5000));\r\n            const recentTweets = await this.client.fetchSearchTweets(\r\n                searchTerm,\r\n                20,\r\n                SearchMode.Top\r\n            );\r\n            elizaLogger.log(\"Search tweets fetched\");\r\n\r\n            const homeTimeline = await this.client.fetchHomeTimeline(50);\r\n\r\n            await this.client.cacheTimeline(homeTimeline);\r\n\r\n            const formattedHomeTimeline =\r\n                `# ${this.runtime.character.name}'s Home Timeline\\n\\n` +\r\n                homeTimeline\r\n                    .map((tweet) => {\r\n                        return `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\\nText: ${tweet.text}\\n---\\n`;\r\n                    })\r\n                    .join(\"\\n\");\r\n\r\n            // randomly slice .tweets down to 20\r\n            const slicedTweets = recentTweets.tweets\r\n                .sort(() => Math.random() - 0.5)\r\n                .slice(0, 20);\r\n\r\n            if (slicedTweets.length === 0) {\r\n                elizaLogger.log(\r\n                    \"No valid tweets found for the search term\",\r\n                    searchTerm\r\n                );\r\n                return;\r\n            }\r\n\r\n            const prompt = `\r\n  Here are some tweets related to the search term \"${searchTerm}\":\r\n\r\n  ${[...slicedTweets, ...homeTimeline]\r\n      .filter((tweet) => {\r\n          // ignore tweets where any of the thread tweets contain a tweet by the bot\r\n          const thread = tweet.thread;\r\n          const botTweet = thread.find(\r\n              (t) => t.username === this.twitterUsername\r\n          );\r\n          return !botTweet;\r\n      })\r\n      .map(\r\n          (tweet) => `\r\n    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\r\n    From: ${tweet.name} (@${tweet.username})\r\n    Text: ${tweet.text}\r\n  `\r\n      )\r\n      .join(\"\\n\")}\r\n\r\n  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.\r\n  Notes:\r\n    - Respond to English tweets only\r\n    - Respond to tweets that don't have a lot of hashtags, links, URLs or images\r\n    - Respond to tweets that are not retweets\r\n    - Respond to tweets where there is an easy exchange of ideas to have with the user\r\n    - ONLY respond with the ID of the tweet`;\r\n\r\n            const mostInterestingTweetResponse = await generateText({\r\n                runtime: this.runtime,\r\n                context: prompt,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            const tweetId = mostInterestingTweetResponse.trim();\r\n            const selectedTweet = slicedTweets.find(\r\n                (tweet) =>\r\n                    tweet.id.toString().includes(tweetId) ||\r\n                    tweetId.includes(tweet.id.toString())\r\n            );\r\n\r\n            if (!selectedTweet) {\r\n                elizaLogger.warn(\"No matching tweet found for the selected ID\");\r\n                elizaLogger.log(\"Selected tweet ID:\", tweetId);\r\n                return;\r\n            }\r\n\r\n            elizaLogger.log(\"Selected tweet to reply to:\", selectedTweet?.text);\r\n\r\n            if (selectedTweet.username === this.twitterUsername) {\r\n                elizaLogger.log(\"Skipping tweet from bot itself\");\r\n                return;\r\n            }\r\n\r\n            const conversationId = selectedTweet.conversationId;\r\n            const roomId = stringToUuid(\r\n                conversationId + \"-\" + this.runtime.agentId\r\n            );\r\n\r\n            const userIdUUID = stringToUuid(selectedTweet.userId as string);\r\n\r\n            await this.runtime.ensureConnection(\r\n                userIdUUID,\r\n                roomId,\r\n                selectedTweet.username,\r\n                selectedTweet.name,\r\n                \"twitter\"\r\n            );\r\n\r\n            // crawl additional conversation tweets, if there are any\r\n            await buildConversationThread(selectedTweet, this.client);\r\n\r\n            const message = {\r\n                id: stringToUuid(selectedTweet.id + \"-\" + this.runtime.agentId),\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: selectedTweet.text,\r\n                    url: selectedTweet.permanentUrl,\r\n                    inReplyTo: selectedTweet.inReplyToStatusId\r\n                        ? stringToUuid(\r\n                              selectedTweet.inReplyToStatusId +\r\n                                  \"-\" +\r\n                                  this.runtime.agentId\r\n                          )\r\n                        : undefined,\r\n                },\r\n                userId: userIdUUID,\r\n                roomId,\r\n                // Timestamps are in seconds, but we need them in milliseconds\r\n                createdAt: selectedTweet.timestamp * 1000,\r\n            };\r\n\r\n            if (!message.content.text) {\r\n                elizaLogger.warn(\"Returning: No response text found\");\r\n                return;\r\n            }\r\n\r\n            // Fetch replies and retweets\r\n            const replies = selectedTweet.thread;\r\n            const replyContext = replies\r\n                .filter((reply) => reply.username !== this.twitterUsername)\r\n                .map((reply) => `@${reply.username}: ${reply.text}`)\r\n                .join(\"\\n\");\r\n\r\n            let tweetBackground = \"\";\r\n            if (selectedTweet.isRetweet) {\r\n                const originalTweet = await this.client.requestQueue.add(() =>\r\n                    this.client.twitterClient.getTweet(selectedTweet.id)\r\n                );\r\n                tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;\r\n            }\r\n\r\n            // Generate image descriptions using GPT-4 vision API\r\n            const imageDescriptions = [];\r\n            for (const photo of selectedTweet.photos) {\r\n                const description = await this.runtime\r\n                    .getService<IImageDescriptionService>(\r\n                        ServiceType.IMAGE_DESCRIPTION\r\n                    )\r\n                    .describeImage(photo.url);\r\n                imageDescriptions.push(description);\r\n            }\r\n\r\n            let state = await this.runtime.composeState(message, {\r\n                twitterClient: this.client.twitterClient,\r\n                twitterUserName: this.twitterUsername,\r\n                timeline: formattedHomeTimeline,\r\n                tweetContext: `${tweetBackground}\r\n\r\n  Original Post:\r\n  By @${selectedTweet.username}\r\n  ${selectedTweet.text}${replyContext.length > 0 && `\\nReplies to original post:\\n${replyContext}`}\r\n  ${`Original post text: ${selectedTweet.text}`}\r\n  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(\", \")}\\n` : \"\"}${imageDescriptions.length > 0 ? `\\nImages in Post (Described): ${imageDescriptions.join(\", \")}\\n` : \"\"}\r\n  `,\r\n            });\r\n\r\n            await this.client.saveRequestMessage(message, state as State);\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.twitterSearchTemplate ||\r\n                    twitterSearchTemplate,\r\n            });\r\n\r\n            const responseContent = await generateMessageResponse({\r\n                runtime: this.runtime,\r\n                context,\r\n                modelClass: ModelClass.LARGE,\r\n            });\r\n\r\n            responseContent.inReplyTo = message.id;\r\n\r\n            const response = responseContent;\r\n\r\n            if (!response.text) {\r\n                elizaLogger.warn(\"Returning: No response text found\");\r\n                return;\r\n            }\r\n\r\n            elizaLogger.log(\r\n                `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`\r\n            );\r\n            try {\r\n                const callback: HandlerCallback = async (response: Content) => {\r\n                    const memories = await sendTweet(\r\n                        this.client,\r\n                        response,\r\n                        message.roomId,\r\n                        this.twitterUsername,\r\n                        tweetId\r\n                    );\r\n                    return memories;\r\n                };\r\n\r\n                const responseMessages = await callback(responseContent);\r\n\r\n                state = await this.runtime.updateRecentMessageState(state);\r\n\r\n                for (const responseMessage of responseMessages) {\r\n                    await this.runtime.messageManager.createMemory(\r\n                        responseMessage,\r\n                        false\r\n                    );\r\n                }\r\n\r\n                state = await this.runtime.updateRecentMessageState(state);\r\n\r\n                await this.runtime.evaluate(message, state);\r\n\r\n                await this.runtime.processActions(\r\n                    message,\r\n                    responseMessages,\r\n                    state,\r\n                    callback\r\n                );\r\n\r\n                this.respondedTweets.add(selectedTweet.id);\r\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\\nAgent's Output:\\n${response.text}`;\r\n\r\n                await this.runtime.cacheManager.set(\r\n                    `twitter/tweet_generation_${selectedTweet.id}.txt`,\r\n                    responseInfo\r\n                );\r\n\r\n                await wait();\r\n            } catch (error) {\r\n                console.error(`Error sending response post: ${error}`);\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error engaging with search terms:\", error);\r\n        }\r\n    }\r\n}\r\n","import {\r\n    elizaLogger,\r\n    IAgentRuntime,\r\n    composeContext,\r\n    generateText,\r\n    ModelClass,\r\n    ServiceType,\r\n    ITranscriptionService,\r\n} from \"@elizaos/core\";\r\nimport { ClientBase } from \"./base\";\r\nimport {\r\n    Scraper,\r\n    Space,\r\n    SpaceConfig,\r\n    RecordToDiskPlugin,\r\n    IdleMonitorPlugin,\r\n    SpeakerRequest,\r\n} from \"agent-twitter-client\";\r\nimport { SttTtsPlugin } from \"./plugins/SttTtsSpacesPlugin.ts\";\r\n\r\ninterface SpaceDecisionOptions {\r\n    maxSpeakers?: number;\r\n    topics?: string[];\r\n    typicalDurationMinutes?: number;\r\n    idleKickTimeoutMs?: number;\r\n    minIntervalBetweenSpacesMinutes?: number;\r\n    businessHoursOnly?: boolean;\r\n    randomChance?: number;\r\n    enableIdleMonitor?: boolean;\r\n    enableSttTts?: boolean;\r\n    enableRecording?: boolean;\r\n    voiceId?: string;\r\n    sttLanguage?: string;\r\n    gptModel?: string;\r\n    systemPrompt?: string;\r\n    speakerMaxDurationMs?: number;\r\n}\r\n\r\ninterface CurrentSpeakerState {\r\n    userId: string;\r\n    sessionUUID: string;\r\n    username: string;\r\n    startTime: number;\r\n}\r\n\r\n/**\r\n * Generate short filler text via GPT\r\n */\r\nasync function generateFiller(\r\n    runtime: IAgentRuntime,\r\n    fillerType: string\r\n): Promise<string> {\r\n    try {\r\n        const context = composeContext({\r\n            state: { fillerType },\r\n            template: `\r\n# INSTRUCTIONS:\r\nYou are generating a short filler message for a Twitter Space. The filler type is \"{{fillerType}}\".\r\nKeep it brief, friendly, and relevant. No more than two sentences.\r\nOnly return the text, no additional formatting.\r\n\r\n---\r\n`,\r\n        });\r\n        const output = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        return output.trim();\r\n    } catch (err) {\r\n        elizaLogger.error(\"[generateFiller] Error generating filler:\", err);\r\n        return \"\";\r\n    }\r\n}\r\n\r\n/**\r\n * Speak a filler message if STT/TTS plugin is available. Sleep a bit after TTS to avoid cutoff.\r\n */\r\nasync function speakFiller(\r\n    runtime: IAgentRuntime,\r\n    sttTtsPlugin: SttTtsPlugin | undefined,\r\n    fillerType: string,\r\n    sleepAfterMs = 3000\r\n): Promise<void> {\r\n    if (!sttTtsPlugin) return;\r\n    const text = await generateFiller(runtime, fillerType);\r\n    if (!text) return;\r\n\r\n    elizaLogger.log(`[Space] Filler (${fillerType}) => ${text}`);\r\n    await sttTtsPlugin.speakText(text);\r\n\r\n    if (sleepAfterMs > 0) {\r\n        await new Promise((res) => setTimeout(res, sleepAfterMs));\r\n    }\r\n}\r\n\r\n/**\r\n * Generate topic suggestions via GPT if no topics are configured\r\n */\r\nasync function generateTopicsIfEmpty(\r\n    runtime: IAgentRuntime\r\n): Promise<string[]> {\r\n    try {\r\n        const context = composeContext({\r\n            state: {},\r\n            template: `\r\n# INSTRUCTIONS:\r\nPlease generate 5 short topic ideas for a Twitter Space about technology or random interesting subjects.\r\nReturn them as a comma-separated list, no additional formatting or numbering.\r\n\r\nExample:\r\n\"AI Advances, Futuristic Gadgets, Space Exploration, Quantum Computing, Digital Ethics\"\r\n---\r\n`,\r\n        });\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        const topics = response\r\n            .split(\",\")\r\n            .map((t) => t.trim())\r\n            .filter(Boolean);\r\n        return topics.length ? topics : [\"Random Tech Chat\", \"AI Thoughts\"];\r\n    } catch (err) {\r\n        elizaLogger.error(\"[generateTopicsIfEmpty] GPT error =>\", err);\r\n        return [\"Random Tech Chat\", \"AI Thoughts\"];\r\n    }\r\n}\r\n\r\n/**\r\n * Main class: manage a Twitter Space with N speakers max, speaker queue, filler messages, etc.\r\n */\r\nexport class TwitterSpaceClient {\r\n    private client: ClientBase;\r\n    private scraper: Scraper;\r\n    private isSpaceRunning = false;\r\n    private currentSpace?: Space;\r\n    private spaceId?: string;\r\n    private startedAt?: number;\r\n    private checkInterval?: NodeJS.Timeout;\r\n    private lastSpaceEndedAt?: number;\r\n    private sttTtsPlugin?: SttTtsPlugin;\r\n\r\n    /**\r\n     * We now store an array of active speakers, not just 1\r\n     */\r\n    private activeSpeakers: CurrentSpeakerState[] = [];\r\n    private speakerQueue: SpeakerRequest[] = [];\r\n\r\n    private decisionOptions: SpaceDecisionOptions;\r\n\r\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.scraper = client.twitterClient;\r\n\r\n        const charSpaces = runtime.character.twitterSpaces || {};\r\n        this.decisionOptions = {\r\n            maxSpeakers: charSpaces.maxSpeakers ?? 1,\r\n            topics: charSpaces.topics ?? [],\r\n            typicalDurationMinutes: charSpaces.typicalDurationMinutes ?? 30,\r\n            idleKickTimeoutMs: charSpaces.idleKickTimeoutMs ?? 5 * 60_000,\r\n            minIntervalBetweenSpacesMinutes:\r\n                charSpaces.minIntervalBetweenSpacesMinutes ?? 60,\r\n            businessHoursOnly: charSpaces.businessHoursOnly ?? false,\r\n            randomChance: charSpaces.randomChance ?? 0.3,\r\n            enableIdleMonitor: charSpaces.enableIdleMonitor !== false,\r\n            enableSttTts: charSpaces.enableSttTts !== false,\r\n            enableRecording: charSpaces.enableRecording !== false,\r\n            voiceId:\r\n                charSpaces.voiceId ||\r\n                runtime.character.settings.voice.model ||\r\n                \"Xb7hH8MSUJpSbSDYk0k2\",\r\n            sttLanguage: charSpaces.sttLanguage || \"en\",\r\n            gptModel: charSpaces.gptModel,\r\n            systemPrompt: charSpaces.systemPrompt,\r\n            speakerMaxDurationMs: charSpaces.speakerMaxDurationMs ?? 4 * 60_000,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Periodic check to launch or manage space\r\n     */\r\n    public async startPeriodicSpaceCheck() {\r\n        elizaLogger.log(\"[Space] Starting periodic check routine...\");\r\n\r\n        // For instance:\r\n        const intervalMsWhenIdle = 5 * 60_000; // 5 minutes if no Space is running\r\n        const intervalMsWhenRunning = 5_000; // 5 seconds if a Space IS running\r\n\r\n        const routine = async () => {\r\n            try {\r\n                if (!this.isSpaceRunning) {\r\n                    // Space not running => check if we should launch\r\n                    const launch = await this.shouldLaunchSpace();\r\n                    if (launch) {\r\n                        const config = await this.generateSpaceConfig();\r\n                        await this.startSpace(config);\r\n                    }\r\n                    // Plan next iteration with a slower pace\r\n                    this.checkInterval = setTimeout(\r\n                        routine,\r\n                        this.isSpaceRunning\r\n                            ? intervalMsWhenRunning\r\n                            : intervalMsWhenIdle\r\n                    );\r\n                } else {\r\n                    // Space is running => manage it more frequently\r\n                    await this.manageCurrentSpace();\r\n                    // Plan next iteration with a faster pace\r\n                    this.checkInterval = setTimeout(\r\n                        routine,\r\n                        intervalMsWhenRunning\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\"[Space] Error in routine =>\", error);\r\n                // In case of error, still schedule next iteration\r\n                this.checkInterval = setTimeout(routine, intervalMsWhenIdle);\r\n            }\r\n        };\r\n\r\n        routine();\r\n    }\r\n\r\n    stopPeriodicCheck() {\r\n        if (this.checkInterval) {\r\n            clearTimeout(this.checkInterval);\r\n            this.checkInterval = undefined;\r\n        }\r\n    }\r\n\r\n    private async shouldLaunchSpace(): Promise<boolean> {\r\n        // Random chance\r\n        const r = Math.random();\r\n        if (r > (this.decisionOptions.randomChance ?? 0.3)) {\r\n            elizaLogger.log(\"[Space] Random check => skip launching\");\r\n            return false;\r\n        }\r\n        // Business hours\r\n        if (this.decisionOptions.businessHoursOnly) {\r\n            const hour = new Date().getUTCHours();\r\n            if (hour < 9 || hour >= 17) {\r\n                elizaLogger.log(\"[Space] Out of business hours => skip\");\r\n                return false;\r\n            }\r\n        }\r\n        // Interval\r\n        const now = Date.now();\r\n        if (this.lastSpaceEndedAt) {\r\n            const minIntervalMs =\r\n                (this.decisionOptions.minIntervalBetweenSpacesMinutes ?? 60) *\r\n                60_000;\r\n            if (now - this.lastSpaceEndedAt < minIntervalMs) {\r\n                elizaLogger.log(\"[Space] Too soon since last space => skip\");\r\n                return false;\r\n            }\r\n        }\r\n\r\n        elizaLogger.log(\"[Space] Deciding to launch a new Space...\");\r\n        return true;\r\n    }\r\n\r\n    private async generateSpaceConfig(): Promise<SpaceConfig> {\r\n        if (\r\n            !this.decisionOptions.topics ||\r\n            this.decisionOptions.topics.length === 0\r\n        ) {\r\n            const newTopics = await generateTopicsIfEmpty(this.client.runtime);\r\n            this.decisionOptions.topics = newTopics;\r\n        }\r\n\r\n        let chosenTopic = \"Random Tech Chat\";\r\n        if (\r\n            this.decisionOptions.topics &&\r\n            this.decisionOptions.topics.length > 0\r\n        ) {\r\n            chosenTopic =\r\n                this.decisionOptions.topics[\r\n                    Math.floor(\r\n                        Math.random() * this.decisionOptions.topics.length\r\n                    )\r\n                ];\r\n        }\r\n\r\n        return {\r\n            mode: \"INTERACTIVE\",\r\n            title: chosenTopic,\r\n            description: `Discussion about ${chosenTopic}`,\r\n            languages: [\"en\"],\r\n        };\r\n    }\r\n\r\n    public async startSpace(config: SpaceConfig) {\r\n        elizaLogger.log(\"[Space] Starting a new Twitter Space...\");\r\n\r\n        try {\r\n            this.currentSpace = new Space(this.scraper);\r\n            this.isSpaceRunning = false;\r\n            this.spaceId = undefined;\r\n            this.startedAt = Date.now();\r\n\r\n            // Reset states\r\n            this.activeSpeakers = [];\r\n            this.speakerQueue = [];\r\n\r\n            // Retrieve keys\r\n            const openAiKey = process.env.OPENAI_API_KEY || \"\";\r\n            const elevenLabsKey = process.env.ELEVENLABS_XI_API_KEY || \"\";\r\n\r\n            // Plugins\r\n            if (this.decisionOptions.enableRecording) {\r\n                elizaLogger.log(\"[Space] Using RecordToDiskPlugin\");\r\n                this.currentSpace.use(new RecordToDiskPlugin());\r\n            }\r\n\r\n            if (this.decisionOptions.enableSttTts) {\r\n                elizaLogger.log(\"[Space] Using SttTtsPlugin\");\r\n                const sttTts = new SttTtsPlugin();\r\n                this.sttTtsPlugin = sttTts;\r\n                this.currentSpace.use(sttTts, {\r\n                    openAiApiKey: openAiKey,\r\n                    elevenLabsApiKey: elevenLabsKey,\r\n                    voiceId: this.decisionOptions.voiceId,\r\n                    gptModel: this.decisionOptions.gptModel,\r\n                    systemPrompt: this.decisionOptions.systemPrompt,\r\n                    sttLanguage: this.decisionOptions.sttLanguage,\r\n                    transcriptionService:\r\n                        this.client.runtime.getService<ITranscriptionService>(\r\n                            ServiceType.TRANSCRIPTION\r\n                        ),\r\n                });\r\n            }\r\n\r\n            if (this.decisionOptions.enableIdleMonitor) {\r\n                elizaLogger.log(\"[Space] Using IdleMonitorPlugin\");\r\n                this.currentSpace.use(\r\n                    new IdleMonitorPlugin(\r\n                        this.decisionOptions.idleKickTimeoutMs ?? 60_000,\r\n                        10_000\r\n                    )\r\n                );\r\n            }\r\n\r\n            const broadcastInfo = await this.currentSpace.initialize(config);\r\n            this.spaceId = broadcastInfo.room_id;\r\n            this.isSpaceRunning = true;\r\n            await this.scraper.sendTweet(\r\n                broadcastInfo.share_url.replace(\"broadcasts\", \"spaces\")\r\n            );\r\n\r\n            const spaceUrl = broadcastInfo.share_url.replace(\r\n                \"broadcasts\",\r\n                \"spaces\"\r\n            );\r\n            elizaLogger.log(`[Space] Space started => ${spaceUrl}`);\r\n\r\n            // Greet\r\n            await speakFiller(\r\n                this.client.runtime,\r\n                this.sttTtsPlugin,\r\n                \"WELCOME\"\r\n            );\r\n\r\n            // Events\r\n            this.currentSpace.on(\"occupancyUpdate\", (update) => {\r\n                elizaLogger.log(\r\n                    `[Space] Occupancy => ${update.occupancy} participant(s).`\r\n                );\r\n            });\r\n\r\n            this.currentSpace.on(\r\n                \"speakerRequest\",\r\n                async (req: SpeakerRequest) => {\r\n                    elizaLogger.log(\r\n                        `[Space] Speaker request from @${req.username} (${req.userId}).`\r\n                    );\r\n                    await this.handleSpeakerRequest(req);\r\n                }\r\n            );\r\n\r\n            this.currentSpace.on(\"idleTimeout\", async (info) => {\r\n                elizaLogger.log(\r\n                    `[Space] idleTimeout => no audio for ${info.idleMs} ms.`\r\n                );\r\n                await speakFiller(\r\n                    this.client.runtime,\r\n                    this.sttTtsPlugin,\r\n                    \"IDLE_ENDING\"\r\n                );\r\n                await this.stopSpace();\r\n            });\r\n\r\n            process.on(\"SIGINT\", async () => {\r\n                elizaLogger.log(\"[Space] SIGINT => stopping space\");\r\n                await speakFiller(\r\n                    this.client.runtime,\r\n                    this.sttTtsPlugin,\r\n                    \"CLOSING\"\r\n                );\r\n                await this.stopSpace();\r\n                process.exit(0);\r\n            });\r\n        } catch (error) {\r\n            elizaLogger.error(\"[Space] Error launching Space =>\", error);\r\n            this.isSpaceRunning = false;\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Periodic management: check durations, remove extras, maybe accept new from queue\r\n     */\r\n    private async manageCurrentSpace() {\r\n        if (!this.spaceId || !this.currentSpace) return;\r\n        try {\r\n            const audioSpace = await this.scraper.getAudioSpaceById(\r\n                this.spaceId\r\n            );\r\n            const { participants } = audioSpace;\r\n            const numSpeakers = participants.speakers?.length || 0;\r\n            const totalListeners = participants.listeners?.length || 0;\r\n\r\n            // 1) Remove any speaker who exceeded speakerMaxDurationMs\r\n            const maxDur = this.decisionOptions.speakerMaxDurationMs ?? 240_000;\r\n            const now = Date.now();\r\n\r\n            for (let i = this.activeSpeakers.length - 1; i >= 0; i--) {\r\n                const speaker = this.activeSpeakers[i];\r\n                const elapsed = now - speaker.startTime;\r\n                if (elapsed > maxDur) {\r\n                    elizaLogger.log(\r\n                        `[Space] Speaker @${speaker.username} exceeded max duration => removing`\r\n                    );\r\n                    await this.removeSpeaker(speaker.userId);\r\n                    this.activeSpeakers.splice(i, 1);\r\n\r\n                    // Possibly speak a short \"SPEAKER_LEFT\" filler\r\n                    await speakFiller(\r\n                        this.client.runtime,\r\n                        this.sttTtsPlugin,\r\n                        \"SPEAKER_LEFT\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            // 2) If we have capacity for new speakers from the queue, accept them\r\n            await this.acceptSpeakersFromQueueIfNeeded();\r\n\r\n            // 3) If somehow more than maxSpeakers are active, remove the extras\r\n            if (numSpeakers > (this.decisionOptions.maxSpeakers ?? 1)) {\r\n                elizaLogger.log(\r\n                    \"[Space] More than maxSpeakers => removing extras...\"\r\n                );\r\n                await this.kickExtraSpeakers(participants.speakers);\r\n            }\r\n\r\n            // 4) Possibly stop the space if empty or time exceeded\r\n            const elapsedMinutes = (now - (this.startedAt || 0)) / 60000;\r\n            if (\r\n                elapsedMinutes >\r\n                    (this.decisionOptions.typicalDurationMinutes ?? 30) ||\r\n                (numSpeakers === 0 &&\r\n                    totalListeners === 0 &&\r\n                    elapsedMinutes > 5)\r\n            ) {\r\n                elizaLogger.log(\r\n                    \"[Space] Condition met => stopping the Space...\"\r\n                );\r\n                await speakFiller(\r\n                    this.client.runtime,\r\n                    this.sttTtsPlugin,\r\n                    \"CLOSING\",\r\n                    4000\r\n                );\r\n                await this.stopSpace();\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"[Space] Error in manageCurrentSpace =>\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If we have available slots, accept new speakers from the queue\r\n     */\r\n    private async acceptSpeakersFromQueueIfNeeded() {\r\n        // while queue not empty and activeSpeakers < maxSpeakers, accept next\r\n        const ms = this.decisionOptions.maxSpeakers ?? 1;\r\n        while (\r\n            this.speakerQueue.length > 0 &&\r\n            this.activeSpeakers.length < ms\r\n        ) {\r\n            const nextReq = this.speakerQueue.shift();\r\n            if (nextReq) {\r\n                await speakFiller(\r\n                    this.client.runtime,\r\n                    this.sttTtsPlugin,\r\n                    \"PRE_ACCEPT\"\r\n                );\r\n                await this.acceptSpeaker(nextReq);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async handleSpeakerRequest(req: SpeakerRequest) {\r\n        if (!this.spaceId || !this.currentSpace) return;\r\n\r\n        const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);\r\n        const janusSpeakers = audioSpace?.participants?.speakers || [];\r\n\r\n        // If we haven't reached maxSpeakers, accept immediately\r\n        if (janusSpeakers.length < (this.decisionOptions.maxSpeakers ?? 1)) {\r\n            elizaLogger.log(`[Space] Accepting speaker @${req.username} now`);\r\n            await speakFiller(\r\n                this.client.runtime,\r\n                this.sttTtsPlugin,\r\n                \"PRE_ACCEPT\"\r\n            );\r\n            await this.acceptSpeaker(req);\r\n        } else {\r\n            elizaLogger.log(\r\n                `[Space] Adding speaker @${req.username} to the queue`\r\n            );\r\n            this.speakerQueue.push(req);\r\n        }\r\n    }\r\n\r\n    private async acceptSpeaker(req: SpeakerRequest) {\r\n        if (!this.currentSpace) return;\r\n        try {\r\n            await this.currentSpace.approveSpeaker(req.userId, req.sessionUUID);\r\n            this.activeSpeakers.push({\r\n                userId: req.userId,\r\n                sessionUUID: req.sessionUUID,\r\n                username: req.username,\r\n                startTime: Date.now(),\r\n            });\r\n            elizaLogger.log(`[Space] Speaker @${req.username} is now live`);\r\n        } catch (err) {\r\n            elizaLogger.error(\r\n                `[Space] Error approving speaker @${req.username}:`,\r\n                err\r\n            );\r\n        }\r\n    }\r\n\r\n    private async removeSpeaker(userId: string) {\r\n        if (!this.currentSpace) return;\r\n        try {\r\n            await this.currentSpace.removeSpeaker(userId);\r\n            elizaLogger.log(`[Space] Removed speaker userId=${userId}`);\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                `[Space] Error removing speaker userId=${userId} =>`,\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If more than maxSpeakers are found, remove extras\r\n     * Also update activeSpeakers array\r\n     */\r\n    private async kickExtraSpeakers(speakers: any[]) {\r\n        if (!this.currentSpace) return;\r\n        const ms = this.decisionOptions.maxSpeakers ?? 1;\r\n\r\n        // sort by who joined first if needed, or just slice\r\n        const extras = speakers.slice(ms);\r\n        for (const sp of extras) {\r\n            elizaLogger.log(\r\n                `[Space] Removing extra speaker => userId=${sp.user_id}`\r\n            );\r\n            await this.removeSpeaker(sp.user_id);\r\n\r\n            // remove from activeSpeakers array\r\n            const idx = this.activeSpeakers.findIndex(\r\n                (s) => s.userId === sp.user_id\r\n            );\r\n            if (idx !== -1) {\r\n                this.activeSpeakers.splice(idx, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async stopSpace() {\r\n        if (!this.currentSpace || !this.isSpaceRunning) return;\r\n        try {\r\n            elizaLogger.log(\"[Space] Stopping the current Space...\");\r\n            await this.currentSpace.stop();\r\n        } catch (err) {\r\n            elizaLogger.error(\"[Space] Error stopping Space =>\", err);\r\n        } finally {\r\n            this.isSpaceRunning = false;\r\n            this.spaceId = undefined;\r\n            this.currentSpace = undefined;\r\n            this.startedAt = undefined;\r\n            this.lastSpaceEndedAt = Date.now();\r\n            this.activeSpeakers = [];\r\n            this.speakerQueue = [];\r\n        }\r\n    }\r\n}\r\n","// src/plugins/SttTtsPlugin.ts\r\n\r\nimport { spawn } from \"child_process\";\r\nimport { ITranscriptionService, elizaLogger } from \"@elizaos/core\";\r\nimport { Space, JanusClient, AudioDataWithUser } from \"agent-twitter-client\";\r\nimport { Plugin } from \"@elizaos/core\";\r\n\r\ninterface PluginConfig {\r\n    openAiApiKey?: string; // for STT & ChatGPT\r\n    elevenLabsApiKey?: string; // for TTS\r\n    sttLanguage?: string; // e.g. \"en\" for Whisper\r\n    gptModel?: string; // e.g. \"gpt-3.5-turbo\"\r\n    silenceThreshold?: number; // amplitude threshold for ignoring silence\r\n    voiceId?: string; // specify which ElevenLabs voice to use\r\n    elevenLabsModel?: string; // e.g. \"eleven_monolingual_v1\"\r\n    systemPrompt?: string; // ex. \"You are a helpful AI assistant\"\r\n    chatContext?: Array<{\r\n        role: \"system\" | \"user\" | \"assistant\";\r\n        content: string;\r\n    }>;\r\n    transcriptionService: ITranscriptionService;\r\n}\r\n\r\n/**\r\n * MVP plugin for speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\r\n * Approach:\r\n *   - Collect each speaker's unmuted PCM in a memory buffer (only if above silence threshold)\r\n *   - On speaker mute -> flush STT -> GPT -> TTS -> push to Janus\r\n */\r\nexport class SttTtsPlugin implements Plugin {\r\n    name = \"SttTtsPlugin\";\r\n    description = \"Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\";\r\n\r\n    private space?: Space;\r\n    private janus?: JanusClient;\r\n\r\n    private openAiApiKey?: string;\r\n    private elevenLabsApiKey?: string;\r\n\r\n    private gptModel = \"gpt-3.5-turbo\";\r\n    private voiceId = \"21m00Tcm4TlvDq8ikWAM\";\r\n    private elevenLabsModel = \"eleven_monolingual_v1\";\r\n    private systemPrompt = \"You are a helpful AI assistant.\";\r\n    private chatContext: Array<{\r\n        role: \"system\" | \"user\" | \"assistant\";\r\n        content: string;\r\n    }> = [];\r\n\r\n    private transcriptionService: ITranscriptionService;\r\n\r\n    /**\r\n     * userId => arrayOfChunks (PCM Int16)\r\n     */\r\n    private pcmBuffers = new Map<string, Int16Array[]>();\r\n\r\n    /**\r\n     * Track mute states: userId => boolean (true=unmuted)\r\n     */\r\n    private speakerUnmuted = new Map<string, boolean>();\r\n\r\n    /**\r\n     * For ignoring near-silence frames (if amplitude < threshold)\r\n     */\r\n    private silenceThreshold = 50;\r\n\r\n    // TTS queue for sequentially speaking\r\n    private ttsQueue: string[] = [];\r\n    private isSpeaking = false;\r\n\r\n    onAttach(_space: Space) {\r\n        elizaLogger.log(\"[SttTtsPlugin] onAttach => space was attached\");\r\n    }\r\n\r\n    init(params: { space: Space; pluginConfig?: Record<string, any> }): void {\r\n        elizaLogger.log(\r\n            \"[SttTtsPlugin] init => Space fully ready. Subscribing to events.\"\r\n        );\r\n\r\n        this.space = params.space;\r\n        this.janus = (this.space as any)?.janusClient as\r\n            | JanusClient\r\n            | undefined;\r\n\r\n        const config = params.pluginConfig as PluginConfig;\r\n        this.openAiApiKey = config?.openAiApiKey;\r\n        this.elevenLabsApiKey = config?.elevenLabsApiKey;\r\n        this.transcriptionService = config.transcriptionService;\r\n        if (config?.gptModel) this.gptModel = config.gptModel;\r\n        if (typeof config?.silenceThreshold === \"number\") {\r\n            this.silenceThreshold = config.silenceThreshold;\r\n        }\r\n        if (config?.voiceId) {\r\n            this.voiceId = config.voiceId;\r\n        }\r\n        if (config?.elevenLabsModel) {\r\n            this.elevenLabsModel = config.elevenLabsModel;\r\n        }\r\n        if (config?.systemPrompt) {\r\n            this.systemPrompt = config.systemPrompt;\r\n        }\r\n        if (config?.chatContext) {\r\n            this.chatContext = config.chatContext;\r\n        }\r\n        elizaLogger.log(\"[SttTtsPlugin] Plugin config =>\", config);\r\n\r\n        // Listen for mute events\r\n        this.space.on(\r\n            \"muteStateChanged\",\r\n            (evt: { userId: string; muted: boolean }) => {\r\n                elizaLogger.log(\r\n                    \"[SttTtsPlugin] Speaker muteStateChanged =>\",\r\n                    evt\r\n                );\r\n                if (evt.muted) {\r\n                    this.handleMute(evt.userId).catch((err) =>\r\n                        elizaLogger.error(\r\n                            \"[SttTtsPlugin] handleMute error =>\",\r\n                            err\r\n                        )\r\n                    );\r\n                } else {\r\n                    this.speakerUnmuted.set(evt.userId, true);\r\n                    if (!this.pcmBuffers.has(evt.userId)) {\r\n                        this.pcmBuffers.set(evt.userId, []);\r\n                    }\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Called whenever we receive PCM from a speaker\r\n     */\r\n    onAudioData(data: AudioDataWithUser): void {\r\n        if (!this.speakerUnmuted.get(data.userId)) return;\r\n\r\n        let maxVal = 0;\r\n        for (let i = 0; i < data.samples.length; i++) {\r\n            const val = Math.abs(data.samples[i]);\r\n            if (val > maxVal) maxVal = val;\r\n        }\r\n        if (maxVal < this.silenceThreshold) {\r\n            return;\r\n        }\r\n\r\n        let arr = this.pcmBuffers.get(data.userId);\r\n        if (!arr) {\r\n            arr = [];\r\n            this.pcmBuffers.set(data.userId, arr);\r\n        }\r\n        arr.push(data.samples);\r\n    }\r\n\r\n    // /src/sttTtsPlugin.ts\r\n    private async convertPcmToWavInMemory(\r\n        pcmData: Int16Array,\r\n        sampleRate: number\r\n    ): Promise<ArrayBuffer> {\r\n        // number of channels\r\n        const numChannels = 1;\r\n        // byte rate = (sampleRate * numChannels * bitsPerSample/8)\r\n        const byteRate = sampleRate * numChannels * 2;\r\n        const blockAlign = numChannels * 2;\r\n        // data chunk size = pcmData.length * (bitsPerSample/8)\r\n        const dataSize = pcmData.length * 2;\r\n\r\n        // WAV header is 44 bytes\r\n        const buffer = new ArrayBuffer(44 + dataSize);\r\n        const view = new DataView(buffer);\r\n\r\n        // RIFF chunk descriptor\r\n        this.writeString(view, 0, \"RIFF\");\r\n        view.setUint32(4, 36 + dataSize, true); // file size - 8\r\n        this.writeString(view, 8, \"WAVE\");\r\n\r\n        // fmt sub-chunk\r\n        this.writeString(view, 12, \"fmt \");\r\n        view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)\r\n        view.setUint16(20, 1, true); // AudioFormat (1 = PCM)\r\n        view.setUint16(22, numChannels, true); // NumChannels\r\n        view.setUint32(24, sampleRate, true); // SampleRate\r\n        view.setUint32(28, byteRate, true); // ByteRate\r\n        view.setUint16(32, blockAlign, true); // BlockAlign\r\n        view.setUint16(34, 16, true); // BitsPerSample (16)\r\n\r\n        // data sub-chunk\r\n        this.writeString(view, 36, \"data\");\r\n        view.setUint32(40, dataSize, true);\r\n\r\n        // Write PCM samples\r\n        let offset = 44;\r\n        for (let i = 0; i < pcmData.length; i++, offset += 2) {\r\n            view.setInt16(offset, pcmData[i], true);\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    private writeString(view: DataView, offset: number, text: string) {\r\n        for (let i = 0; i < text.length; i++) {\r\n            view.setUint8(offset + i, text.charCodeAt(i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * On speaker mute => flush STT => GPT => TTS => push to Janus\r\n     */\r\n    private async handleMute(userId: string): Promise<void> {\r\n        this.speakerUnmuted.set(userId, false);\r\n        const chunks = this.pcmBuffers.get(userId) || [];\r\n        this.pcmBuffers.set(userId, []);\r\n\r\n        if (!chunks.length) {\r\n            elizaLogger.warn(\r\n                \"[SttTtsPlugin] No audio chunks for user =>\",\r\n                userId\r\n            );\r\n            return;\r\n        }\r\n        elizaLogger.log(\r\n            `[SttTtsPlugin] Flushing STT buffer for user=${userId}, chunks=${chunks.length}`\r\n        );\r\n\r\n        const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);\r\n        const merged = new Int16Array(totalLen);\r\n        let offset = 0;\r\n        for (const c of chunks) {\r\n            merged.set(c, offset);\r\n            offset += c.length;\r\n        }\r\n\r\n        // Convert PCM to WAV for STT\r\n        const wavBuffer = await this.convertPcmToWavInMemory(merged, 48000);\r\n\r\n        // Whisper STT\r\n        const sttText = await this.transcriptionService.transcribe(wavBuffer);\r\n\r\n        if (!sttText || !sttText.trim()) {\r\n            elizaLogger.warn(\r\n                \"[SttTtsPlugin] No speech recognized for user =>\",\r\n                userId\r\n            );\r\n            return;\r\n        }\r\n        elizaLogger.log(\r\n            `[SttTtsPlugin] STT => user=${userId}, text=\"${sttText}\"`\r\n        );\r\n\r\n        // GPT answer\r\n        const replyText = await this.askChatGPT(sttText);\r\n        elizaLogger.log(\r\n            `[SttTtsPlugin] GPT => user=${userId}, reply=\"${replyText}\"`\r\n        );\r\n\r\n        // Use the standard speak method with queue\r\n        await this.speakText(replyText);\r\n    }\r\n\r\n    /**\r\n     * Public method to queue a TTS request\r\n     */\r\n    public async speakText(text: string): Promise<void> {\r\n        this.ttsQueue.push(text);\r\n        if (!this.isSpeaking) {\r\n            this.isSpeaking = true;\r\n            this.processTtsQueue().catch((err) => {\r\n                elizaLogger.error(\r\n                    \"[SttTtsPlugin] processTtsQueue error =>\",\r\n                    err\r\n                );\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process TTS requests one by one\r\n     */\r\n    private async processTtsQueue(): Promise<void> {\r\n        while (this.ttsQueue.length > 0) {\r\n            const text = this.ttsQueue.shift();\r\n            if (!text) continue;\r\n\r\n            try {\r\n                const ttsAudio = await this.elevenLabsTts(text);\r\n                const pcm = await this.convertMp3ToPcm(ttsAudio, 48000);\r\n                await this.streamToJanus(pcm, 48000);\r\n            } catch (err) {\r\n                elizaLogger.error(\"[SttTtsPlugin] TTS streaming error =>\", err);\r\n            }\r\n        }\r\n        this.isSpeaking = false;\r\n    }\r\n\r\n    /**\r\n     * Simple ChatGPT call\r\n     */\r\n    private async askChatGPT(userText: string): Promise<string> {\r\n        if (!this.openAiApiKey) {\r\n            throw new Error(\"[SttTtsPlugin] No OpenAI API key for ChatGPT\");\r\n        }\r\n        const url = \"https://api.openai.com/v1/chat/completions\";\r\n        const messages = [\r\n            { role: \"system\", content: this.systemPrompt },\r\n            ...this.chatContext,\r\n            { role: \"user\", content: userText },\r\n        ];\r\n\r\n        const resp = await fetch(url, {\r\n            method: \"POST\",\r\n            headers: {\r\n                Authorization: `Bearer ${this.openAiApiKey}`,\r\n                \"Content-Type\": \"application/json\",\r\n            },\r\n            body: JSON.stringify({\r\n                model: this.gptModel,\r\n                messages,\r\n            }),\r\n        });\r\n\r\n        if (!resp.ok) {\r\n            const errText = await resp.text();\r\n            throw new Error(\r\n                `[SttTtsPlugin] ChatGPT error => ${resp.status} ${errText}`\r\n            );\r\n        }\r\n\r\n        const json = await resp.json();\r\n        const reply = json.choices?.[0]?.message?.content || \"\";\r\n        this.chatContext.push({ role: \"user\", content: userText });\r\n        this.chatContext.push({ role: \"assistant\", content: reply });\r\n        return reply.trim();\r\n    }\r\n\r\n    /**\r\n     * ElevenLabs TTS => returns MP3 Buffer\r\n     */\r\n    private async elevenLabsTts(text: string): Promise<Buffer> {\r\n        if (!this.elevenLabsApiKey) {\r\n            throw new Error(\"[SttTtsPlugin] No ElevenLabs API key\");\r\n        }\r\n        const url = `https://api.elevenlabs.io/v1/text-to-speech/${this.voiceId}`;\r\n        const resp = await fetch(url, {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"xi-api-key\": this.elevenLabsApiKey,\r\n            },\r\n            body: JSON.stringify({\r\n                text,\r\n                model_id: this.elevenLabsModel,\r\n                voice_settings: { stability: 0.4, similarity_boost: 0.8 },\r\n            }),\r\n        });\r\n        if (!resp.ok) {\r\n            const errText = await resp.text();\r\n            throw new Error(\r\n                `[SttTtsPlugin] ElevenLabs TTS error => ${resp.status} ${errText}`\r\n            );\r\n        }\r\n        const arrayBuf = await resp.arrayBuffer();\r\n        return Buffer.from(arrayBuf);\r\n    }\r\n\r\n    /**\r\n     * Convert MP3 => PCM via ffmpeg\r\n     */\r\n    private convertMp3ToPcm(\r\n        mp3Buf: Buffer,\r\n        outRate: number\r\n    ): Promise<Int16Array> {\r\n        return new Promise((resolve, reject) => {\r\n            const ff = spawn(\"ffmpeg\", [\r\n                \"-i\",\r\n                \"pipe:0\",\r\n                \"-f\",\r\n                \"s16le\",\r\n                \"-ar\",\r\n                outRate.toString(),\r\n                \"-ac\",\r\n                \"1\",\r\n                \"pipe:1\",\r\n            ]);\r\n            let raw = Buffer.alloc(0);\r\n\r\n            ff.stdout.on(\"data\", (chunk: Buffer) => {\r\n                raw = Buffer.concat([raw, chunk]);\r\n            });\r\n            ff.stderr.on(\"data\", () => {\r\n                // ignoring ffmpeg logs\r\n            });\r\n            ff.on(\"close\", (code) => {\r\n                if (code !== 0) {\r\n                    reject(new Error(`ffmpeg error code=${code}`));\r\n                    return;\r\n                }\r\n                const samples = new Int16Array(\r\n                    raw.buffer,\r\n                    raw.byteOffset,\r\n                    raw.byteLength / 2\r\n                );\r\n                resolve(samples);\r\n            });\r\n\r\n            ff.stdin.write(mp3Buf);\r\n            ff.stdin.end();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Push PCM back to Janus in small frames\r\n     * We'll do 10ms @48k => 960 samples per frame\r\n     */\r\n    private async streamToJanus(\r\n        samples: Int16Array,\r\n        sampleRate: number\r\n    ): Promise<void> {\r\n        // TODO: Check if better than 480 fixed\r\n        const FRAME_SIZE = Math.floor(sampleRate * 0.01); // 10ms frames => 480 @48kHz\r\n\r\n        for (\r\n            let offset = 0;\r\n            offset + FRAME_SIZE <= samples.length;\r\n            offset += FRAME_SIZE\r\n        ) {\r\n            const frame = new Int16Array(FRAME_SIZE);\r\n            frame.set(samples.subarray(offset, offset + FRAME_SIZE));\r\n            this.janus?.pushLocalAudio(frame, sampleRate, 1);\r\n\r\n            // Short pause so we don't overload\r\n            await new Promise((r) => setTimeout(r, 10));\r\n        }\r\n    }\r\n\r\n    public setSystemPrompt(prompt: string) {\r\n        this.systemPrompt = prompt;\r\n        elizaLogger.log(\"[SttTtsPlugin] setSystemPrompt =>\", prompt);\r\n    }\r\n\r\n    /**\r\n     * Change the GPT model at runtime (e.g. \"gpt-4\", \"gpt-3.5-turbo\", etc.).\r\n     */\r\n    public setGptModel(model: string) {\r\n        this.gptModel = model;\r\n        elizaLogger.log(\"[SttTtsPlugin] setGptModel =>\", model);\r\n    }\r\n\r\n    /**\r\n     * Add a message (system, user or assistant) to the chat context.\r\n     * E.g. to store conversation history or inject a persona.\r\n     */\r\n    public addMessage(role: \"system\" | \"user\" | \"assistant\", content: string) {\r\n        this.chatContext.push({ role, content });\r\n        elizaLogger.log(\r\n            `[SttTtsPlugin] addMessage => role=${role}, content=${content}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Clear the chat context if needed.\r\n     */\r\n    public clearChatContext() {\r\n        this.chatContext = [];\r\n        elizaLogger.log(\"[SttTtsPlugin] clearChatContext => done\");\r\n    }\r\n\r\n    cleanup(): void {\r\n        elizaLogger.log(\"[SttTtsPlugin] cleanup => releasing resources\");\r\n        this.pcmBuffers.clear();\r\n        this.speakerUnmuted.clear();\r\n        this.ttsQueue = [];\r\n        this.isSpeaking = false;\r\n    }\r\n}\r\n"],"mappings":"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","names":["elizaLogger","existingMemories","existingMemoryIds","tweetsToSave","profile","ActionTimelineType","SearchMode","stringToUuid","elizaLogger","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","elizaLogger","stringToUuid","getEmbeddingZeroVector","elizaLogger","SearchMode","stringToUuid","tweet","message","response","getEmbeddingZeroVector","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","ServiceType","elizaLogger","stringToUuid","getEmbeddingZeroVector","composeContext","ModelClass","ServiceType","SearchMode","composeContext","elizaLogger","generateMessageResponse","generateText","messageCompletionFooter","ModelClass","ServiceType","stringToUuid","messageCompletionFooter","elizaLogger","SearchMode","generateText","ModelClass","stringToUuid","ServiceType","composeContext","generateMessageResponse","response","elizaLogger","composeContext","generateText","ModelClass","ServiceType","elizaLogger","composeContext","generateText","ModelClass","elizaLogger","ServiceType","elizaLogger"]}