{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/post.ts","../src/prompts.ts","../src/utils.ts","../src/memory.ts","../src/actions.ts","../src/interactions.ts"],"sourcesContent":["import { Client, IAgentRuntime, elizaLogger } from \"@elizaos/core\";\r\nimport { FarcasterClient } from \"./client\";\r\nimport { FarcasterPostManager } from \"./post\";\r\nimport { FarcasterInteractionManager } from \"./interactions\";\r\nimport { Configuration, NeynarAPIClient } from \"@neynar/nodejs-sdk\";\r\n\r\nexport class FarcasterAgentClient implements Client {\r\n    client: FarcasterClient;\r\n    posts: FarcasterPostManager;\r\n    interactions: FarcasterInteractionManager;\r\n\r\n    private signerUuid: string;\r\n\r\n    constructor(\r\n        public runtime: IAgentRuntime,\r\n        client?: FarcasterClient\r\n    ) {\r\n        const cache = new Map<string, any>();\r\n\r\n        this.signerUuid = runtime.getSetting(\"FARCASTER_NEYNAR_SIGNER_UUID\")!;\r\n\r\n        const neynarConfig = new Configuration({\r\n            apiKey: runtime.getSetting(\"FARCASTER_NEYNAR_API_KEY\")!,\r\n        });\r\n\r\n        const neynarClient = new NeynarAPIClient(neynarConfig);\r\n\r\n        this.client =\r\n            client ??\r\n            new FarcasterClient({\r\n                runtime,\r\n                ssl: true,\r\n                url:\r\n                    runtime.getSetting(\"FARCASTER_HUB_URL\") ??\r\n                    \"hub.pinata.cloud\",\r\n                neynar: neynarClient,\r\n                signerUuid: this.signerUuid,\r\n                cache,\r\n            });\r\n\r\n        elizaLogger.info(\"Farcaster Neynar client initialized.\");\r\n\r\n        this.posts = new FarcasterPostManager(\r\n            this.client,\r\n            this.runtime,\r\n            this.signerUuid,\r\n            cache\r\n        );\r\n\r\n        this.interactions = new FarcasterInteractionManager(\r\n            this.client,\r\n            this.runtime,\r\n            this.signerUuid,\r\n            cache\r\n        );\r\n    }\r\n\r\n    async start() {\r\n        await Promise.all([this.posts.start(), this.interactions.start()]);\r\n    }\r\n\r\n    async stop() {\r\n        await Promise.all([this.posts.stop(), this.interactions.stop()]);\r\n    }\r\n}\r\n","import { IAgentRuntime, elizaLogger } from \"@elizaos/core\";\r\nimport { NeynarAPIClient, isApiErrorResponse } from \"@neynar/nodejs-sdk\";\r\nimport { NeynarCastResponse, Cast, Profile, FidRequest, CastId } from \"./types\";\r\n\r\nexport class FarcasterClient {\r\n    runtime: IAgentRuntime;\r\n    neynar: NeynarAPIClient;\r\n    signerUuid: string;\r\n    cache: Map<string, any>;\r\n    lastInteractionTimestamp: Date;\r\n\r\n    constructor(opts: {\r\n        runtime: IAgentRuntime;\r\n        url: string;\r\n        ssl: boolean;\r\n        neynar: NeynarAPIClient;\r\n        signerUuid: string;\r\n        cache: Map<string, any>;\r\n    }) {\r\n        this.cache = opts.cache;\r\n        this.runtime = opts.runtime;\r\n        this.neynar = opts.neynar;\r\n        this.signerUuid = opts.signerUuid;\r\n        this.lastInteractionTimestamp = new Date();\r\n    }\r\n\r\n    async loadCastFromNeynarResponse(neynarResponse: any): Promise<Cast> {\r\n        const profile = await this.getProfile(neynarResponse.author.fid);\r\n        return {\r\n            hash: neynarResponse.hash,\r\n            authorFid: neynarResponse.author.fid,\r\n            text: neynarResponse.text,\r\n            profile,\r\n            ...(neynarResponse.parent_hash\r\n                ? {\r\n                      inReplyTo: {\r\n                          hash: neynarResponse.parent_hash,\r\n                          fid: neynarResponse.parent_author.fid,\r\n                      },\r\n                  }\r\n                : {}),\r\n            timestamp: new Date(neynarResponse.timestamp),\r\n        };\r\n    }\r\n\r\n    async publishCast(\r\n        cast: string,\r\n        parentCastId: CastId | undefined,\r\n        retryTimes?: number\r\n    ): Promise<NeynarCastResponse | undefined> {\r\n        try {\r\n            const result = await this.neynar.publishCast({\r\n                signerUuid: this.signerUuid,\r\n                text: cast,\r\n                parent: parentCastId?.hash,\r\n            });\r\n            if (result.success) {\r\n                return {\r\n                    hash: result.cast.hash,\r\n                    authorFid: result.cast.author.fid,\r\n                    text: result.cast.text,\r\n                };\r\n            }\r\n        } catch (err) {\r\n            if (isApiErrorResponse(err)) {\r\n                elizaLogger.error(\"Neynar error: \", err.response.data);\r\n                throw err.response.data;\r\n            } else {\r\n                elizaLogger.error(\"Error: \", err);\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    async getCast(castHash: string): Promise<Cast> {\r\n        if (this.cache.has(`farcaster/cast/${castHash}`)) {\r\n            return this.cache.get(`farcaster/cast/${castHash}`);\r\n        }\r\n\r\n        const response = await this.neynar.lookupCastByHashOrWarpcastUrl({\r\n            identifier: castHash,\r\n            type: \"hash\",\r\n        });\r\n        const cast = {\r\n            hash: response.cast.hash,\r\n            authorFid: response.cast.author.fid,\r\n            text: response.cast.text,\r\n            profile: {\r\n                fid: response.cast.author.fid,\r\n                name: response.cast.author.display_name || \"anon\",\r\n                username: response.cast.author.username,\r\n            },\r\n            ...(response.cast.parent_hash\r\n                ? {\r\n                      inReplyTo: {\r\n                          hash: response.cast.parent_hash,\r\n                          fid: response.cast.parent_author.fid,\r\n                      },\r\n                  }\r\n                : {}),\r\n            timestamp: new Date(response.cast.timestamp),\r\n        };\r\n\r\n        this.cache.set(`farcaster/cast/${castHash}`, cast);\r\n\r\n        return cast;\r\n    }\r\n\r\n    async getCastsByFid(request: FidRequest): Promise<Cast[]> {\r\n        const timeline: Cast[] = [];\r\n\r\n        const response = await this.neynar.fetchCastsForUser({\r\n            fid: request.fid,\r\n            limit: request.pageSize,\r\n        });\r\n        response.casts.map((cast) => {\r\n            this.cache.set(`farcaster/cast/${cast.hash}`, cast);\r\n            timeline.push({\r\n                hash: cast.hash,\r\n                authorFid: cast.author.fid,\r\n                text: cast.text,\r\n                profile: {\r\n                    fid: cast.author.fid,\r\n                    name: cast.author.display_name || \"anon\",\r\n                    username: cast.author.username,\r\n                },\r\n                timestamp: new Date(cast.timestamp),\r\n            });\r\n        });\r\n\r\n        return timeline;\r\n    }\r\n\r\n    async getMentions(request: FidRequest): Promise<Cast[]> {\r\n        const neynarMentionsResponse = await this.neynar.fetchAllNotifications({\r\n            fid: request.fid,\r\n            type: [\"mentions\", \"replies\"],\r\n        });\r\n        const mentions: Cast[] = [];\r\n\r\n        neynarMentionsResponse.notifications.map((notification) => {\r\n            const cast = {\r\n                hash: notification.cast!.hash,\r\n                authorFid: notification.cast!.author.fid,\r\n                text: notification.cast!.text,\r\n                profile: {\r\n                    fid: notification.cast!.author.fid,\r\n                    name: notification.cast!.author.display_name || \"anon\",\r\n                    username: notification.cast!.author.username,\r\n                },\r\n                ...(notification.cast!.parent_hash\r\n                    ? {\r\n                          inReplyTo: {\r\n                              hash: notification.cast!.parent_hash,\r\n                              fid: notification.cast!.parent_author.fid,\r\n                          },\r\n                      }\r\n                    : {}),\r\n                timestamp: new Date(notification.cast!.timestamp),\r\n            };\r\n            mentions.push(cast);\r\n            this.cache.set(`farcaster/cast/${cast.hash}`, cast);\r\n        });\r\n\r\n        return mentions;\r\n    }\r\n\r\n    async getProfile(fid: number): Promise<Profile> {\r\n        if (this.cache.has(`farcaster/profile/${fid}`)) {\r\n            return this.cache.get(`farcaster/profile/${fid}`) as Profile;\r\n        }\r\n\r\n        const result = await this.neynar.fetchBulkUsers({ fids: [fid] });\r\n        if (!result.users || result.users.length < 1) {\r\n            elizaLogger.error(\"Error fetching user by fid\");\r\n\r\n            throw \"getProfile ERROR\";\r\n        }\r\n\r\n        const neynarUserProfile = result.users[0];\r\n\r\n        const profile: Profile = {\r\n            fid,\r\n            name: \"\",\r\n            username: \"\",\r\n        };\r\n\r\n        const userDataBodyType = {\r\n            1: \"pfp\",\r\n            2: \"name\",\r\n            3: \"bio\",\r\n            5: \"url\",\r\n            6: \"username\",\r\n            // 7: \"location\",\r\n            // 8: \"twitter\",\r\n            // 9: \"github\",\r\n        } as const;\r\n\r\n        profile.name = neynarUserProfile.display_name!;\r\n        profile.username = neynarUserProfile.username;\r\n        profile.bio = neynarUserProfile.profile.bio.text;\r\n        profile.pfp = neynarUserProfile.pfp_url;\r\n\r\n        this.cache.set(`farcaster/profile/${fid}`, profile);\r\n\r\n        return profile;\r\n    }\r\n\r\n    async getTimeline(request: FidRequest): Promise<{\r\n        timeline: Cast[];\r\n        nextPageToken?: Uint8Array | undefined;\r\n    }> {\r\n        const timeline: Cast[] = [];\r\n\r\n        const results = await this.getCastsByFid(request);\r\n\r\n        for (const cast of results) {\r\n            this.cache.set(`farcaster/cast/${cast.hash}`, cast);\r\n            timeline.push(cast);\r\n        }\r\n\r\n        return {\r\n            timeline,\r\n            //TODO implement paging\r\n            //nextPageToken: results.nextPageToken,\r\n        };\r\n    }\r\n}\r\n","import {\r\n    composeContext,\r\n    generateText,\r\n    IAgentRuntime,\r\n    ModelClass,\r\n    stringToUuid,\r\n    elizaLogger,\r\n} from \"@elizaos/core\";\r\nimport { FarcasterClient } from \"./client\";\r\nimport { formatTimeline, postTemplate } from \"./prompts\";\r\nimport { castUuid, MAX_CAST_LENGTH } from \"./utils\";\r\nimport { createCastMemory } from \"./memory\";\r\nimport { sendCast } from \"./actions\";\r\n\r\nexport class FarcasterPostManager {\r\n    private timeout: NodeJS.Timeout | undefined;\r\n\r\n    constructor(\r\n        public client: FarcasterClient,\r\n        public runtime: IAgentRuntime,\r\n        private signerUuid: string,\r\n        public cache: Map<string, any>\r\n    ) {}\r\n\r\n    public async start() {\r\n        const generateNewCastLoop = async () => {\r\n            try {\r\n                await this.generateNewCast();\r\n            } catch (error) {\r\n                elizaLogger.error(error);\r\n                return;\r\n            }\r\n\r\n            this.timeout = setTimeout(\r\n                generateNewCastLoop,\r\n                (Math.floor(Math.random() * (4 - 1 + 1)) + 1) * 60 * 60 * 1000\r\n            ); // Random interval between 1 and 4 hours\r\n        };\r\n\r\n        generateNewCastLoop();\r\n    }\r\n\r\n    public async stop() {\r\n        if (this.timeout) clearTimeout(this.timeout);\r\n    }\r\n\r\n    private async generateNewCast() {\r\n        elizaLogger.info(\"Generating new cast\");\r\n        try {\r\n            const fid = Number(this.runtime.getSetting(\"FARCASTER_FID\")!);\r\n\r\n            const profile = await this.client.getProfile(fid);\r\n            await this.runtime.ensureUserExists(\r\n                this.runtime.agentId,\r\n                profile.username,\r\n                this.runtime.character.name,\r\n                \"farcaster\"\r\n            );\r\n\r\n            const { timeline } = await this.client.getTimeline({\r\n                fid,\r\n                pageSize: 10,\r\n            });\r\n\r\n            this.cache.set(\"farcaster/timeline\", timeline);\r\n\r\n            const formattedHomeTimeline = formatTimeline(\r\n                this.runtime.character,\r\n                timeline\r\n            );\r\n\r\n            const generateRoomId = stringToUuid(\"farcaster_generate_room\");\r\n\r\n            const state = await this.runtime.composeState(\r\n                {\r\n                    roomId: generateRoomId,\r\n                    userId: this.runtime.agentId,\r\n                    agentId: this.runtime.agentId,\r\n                    content: { text: \"\", action: \"\" },\r\n                },\r\n                {\r\n                    farcasterUserName: profile.username,\r\n                    timeline: formattedHomeTimeline,\r\n                }\r\n            );\r\n\r\n            // Generate new cast\r\n            const context = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.farcasterPostTemplate ||\r\n                    postTemplate,\r\n            });\r\n\r\n            const newContent = await generateText({\r\n                runtime: this.runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            const slice = newContent.replaceAll(/\\\\n/g, \"\\n\").trim();\r\n\r\n            let content = slice.slice(0, MAX_CAST_LENGTH);\r\n\r\n            // if it's bigger than the max limit, delete the last line\r\n            if (content.length > MAX_CAST_LENGTH) {\r\n                content = content.slice(0, content.lastIndexOf(\"\\n\"));\r\n            }\r\n\r\n            if (content.length > MAX_CAST_LENGTH) {\r\n                // slice at the last period\r\n                content = content.slice(0, content.lastIndexOf(\".\"));\r\n            }\r\n\r\n            // if it's still too long, get the period before the last period\r\n            if (content.length > MAX_CAST_LENGTH) {\r\n                content = content.slice(0, content.lastIndexOf(\".\"));\r\n            }\r\n\r\n            if (this.runtime.getSetting(\"FARCASTER_DRY_RUN\") === \"true\") {\r\n                elizaLogger.info(`Dry run: would have cast: ${content}`);\r\n                return;\r\n            }\r\n\r\n            try {\r\n                const [{ cast }] = await sendCast({\r\n                    client: this.client,\r\n                    runtime: this.runtime,\r\n                    signerUuid: this.signerUuid,\r\n                    roomId: generateRoomId,\r\n                    content: { text: content },\r\n                    profile,\r\n                });\r\n\r\n                const roomId = castUuid({\r\n                    agentId: this.runtime.agentId,\r\n                    hash: cast.hash,\r\n                });\r\n\r\n                await this.runtime.ensureRoomExists(roomId);\r\n\r\n                await this.runtime.ensureParticipantInRoom(\r\n                    this.runtime.agentId,\r\n                    roomId\r\n                );\r\n\r\n                elizaLogger.info(\r\n                    `[Farcaster Neynar Client] Published cast ${cast.hash}`\r\n                );\r\n\r\n                await this.runtime.messageManager.createMemory(\r\n                    createCastMemory({\r\n                        roomId,\r\n                        runtime: this.runtime,\r\n                        cast,\r\n                    })\r\n                );\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error sending cast:\", error);\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error generating new cast:\", error);\r\n        }\r\n    }\r\n}\r\n","import {\r\n    Character,\r\n    messageCompletionFooter,\r\n    shouldRespondFooter,\r\n} from \"@elizaos/core\";\r\nimport type { Cast } from \"./types\";\r\n\r\nexport const formatCast = (cast: Cast) => {\r\n    return `ID: ${cast.hash}\r\n    From: ${cast.profile.name} (@${cast.profile.username})${cast.profile.username})${cast.inReplyTo ? `\\nIn reply to: ${cast.inReplyTo.fid}` : \"\"}\r\nText: ${cast.text}`;\r\n};\r\n\r\nexport const formatTimeline = (\r\n    character: Character,\r\n    timeline: Cast[]\r\n) => `# ${character.name}'s Home Timeline\r\n${timeline.map(formatCast).join(\"\\n\")}\r\n`;\r\n\r\nexport const headerTemplate = `\r\n{{timeline}}\r\n\r\n# Knowledge\r\n{{knowledge}}\r\n\r\nAbout {{agentName}} (@{{farcasterUsername}}):\r\n{{bio}}\r\n{{lore}}\r\n{{postDirections}}\r\n\r\n{{providers}}\r\n\r\n{{recentPosts}}\r\n\r\n{{characterPostExamples}}`;\r\n\r\nexport const postTemplate =\r\n    headerTemplate +\r\n    `\r\n# Task: Generate a post in the voice and style of {{agentName}}, aka @{{farcasterUsername}}\r\nWrite a single sentence post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}.\r\nTry to write something totally different than previous posts. Do not add commentary or ackwowledge this request, just write the post.\r\n\r\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.`;\r\n\r\nexport const messageHandlerTemplate =\r\n    headerTemplate +\r\n    `\r\nRecent interactions between {{agentName}} and other users:\r\n{{recentPostInteractions}}\r\n\r\nThread of casts You Are Replying To:\r\n{{formattedConversation}}\r\n\r\n# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{farcasterUsername}}):\r\n{{currentPost}}` +\r\n    messageCompletionFooter;\r\n\r\nexport const shouldRespondTemplate =\r\n    //\r\n    `# Task: Decide if {{agentName}} should respond.\r\n    About {{agentName}}:\r\n    {{bio}}\r\n\r\n    # INSTRUCTIONS: Determine if {{agentName}} (@{{farcasterUsername}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\r\n\r\nResponse options are RESPOND, IGNORE and STOP.\r\n\r\n{{agentName}} should respond to messages that are directed at them, or participate in conversations that are interesting or relevant to their background, IGNORE messages that are irrelevant to them, and should STOP if the conversation is concluded.\r\n\r\n{{agentName}} is in a room with other users and wants to be conversational, but not annoying.\r\n{{agentName}} should RESPOND to messages that are directed at them, or participate in conversations that are interesting or relevant to their background.\r\nIf a message is not interesting or relevant, {{agentName}} should IGNORE.\r\nIf a message thread has become repetitive, {{agentName}} should IGNORE.\r\nUnless directly RESPONDing to a user, {{agentName}} should IGNORE messages that are very short or do not contain much information.\r\nIf a user asks {{agentName}} to stop talking, {{agentName}} should STOP.\r\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, {{agentName}} should STOP.\r\n\r\nIMPORTANT: {{agentName}} (aka @{{farcasterUsername}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\r\n\r\nThread of messages You Are Replying To:\r\n{{formattedConversation}}\r\n\r\nCurrent message:\r\n{{currentPost}}\r\n\r\n` + shouldRespondFooter;\r\n","import { stringToUuid } from \"@elizaos/core\";\r\n\r\nexport const MAX_CAST_LENGTH = 1024; // Updated to Twitter's current character limit\r\n\r\nexport function castId({ hash, agentId }: { hash: string; agentId: string }) {\r\n    return `${hash}-${agentId}`;\r\n}\r\n\r\nexport function castUuid(props: { hash: string; agentId: string }) {\r\n    return stringToUuid(castId(props));\r\n}\r\n\r\nexport function splitPostContent(\r\n    content: string,\r\n    maxLength: number = MAX_CAST_LENGTH\r\n): string[] {\r\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\r\n    const posts: string[] = [];\r\n    let currentTweet = \"\";\r\n\r\n    for (const paragraph of paragraphs) {\r\n        if (!paragraph) continue;\r\n\r\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\r\n            if (currentTweet) {\r\n                currentTweet += \"\\n\\n\" + paragraph;\r\n            } else {\r\n                currentTweet = paragraph;\r\n            }\r\n        } else {\r\n            if (currentTweet) {\r\n                posts.push(currentTweet.trim());\r\n            }\r\n            if (paragraph.length <= maxLength) {\r\n                currentTweet = paragraph;\r\n            } else {\r\n                // Split long paragraph into smaller chunks\r\n                const chunks = splitParagraph(paragraph, maxLength);\r\n                posts.push(...chunks.slice(0, -1));\r\n                currentTweet = chunks[chunks.length - 1];\r\n            }\r\n        }\r\n    }\r\n\r\n    if (currentTweet) {\r\n        posts.push(currentTweet.trim());\r\n    }\r\n\r\n    return posts;\r\n}\r\n\r\nexport function splitParagraph(paragraph: string, maxLength: number): string[] {\r\n    const sentences = paragraph.match(/[^\\.!\\?]+[\\.!\\?]+|[^\\.!\\?]+$/g) || [\r\n        paragraph,\r\n    ];\r\n    const chunks: string[] = [];\r\n    let currentChunk = \"\";\r\n\r\n    for (const sentence of sentences) {\r\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\r\n            if (currentChunk) {\r\n                currentChunk += \" \" + sentence;\r\n            } else {\r\n                currentChunk = sentence;\r\n            }\r\n        } else {\r\n            if (currentChunk) {\r\n                chunks.push(currentChunk.trim());\r\n            }\r\n            if (sentence.length <= maxLength) {\r\n                currentChunk = sentence;\r\n            } else {\r\n                // Split long sentence into smaller pieces\r\n                const words = sentence.split(\" \");\r\n                currentChunk = \"\";\r\n                for (const word of words) {\r\n                    if (\r\n                        (currentChunk + \" \" + word).trim().length <= maxLength\r\n                    ) {\r\n                        if (currentChunk) {\r\n                            currentChunk += \" \" + word;\r\n                        } else {\r\n                            currentChunk = word;\r\n                        }\r\n                    } else {\r\n                        if (currentChunk) {\r\n                            chunks.push(currentChunk.trim());\r\n                        }\r\n                        currentChunk = word;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (currentChunk) {\r\n        chunks.push(currentChunk.trim());\r\n    }\r\n\r\n    return chunks;\r\n}\r\n\r\nexport function populateMentions(\r\n    text: string,\r\n    userIds: number[],\r\n    positions: number[],\r\n    userMap: Record<number, string>\r\n) {\r\n    // Validate input arrays have same length\r\n    if (userIds.length !== positions.length) {\r\n        throw new Error(\r\n            \"User IDs and positions arrays must have the same length\"\r\n        );\r\n    }\r\n\r\n    // Create array of mention objects with position and user info\r\n    const mentions = userIds\r\n        .map((userId, index) => ({\r\n            position: positions[index],\r\n            userId,\r\n            displayName: userMap[userId]!,\r\n        }))\r\n        .sort((a, b) => b.position - a.position); // Sort in reverse order to prevent position shifting\r\n\r\n    // Create the resulting string by inserting mentions\r\n    let result = text;\r\n    mentions.forEach((mention) => {\r\n        const mentionText = `@${mention.displayName}`;\r\n        result =\r\n            result.slice(0, mention.position) +\r\n            mentionText +\r\n            result.slice(mention.position);\r\n    });\r\n\r\n    return result;\r\n}\r\n","import {\r\n    elizaLogger,\r\n    getEmbeddingZeroVector,\r\n    IAgentRuntime,\r\n    stringToUuid,\r\n    type Memory,\r\n    type UUID,\r\n} from \"@elizaos/core\";\r\nimport type { Cast } from \"./types\";\r\nimport { toHex } from \"viem\";\r\nimport { castUuid } from \"./utils\";\r\nimport { FarcasterClient } from \"./client\";\r\n\r\nexport function createCastMemory({\r\n    roomId,\r\n    runtime,\r\n    cast,\r\n}: {\r\n    roomId: UUID;\r\n    runtime: IAgentRuntime;\r\n    cast: Cast;\r\n}): Memory {\r\n    const inReplyTo = cast.inReplyTo\r\n        ? castUuid({\r\n              hash: toHex(cast.inReplyTo.hash),\r\n              agentId: runtime.agentId,\r\n          })\r\n        : undefined;\r\n\r\n    return {\r\n        id: castUuid({\r\n            hash: cast.hash,\r\n            agentId: runtime.agentId,\r\n        }),\r\n        agentId: runtime.agentId,\r\n        userId: runtime.agentId,\r\n        content: {\r\n            text: cast.text,\r\n            source: \"farcaster\",\r\n            url: \"\",\r\n            inReplyTo,\r\n            hash: cast.hash,\r\n        },\r\n        roomId,\r\n        embedding: getEmbeddingZeroVector(),\r\n    };\r\n}\r\n\r\nexport async function buildConversationThread({\r\n    cast,\r\n    runtime,\r\n    client,\r\n}: {\r\n    cast: Cast;\r\n    runtime: IAgentRuntime;\r\n    client: FarcasterClient;\r\n}): Promise<Cast[]> {\r\n    const thread: Cast[] = [];\r\n    const visited: Set<string> = new Set();\r\n    async function processThread(currentCast: Cast) {\r\n        if (visited.has(currentCast.hash)) {\r\n            return;\r\n        }\r\n\r\n        visited.add(currentCast.hash);\r\n\r\n        const roomId = castUuid({\r\n            hash: currentCast.hash,\r\n            agentId: runtime.agentId,\r\n        });\r\n\r\n        // Check if the current cast has already been saved\r\n        const memory = await runtime.messageManager.getMemoryById(roomId);\r\n\r\n        if (!memory) {\r\n            elizaLogger.log(\"Creating memory for cast\", currentCast.hash);\r\n\r\n            const userId = stringToUuid(currentCast.profile.username);\r\n\r\n            await runtime.ensureConnection(\r\n                userId,\r\n                roomId,\r\n                currentCast.profile.username,\r\n                currentCast.profile.name,\r\n                \"farcaster\"\r\n            );\r\n\r\n            await runtime.messageManager.createMemory(\r\n                createCastMemory({\r\n                    roomId,\r\n                    runtime,\r\n                    cast: currentCast,\r\n                })\r\n            );\r\n        }\r\n\r\n        thread.unshift(currentCast);\r\n\r\n        if (currentCast.inReplyTo) {\r\n            const parentCast = await client.getCast(currentCast.inReplyTo.hash);\r\n            await processThread(parentCast);\r\n        }\r\n    }\r\n\r\n    await processThread(cast);\r\n    return thread;\r\n}\r\n","import type { FarcasterClient } from \"./client\";\r\nimport type { Content, IAgentRuntime, Memory, UUID } from \"@elizaos/core\";\r\nimport type { Cast, CastId, Profile } from \"./types\";\r\nimport { createCastMemory } from \"./memory\";\r\nimport { splitPostContent } from \"./utils\";\r\n\r\nexport async function sendCast({\r\n    client,\r\n    runtime,\r\n    content,\r\n    roomId,\r\n    inReplyTo,\r\n    profile,\r\n}: {\r\n    profile: Profile;\r\n    client: FarcasterClient;\r\n    runtime: IAgentRuntime;\r\n    content: Content;\r\n    roomId: UUID;\r\n    signerUuid: string;\r\n    inReplyTo?: CastId;\r\n}): Promise<{ memory: Memory; cast: Cast }[]> {\r\n    const chunks = splitPostContent(content.text);\r\n    const sent: Cast[] = [];\r\n    let parentCastId = inReplyTo;\r\n\r\n    for (const chunk of chunks) {\r\n        const neynarCast = await client.publishCast(chunk, parentCastId);\r\n\r\n        if (neynarCast) {\r\n            const cast: Cast = {\r\n                hash: neynarCast.hash,\r\n                authorFid: neynarCast.authorFid,\r\n                text: neynarCast.text,\r\n                profile,\r\n                inReplyTo: parentCastId,\r\n                timestamp: new Date(),\r\n            };\r\n\r\n            sent.push(cast!);\r\n\r\n            parentCastId = {\r\n                fid: neynarCast?.authorFid!,\r\n                hash: neynarCast?.hash!,\r\n            };\r\n        }\r\n    }\r\n\r\n    return sent.map((cast) => ({\r\n        cast,\r\n        memory: createCastMemory({\r\n            roomId,\r\n            runtime,\r\n            cast,\r\n        }),\r\n    }));\r\n}\r\n","import {\r\n    composeContext,\r\n    generateMessageResponse,\r\n    generateShouldRespond,\r\n    Memory,\r\n    ModelClass,\r\n    stringToUuid,\r\n    elizaLogger,\r\n    HandlerCallback,\r\n    Content,\r\n    type IAgentRuntime,\r\n} from \"@elizaos/core\";\r\nimport type { FarcasterClient } from \"./client\";\r\nimport { toHex } from \"viem\";\r\nimport { buildConversationThread, createCastMemory } from \"./memory\";\r\nimport { Cast, Profile } from \"./types\";\r\nimport {\r\n    formatCast,\r\n    formatTimeline,\r\n    messageHandlerTemplate,\r\n    shouldRespondTemplate,\r\n} from \"./prompts\";\r\nimport { castUuid } from \"./utils\";\r\nimport { sendCast } from \"./actions\";\r\n\r\nexport class FarcasterInteractionManager {\r\n    private timeout: NodeJS.Timeout | undefined;\r\n    constructor(\r\n        public client: FarcasterClient,\r\n        public runtime: IAgentRuntime,\r\n        private signerUuid: string,\r\n        public cache: Map<string, any>\r\n    ) {}\r\n\r\n    public async start() {\r\n        const handleInteractionsLoop = async () => {\r\n            try {\r\n                await this.handleInteractions();\r\n            } catch (error) {\r\n                elizaLogger.error(error);\r\n                return;\r\n            }\r\n\r\n            this.timeout = setTimeout(\r\n                handleInteractionsLoop,\r\n                Number(\r\n                    this.runtime.getSetting(\"FARCASTER_POLL_INTERVAL\") || 120\r\n                ) * 1000 // Default to 2 minutes\r\n            );\r\n        };\r\n\r\n        handleInteractionsLoop();\r\n    }\r\n\r\n    public async stop() {\r\n        if (this.timeout) clearTimeout(this.timeout);\r\n    }\r\n\r\n    private async handleInteractions() {\r\n        const agentFid = Number(this.runtime.getSetting(\"FARCASTER_FID\"));\r\n\r\n        const mentions = await this.client.getMentions({\r\n            fid: agentFid,\r\n            pageSize: 10,\r\n        });\r\n\r\n        const agent = await this.client.getProfile(agentFid);\r\n        for (const mention of mentions) {\r\n            const messageHash = toHex(mention.hash);\r\n            const conversationId = `${messageHash}-${this.runtime.agentId}`;\r\n            const roomId = stringToUuid(conversationId);\r\n            const userId = stringToUuid(mention.authorFid.toString());\r\n\r\n            const pastMemoryId = castUuid({\r\n                agentId: this.runtime.agentId,\r\n                hash: mention.hash,\r\n            });\r\n\r\n            const pastMemory =\r\n                await this.runtime.messageManager.getMemoryById(pastMemoryId);\r\n\r\n            if (pastMemory) {\r\n                continue;\r\n            }\r\n\r\n            await this.runtime.ensureConnection(\r\n                userId,\r\n                roomId,\r\n                mention.profile.username,\r\n                mention.profile.name,\r\n                \"farcaster\"\r\n            );\r\n\r\n            const thread = await buildConversationThread({\r\n                client: this.client,\r\n                runtime: this.runtime,\r\n                cast: mention,\r\n            });\r\n\r\n            const memory: Memory = {\r\n                content: { text: mention.text, hash: mention.hash },\r\n                agentId: this.runtime.agentId,\r\n                userId,\r\n                roomId,\r\n            };\r\n\r\n            await this.handleCast({\r\n                agent,\r\n                cast: mention,\r\n                memory,\r\n                thread,\r\n            });\r\n        }\r\n\r\n        this.client.lastInteractionTimestamp = new Date();\r\n    }\r\n\r\n    private async handleCast({\r\n        agent,\r\n        cast,\r\n        memory,\r\n        thread,\r\n    }: {\r\n        agent: Profile;\r\n        cast: Cast;\r\n        memory: Memory;\r\n        thread: Cast[];\r\n    }) {\r\n        if (cast.profile.fid === agent.fid) {\r\n            elizaLogger.info(\"skipping cast from bot itself\", cast.hash);\r\n            return;\r\n        }\r\n\r\n        if (!memory.content.text) {\r\n            elizaLogger.info(\"skipping cast with no text\", cast.hash);\r\n            return { text: \"\", action: \"IGNORE\" };\r\n        }\r\n\r\n        const currentPost = formatCast(cast);\r\n\r\n        const { timeline } = await this.client.getTimeline({\r\n            fid: agent.fid,\r\n            pageSize: 10,\r\n        });\r\n\r\n        const formattedTimeline = formatTimeline(\r\n            this.runtime.character,\r\n            timeline\r\n        );\r\n\r\n        const formattedConversation = thread\r\n            .map(\r\n                (cast) => `@${cast.profile.username} (${new Date(\r\n                    cast.timestamp\r\n                ).toLocaleString(\"en-US\", {\r\n                    hour: \"2-digit\",\r\n                    minute: \"2-digit\",\r\n                    month: \"short\",\r\n                    day: \"numeric\",\r\n                })}):\r\n                ${cast.text}`\r\n            )\r\n            .join(\"\\n\\n\");\r\n\r\n        const state = await this.runtime.composeState(memory, {\r\n            farcasterUsername: agent.username,\r\n            timeline: formattedTimeline,\r\n            currentPost,\r\n            formattedConversation,\r\n        });\r\n\r\n        const shouldRespondContext = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.farcasterShouldRespondTemplate ||\r\n                this.runtime.character?.templates?.shouldRespondTemplate ||\r\n                shouldRespondTemplate,\r\n        });\r\n\r\n        const memoryId = castUuid({\r\n            agentId: this.runtime.agentId,\r\n            hash: cast.hash,\r\n        });\r\n\r\n        const castMemory =\r\n            await this.runtime.messageManager.getMemoryById(memoryId);\r\n\r\n        if (!castMemory) {\r\n            await this.runtime.messageManager.createMemory(\r\n                createCastMemory({\r\n                    roomId: memory.roomId,\r\n                    runtime: this.runtime,\r\n                    cast,\r\n                })\r\n            );\r\n        }\r\n\r\n        const shouldRespondResponse = await generateShouldRespond({\r\n            runtime: this.runtime,\r\n            context: shouldRespondContext,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        if (\r\n            shouldRespondResponse === \"IGNORE\" ||\r\n            shouldRespondResponse === \"STOP\"\r\n        ) {\r\n            elizaLogger.info(\r\n                `Not responding to cast because generated ShouldRespond was ${shouldRespondResponse}`\r\n            );\r\n            return;\r\n        }\r\n\r\n        const context = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.farcasterMessageHandlerTemplate ??\r\n                this.runtime.character?.templates?.messageHandlerTemplate ??\r\n                messageHandlerTemplate,\r\n        });\r\n\r\n        const responseContent = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        responseContent.inReplyTo = memoryId;\r\n\r\n        if (!responseContent.text) return;\r\n\r\n        if (this.runtime.getSetting(\"FARCASTER_DRY_RUN\") === \"true\") {\r\n            elizaLogger.info(\r\n                `Dry run: would have responded to cast ${cast.hash} with ${responseContent.text}`\r\n            );\r\n            return;\r\n        }\r\n\r\n        const callback: HandlerCallback = async (\r\n            content: Content,\r\n            files: any[]\r\n        ) => {\r\n            try {\r\n                if (memoryId && !content.inReplyTo) {\r\n                    content.inReplyTo = memoryId;\r\n                }\r\n                const results = await sendCast({\r\n                    runtime: this.runtime,\r\n                    client: this.client,\r\n                    signerUuid: this.signerUuid,\r\n                    profile: cast.profile,\r\n                    content: content,\r\n                    roomId: memory.roomId,\r\n                    inReplyTo: {\r\n                        fid: cast.authorFid,\r\n                        hash: cast.hash,\r\n                    },\r\n                });\r\n                // sendCast lost response action, so we need to add it back here\r\n                results[0].memory.content.action = content.action;\r\n\r\n                for (const { memory } of results) {\r\n                    await this.runtime.messageManager.createMemory(memory);\r\n                }\r\n                return results.map((result) => result.memory);\r\n            } catch (error) {\r\n                console.error(\"Error sending response cast:\", error);\r\n                return [];\r\n            }\r\n        };\r\n\r\n        const responseMessages = await callback(responseContent);\r\n\r\n        const newState = await this.runtime.updateRecentMessageState(state);\r\n\r\n        await this.runtime.processActions(\r\n            memory,\r\n            responseMessages,\r\n            newState,\r\n            callback\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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","names":["elizaLogger","stringToUuid","elizaLogger","elizaLogger","stringToUuid","elizaLogger","stringToUuid","elizaLogger","stringToUuid","composeContext","ModelClass","stringToUuid","elizaLogger","elizaLogger","stringToUuid","cast","composeContext","ModelClass","memory","NeynarAPIClient","elizaLogger"]}