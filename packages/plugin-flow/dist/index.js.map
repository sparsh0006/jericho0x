{"version":3,"sources":["../src/environment.ts","../src/assets/cadence/scripts/evm/call.cdc","../src/assets/cadence/scripts/evm/erc20/balance_of.cdc","../src/assets/cadence/scripts/evm/erc20/get_decimals.cdc","../src/assets/cadence/scripts/evm/erc20/total_supply.cdc","../src/assets/cadence/scripts/main-account/get_acct_info.cdc","../src/assets/script.defs.ts","../src/assets/cadence/transactions/evm/call.cdc","../src/assets/cadence/transactions/main-account/account/create_new_account_with_coa.cdc","../src/assets/cadence/transactions/main-account/account/setup_coa.cdc","../src/assets/cadence/transactions/main-account/evm/transfer_erc20.cdc","../src/assets/cadence/transactions/main-account/flow-token/dynamic_vm_transfer.cdc","../src/assets/cadence/transactions/main-account/ft/generic_transfer_with_address.cdc","../src/assets/transaction.defs.ts","../src/queries.ts","../src/providers/connector.provider.ts","../src/providers/utils/flow.connector.ts","../src/types/exception.ts","../flow.json","../src/providers/wallet.provider.ts","../src/providers/utils/pure.signer.ts","../src/actions/transfer.ts","../src/templates/index.ts","../src/index.ts"],"sourcesContent":["import { IAgentRuntime } from \"@elizaos/core\";\r\nimport { z } from \"zod\";\r\n\r\nconst FLOW_MAINNET_PUBLIC_RPC = \"https://mainnet.onflow.org\";\r\n\r\nexport const flowEnvSchema = z.object({\r\n    FLOW_ADDRESS: z\r\n        .string()\r\n        .min(1, \"Flow native address is required\")\r\n        .startsWith(\"0x\", \"Flow address must start with 0x\"),\r\n    FLOW_PRIVATE_KEY: z\r\n        .string()\r\n        .min(1, \"Flow private key for the address is required\")\r\n        .startsWith(\"0x\", \"Flow private key must start with 0x\"),\r\n    FLOW_NETWORK: z.string().optional().default(\"mainnet\"),\r\n    FLOW_ENDPOINT_URL: z.string().optional().default(FLOW_MAINNET_PUBLIC_RPC),\r\n});\r\n\r\nexport type FlowConfig = z.infer<typeof flowEnvSchema>;\r\n\r\nexport async function validateFlowConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<FlowConfig> {\r\n    try {\r\n        const config = {\r\n            FLOW_ADDRESS:\r\n                runtime.getSetting(\"FLOW_ADDRESS\") || process.env.FLOW_ADDRESS,\r\n            FLOW_PRIVATE_KEY:\r\n                runtime.getSetting(\"FLOW_PRIVATE_KEY\") ||\r\n                process.env.FLOW_PRIVATE_KEY,\r\n            FLOW_NETWORK:\r\n                runtime.getSetting(\"FLOW_NETWORK\") ||\r\n                process.env.FLOW_NETWORK ||\r\n                \"mainnet\",\r\n            FLOW_ENDPOINT_URL:\r\n                runtime.getSetting(\"FLOW_ENDPOINT_URL\") ||\r\n                process.env.FLOW_ENDPOINT_URL ||\r\n                FLOW_MAINNET_PUBLIC_RPC,\r\n        };\r\n\r\n        return flowEnvSchema.parse(config);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `Flow Blockchain configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n","import \"EVM\"\r\n\r\naccess(all) fun getTypeArray(_ identifiers: [String]): [Type] {\r\n    var types: [Type] = []\r\n    for identifier in identifiers {\r\n        let type = CompositeType(identifier)\r\n            ?? panic(\"Invalid identifier: \".concat(identifier))\r\n        types.append(type)\r\n    }\r\n    return types\r\n}\r\n\r\n/// Supports generic calls to EVM contracts that might have return values\r\n///\r\naccess(all) fun main(\r\n    gatewayAddress: Address,\r\n    evmContractAddressHex: String,\r\n    calldata: String,\r\n    gasLimit: UInt64,\r\n    typeIdentifiers: [String]\r\n): [AnyStruct] {\r\n\r\n    let evmAddress = EVM.addressFromString(evmContractAddressHex)\r\n\r\n    let data = calldata.decodeHex()\r\n\r\n    let gatewayCOA = getAuthAccount<auth(BorrowValue) &Account>(gatewayAddress)\r\n        .storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(\r\n            from: /storage/evm\r\n        ) ?? panic(\"Could not borrow COA from provided gateway address\")\r\n\r\n    let evmResult = gatewayCOA.call(\r\n        to: evmAddress,\r\n        data: data,\r\n        gasLimit: gasLimit,\r\n        value: EVM.Balance(attoflow: 0)\r\n    )\r\n\r\n    return EVM.decodeABI(types: getTypeArray(typeIdentifiers), data: evmResult.data)\r\n}\r\n","import \"EVM\"\r\n\r\nimport \"FlowEVMBridgeUtils\"\r\n\r\n/// Returns the balance of the owner (hex-encoded EVM address) of a given ERC20 fungible token defined\r\n/// at the hex-encoded EVM contract address\r\n///\r\n/// @param owner: The hex-encoded EVM address of the owner\r\n/// @param evmContractAddress: The hex-encoded EVM contract address of the ERC20 contract\r\n///\r\n/// @return The balance of the address, reverting if the given contract address does not implement the ERC20 method\r\n///     \"balanceOf(address)(uint256)\"\r\n///\r\naccess(all) fun main(owner: String, evmContractAddress: String): UInt256 {\r\n    return FlowEVMBridgeUtils.balanceOf(\r\n        owner: EVM.addressFromString(owner),\r\n        evmContractAddress: EVM.addressFromString(evmContractAddress)\r\n    )\r\n}\r\n","import \"EVM\"\r\n\r\nimport \"FlowEVMBridgeUtils\"\r\n\r\naccess(all)\r\nfun main(erc20ContractAddressHex: String): UInt8 {\r\n    return FlowEVMBridgeUtils.getTokenDecimals(\r\n        evmContractAddress: EVM.addressFromString(erc20ContractAddressHex)\r\n    )\r\n}\r\n","import \"EVM\"\r\n\r\nimport \"FlowEVMBridgeUtils\"\r\n\r\n/// Retrieves the total supply of the ERC20 contract at the given EVM contract address. Reverts on EVM call failure.\r\n///\r\n/// @param evmContractAddress: The EVM contract address to retrieve the total supply from\r\n///\r\n/// @return the total supply of the ERC20\r\n///\r\naccess(all) fun main(evmContractAddressHex: String): UInt256 {\r\n    return FlowEVMBridgeUtils.totalSupply(\r\n        evmContractAddress: EVM.addressFromString(evmContractAddressHex)\r\n    )\r\n}\r\n","import \"FungibleToken\"\r\nimport \"EVM\"\r\n\r\n/// Returns the hex encoded address of the COA in the given Flow address\r\n///\r\naccess(all) fun main(flowAddress: Address): AccountInfo {\r\n    var flowBalance: UFix64 = 0.0\r\n    if let flowVaultRef = getAccount(flowAddress)\r\n        .capabilities.get<&{FungibleToken.Balance}>(/public/flowTokenBalance)\r\n        .borrow() {\r\n        flowBalance = flowVaultRef.balance\r\n    }\r\n\r\n    var coaAddress: String? = nil\r\n    var coaBalance: UFix64? = nil\r\n\r\n    if let address: EVM.EVMAddress = getAuthAccount<auth(BorrowValue) &Account>(flowAddress)\r\n        .storage.borrow<&EVM.CadenceOwnedAccount>(from: /storage/evm)?.address() {\r\n        let bytes: [UInt8] = []\r\n        for byte in address.bytes {\r\n            bytes.append(byte)\r\n        }\r\n        coaAddress = String.encodeHex(bytes)\r\n        coaBalance = address.balance().inFLOW()\r\n    }\r\n    return AccountInfo(\r\n        flowAddress,\r\n        flowBalance,\r\n        coaAddress,\r\n        coaBalance\r\n    )\r\n}\r\n\r\naccess(all) struct AccountInfo {\r\n    access(all) let address: Address\r\n    access(all) let balance: UFix64\r\n    access(all) let coaAddress: String?\r\n    access(all) let coaBalance: UFix64?\r\n\r\n    init(\r\n        _ address: Address,\r\n        _ balance: UFix64,\r\n        _ coaAddress: String?,\r\n        _ coaBalance: UFix64?\r\n    ) {\r\n        self.address = address\r\n        self.balance = balance\r\n        self.coaAddress = coaAddress\r\n        self.coaBalance = coaBalance\r\n    }\r\n}\r\n","// Source:\r\n//\r\n// This file contains the definitions of the Cadence scripts used in the plugin.\r\n// The scripts are defined as strings and exported as a dictionary.\r\n\r\n// Scripts for EVM\r\nimport evmCall from \"./cadence/scripts/evm/call.cdc?raw\";\r\nimport evmERC20BalanceOf from \"./cadence/scripts/evm/erc20/balance_of.cdc?raw\";\r\nimport evmERC20GetDecimals from \"./cadence/scripts/evm/erc20/get_decimals.cdc?raw\";\r\nimport evmERC20GetTotalSupply from \"./cadence/scripts/evm/erc20/total_supply.cdc?raw\";\r\n\r\n// Scripts for main account\r\nimport mainGetAccountInfo from \"./cadence/scripts/main-account/get_acct_info.cdc?raw\";\r\n\r\nexport const scripts = {\r\n    evmCall,\r\n    evmERC20BalanceOf,\r\n    evmERC20GetDecimals,\r\n    evmERC20GetTotalSupply,\r\n    mainGetAccountInfo,\r\n};\r\n","import \"EVM\"\r\n\r\n/// Executes the calldata from the signer's COA\r\n///\r\ntransaction(evmContractAddressHex: String, calldata: String, gasLimit: UInt64, value: UFix64) {\r\n\r\n    let evmAddress: EVM.EVMAddress\r\n    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount\r\n\r\n    prepare(signer: auth(BorrowValue) &Account) {\r\n        self.evmAddress = EVM.addressFromString(evmContractAddressHex)\r\n\r\n        let storagePath = StoragePath(identifier: \"evm\")!\r\n        let publicPath = PublicPath(identifier: \"evm\")!\r\n\r\n        // Reference signer's COA if one exists\r\n        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: storagePath)\r\n        if coa == nil {\r\n            let coa <- EVM.createCadenceOwnedAccount()\r\n            signer.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)\r\n            let addressableCap = signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)\r\n            signer.capabilities.unpublish(publicPath)\r\n            signer.capabilities.publish(addressableCap, at: publicPath)\r\n        }\r\n\r\n        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: storagePath)\r\n            ?? panic(\"Could not borrow COA from provided gateway address\")\r\n    }\r\n\r\n    execute {\r\n        let valueBalance = EVM.Balance(attoflow: 0)\r\n        valueBalance.setFLOW(flow: value)\r\n        let callResult = self.coa.call(\r\n            to: self.evmAddress,\r\n            data: calldata.decodeHex(),\r\n            gasLimit: gasLimit,\r\n            value: valueBalance\r\n        )\r\n        assert(callResult.status == EVM.Status.successful, message: \"Call failed\")\r\n    }\r\n}\r\n","import Crypto\r\n\r\nimport \"EVM\"\r\n\r\n/// Creates a new Flow Address with a single full-weight key and its EVM account, which is\r\n/// a Cadence Owned Account (COA) stored in the account's storage.\r\n///\r\ntransaction(\r\n    key: String,  // key to be used for the account\r\n    signatureAlgorithm: UInt8, // signature algorithm to be used for the account\r\n    hashAlgorithm: UInt8, // hash algorithm to be used for the account\r\n) {\r\n    let auth: auth(BorrowValue) &Account\r\n\r\n    prepare(signer: auth(BorrowValue) &Account) {\r\n        pre {\r\n            signatureAlgorithm == 1 || signatureAlgorithm == 2:\r\n                \"Cannot add Key: Must provide a signature algorithm raw value that corresponds to \"\r\n                .concat(\"one of the available signature algorithms for Flow keys.\")\r\n                .concat(\"You provided \").concat(signatureAlgorithm.toString())\r\n                .concat(\" but the options are either 1 (ECDSA_P256), 2 (ECDSA_secp256k1).\")\r\n            hashAlgorithm == 1 || hashAlgorithm == 3:\r\n                \"Cannot add Key: Must provide a hash algorithm raw value that corresponds to \"\r\n                .concat(\"one of of the available hash algorithms for Flow keys.\")\r\n                .concat(\"You provided \").concat(hashAlgorithm.toString())\r\n                .concat(\" but the options are 1 (SHA2_256), 3 (SHA3_256).\")\r\n        }\r\n\r\n        self.auth = signer\r\n    }\r\n\r\n    execute {\r\n        // Create a new public key\r\n        let publicKey = PublicKey(\r\n            publicKey: key.decodeHex(),\r\n            signatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!\r\n        )\r\n\r\n        // Create a new account\r\n        let account = Account(payer: self.auth)\r\n\r\n        // Add the public key to the account\r\n        account.keys.add(\r\n            publicKey: publicKey,\r\n            hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!,\r\n            weight: 1000.0\r\n        )\r\n\r\n        // Create a new COA\r\n        let coa <- EVM.createCadenceOwnedAccount()\r\n\r\n        // Save the COA to the new account\r\n        let storagePath = StoragePath(identifier: \"evm\")!\r\n        let publicPath = PublicPath(identifier: \"evm\")!\r\n        account.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)\r\n        let addressableCap = account.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)\r\n        account.capabilities.unpublish(publicPath)\r\n        account.capabilities.publish(addressableCap, at: publicPath)\r\n    }\r\n}\r\n","import \"EVM\"\r\nimport \"FungibleToken\"\r\nimport \"FlowToken\"\r\n\r\n/// Creates a COA and saves it in the signer's Flow account & passing the given value of Flow into FlowEVM\r\n///\r\ntransaction() {\r\n\r\n    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {\r\n        let storagePath = StoragePath(identifier: \"evm\")!\r\n        let publicPath = PublicPath(identifier: \"evm\")!\r\n\r\n        // Reference signer's COA if one exists\r\n        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: storagePath)\r\n        if coa == nil {\r\n            let coa <- EVM.createCadenceOwnedAccount()\r\n            signer.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)\r\n            let addressableCap = signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)\r\n            signer.capabilities.unpublish(publicPath)\r\n            signer.capabilities.publish(addressableCap, at: publicPath)\r\n        }\r\n    }\r\n}\r\n","import \"EVM\"\r\n\r\nimport \"FlowEVMBridgeUtils\"\r\n\r\n/// Executes a token transfer to the defined recipient address against the specified ERC20 contract.\r\n///\r\ntransaction(evmContractAddressHex: String, recipientAddressHex: String, amount: UInt256) {\r\n\r\n    let evmContractAddress: EVM.EVMAddress\r\n    let recipientAddress: EVM.EVMAddress\r\n    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount\r\n    let preBalance: UInt256\r\n    var postBalance: UInt256\r\n\r\n    prepare(signer: auth(BorrowValue) &Account) {\r\n        self.evmContractAddress = EVM.addressFromString(evmContractAddressHex)\r\n        self.recipientAddress = EVM.addressFromString(recipientAddressHex)\r\n\r\n        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)\r\n            ?? panic(\"Could not borrow CadenceOwnedAccount reference\")\r\n\r\n        self.preBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)\r\n        self.postBalance = 0\r\n    }\r\n\r\n    execute {\r\n        let calldata = EVM.encodeABIWithSignature(\"transfer(address,uint256)\", [self.recipientAddress, amount])\r\n        let callResult = self.coa.call(\r\n            to: self.evmContractAddress,\r\n            data: calldata,\r\n            gasLimit: 15_000_000,\r\n            value: EVM.Balance(attoflow: 0)\r\n        )\r\n        assert(callResult.status == EVM.Status.successful, message: \"Call to ERC20 contract failed\")\r\n        self.postBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)\r\n    }\r\n\r\n    post {\r\n        self.postBalance == self.preBalance - amount: \"Transfer failed\"\r\n    }\r\n}\r\n","import \"FungibleToken\"\r\nimport \"FlowToken\"\r\n\r\nimport \"EVM\"\r\n\r\n// Transfers $FLOW from the signer's account to the recipient's address, determining the target VM based on the format\r\n// of the recipient's hex address. Note that the sender's funds are sourced by default from the target VM, pulling any\r\n// difference from the alternate VM if available. e.g. Transfers to Flow addresses will first attempt to withdraw from\r\n// the signer's Flow vault, pulling any remaining funds from the signer's EVM account if available. Transfers to EVM\r\n// addresses will first attempt to withdraw from the signer's EVM account, pulling any remaining funds from the signer's\r\n// Flow vault if available. If the signer's balance across both VMs is insufficient, the transaction will revert.\r\n///\r\n/// @param addressString: The recipient's address in hex format - this should be either an EVM address or a Flow address\r\n/// @param amount: The amount of $FLOW to transfer as a UFix64 value\r\n///\r\ntransaction(addressString: String, amount: UFix64) {\r\n\r\n    let sentVault: @FlowToken.Vault\r\n    let evmRecipient: EVM.EVMAddress?\r\n    var receiver: &{FungibleToken.Receiver}?\r\n\r\n    prepare(signer: auth(BorrowValue, SaveValue) &Account) {\r\n        // Reference signer's COA if one exists\r\n        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: /storage/evm)\r\n\r\n        // Reference signer's FlowToken Vault\r\n        let sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\r\n            ?? panic(\"Could not borrow signer's FlowToken.Vault\")\r\n        let cadenceBalance = sourceVault.balance\r\n\r\n        // Define optional recipients for both VMs\r\n        self.receiver = nil\r\n        let cadenceRecipient = Address.fromString(addressString)\r\n        self.evmRecipient = cadenceRecipient == nil ? EVM.addressFromString(addressString) : nil\r\n        // Validate exactly one target address is assigned\r\n        if cadenceRecipient != nil && self.evmRecipient != nil {\r\n            panic(\"Malformed recipient address - assignable as both Cadence and EVM addresses\")\r\n        } else if cadenceRecipient == nil && self.evmRecipient == nil {\r\n            panic(\"Malformed recipient address - not assignable as either Cadence or EVM address\")\r\n        }\r\n\r\n        // Create empty FLOW vault to capture funds\r\n        self.sentVault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\r\n        /// If the target VM is Flow, does the Vault have sufficient balance to cover?\r\n        if cadenceRecipient != nil {\r\n            // Assign the Receiver of the $FLOW transfer\r\n            self.receiver = getAccount(cadenceRecipient!).capabilities.borrow<&{FungibleToken.Receiver}>(\r\n                    /public/flowTokenReceiver\r\n                ) ?? panic(\"Could not borrow reference to recipient's FungibleToken.Receiver\")\r\n\r\n            // Withdraw from the signer's Cadence Vault and deposit to sentVault\r\n            var withdrawAmount = amount < cadenceBalance ? amount : cadenceBalance\r\n            self.sentVault.deposit(from: <-sourceVault.withdraw(amount: withdrawAmount))\r\n\r\n            // If the cadence balance didn't cover the amount, check the signer's EVM balance\r\n            if amount > self.sentVault.balance {\r\n                let difference = amount - cadenceBalance\r\n                // Revert if the signer doesn't have an EVM account or EVM balance is insufficient\r\n                if coa == nil || difference < coa!.balance().inFLOW() {\r\n                    panic(\"Insufficient balance across Flow and EVM accounts\")\r\n                }\r\n\r\n                // Withdraw from the signer's EVM account and deposit to sentVault\r\n                let withdrawFromEVM = EVM.Balance(attoflow: 0)\r\n                withdrawFromEVM.setFLOW(flow: difference)\r\n                self.sentVault.deposit(from: <-coa!.withdraw(balance: withdrawFromEVM))\r\n            }\r\n        } else if self.evmRecipient != nil {\r\n            // Check signer's balance can cover the amount\r\n            if coa != nil {\r\n                // Determine the amount to withdraw from the signer's EVM account\r\n                let balance = coa!.balance()\r\n                let withdrawAmount = amount < balance.inFLOW() ? amount : balance.inFLOW()\r\n                balance.setFLOW(flow: withdrawAmount)\r\n\r\n                // Withdraw funds from EVM to the sentVault\r\n                self.sentVault.deposit(from: <-coa!.withdraw(balance: balance))\r\n            }\r\n            if amount > self.sentVault.balance {\r\n                // Insufficient amount withdrawn from EVM, check signer's Flow balance\r\n                let difference = amount - self.sentVault.balance\r\n                if difference > cadenceBalance {\r\n                    panic(\"Insufficient balance across Flow and EVM accounts\")\r\n                }\r\n                // Withdraw from the signer's Cadence Vault and deposit to sentVault\r\n                self.sentVault.deposit(from: <-sourceVault.withdraw(amount: difference))\r\n            }\r\n        }\r\n    }\r\n\r\n    pre {\r\n        self.sentVault.balance == amount: \"Attempting to send an incorrect amount of $FLOW\"\r\n    }\r\n\r\n    execute {\r\n        // Complete Cadence transfer if the FungibleToken Receiver is assigned\r\n        if self.receiver != nil {\r\n            self.receiver!.deposit(from: <-self.sentVault)\r\n        } else {\r\n            // Otherwise, complete EVM transfer\r\n            self.evmRecipient!.deposit(from: <-self.sentVault)\r\n        }\r\n    }\r\n}\r\n","import \"FungibleToken\"\r\nimport \"FungibleTokenMetadataViews\"\r\n\r\n#interaction (\r\n  version: \"1.0.0\",\r\n\ttitle: \"Generic FT Transfer with Contract Address and Name\",\r\n\tdescription: \"Transfer any Fungible Token by providing the contract address and name\",\r\n\tlanguage: \"en-US\",\r\n)\r\n\r\n/// Can pass in any contract address and name to transfer a token from that contract\r\n/// This lets you choose the token you want to send\r\n///\r\n/// Any contract can be chosen here, so wallets should check argument values\r\n/// to make sure the intended token contract name and address is passed in\r\n/// Contracts that are used must implement the FTVaultData Metadata View\r\n///\r\n/// Note: This transaction only will work for Fungible Tokens that\r\n///       have their token's resource name set as \"Vault\".\r\n///       Tokens with other names will need to use a different transaction\r\n///       that additionally specifies the identifier\r\n///\r\n/// @param amount: The amount of tokens to transfer\r\n/// @param to: The address to transfer the tokens to\r\n/// @param contractAddress: The address of the contract that defines the tokens being transferred\r\n/// @param contractName: The name of the contract that defines the tokens being transferred. Ex: \"FlowToken\"\r\n///\r\ntransaction(amount: UFix64, to: Address, contractAddress: Address, contractName: String) {\r\n\r\n    // The Vault resource that holds the tokens that are being transferred\r\n    let tempVault: @{FungibleToken.Vault}\r\n\r\n    // FTVaultData struct to get paths from\r\n    let vaultData: FungibleTokenMetadataViews.FTVaultData\r\n\r\n    prepare(signer: auth(BorrowValue) &Account) {\r\n\r\n        // Borrow a reference to the vault stored on the passed account at the passed publicPath\r\n        let resolverRef = getAccount(contractAddress)\r\n            .contracts.borrow<&{FungibleToken}>(name: contractName)\r\n                ?? panic(\"Could not borrow FungibleToken reference to the contract. Make sure the provided contract name (\"\r\n                          .concat(contractName).concat(\") and address (\").concat(contractAddress.toString()).concat(\") are correct!\"))\r\n\r\n        // Use that reference to retrieve the FTView\r\n        self.vaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?\r\n            ?? panic(\"Could not resolve FTVaultData view. The \".concat(contractName)\r\n                .concat(\" contract needs to implement the FTVaultData Metadata view in order to execute this transaction.\"))\r\n\r\n        // Get a reference to the signer's stored vault\r\n        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(from: self.vaultData.storagePath)\r\n\t\t\t?? panic(\"The signer does not store a FungibleToken.Provider object at the path \"\r\n                .concat(self.vaultData.storagePath.toString()).concat(\"For the \").concat(contractName)\r\n                .concat(\" contract at address \").concat(contractAddress.toString())\r\n                .concat(\". The signer must initialize their account with this object first!\"))\r\n\r\n        self.tempVault <- vaultRef.withdraw(amount: amount)\r\n\r\n        // Get the string representation of the address without the 0x\r\n        var addressString = contractAddress.toString()\r\n        if addressString.length == 18 {\r\n            addressString = addressString.slice(from: 2, upTo: 18)\r\n        }\r\n        let typeString: String = \"A.\".concat(addressString).concat(\".\").concat(contractName).concat(\".Vault\")\r\n        let type = CompositeType(typeString)\r\n        assert(\r\n            type != nil,\r\n            message: \"Could not create a type out of the contract name and address!\"\r\n        )\r\n\r\n        assert(\r\n            self.tempVault.getType() == type!,\r\n            message: \"The Vault that was withdrawn to transfer is not the type that was requested!\"\r\n        )\r\n    }\r\n\r\n    execute {\r\n        let recipient = getAccount(to)\r\n        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)\r\n            ?? panic(\"Could not borrow a Receiver reference to the FungibleToken Vault in account \"\r\n                .concat(to.toString()).concat(\" at path \").concat(self.vaultData.receiverPath.toString())\r\n                .concat(\". Make sure you are sending to an address that has \")\r\n                .concat(\"a FungibleToken Vault set up properly at the specified path.\"))\r\n\r\n        // Transfer tokens from the signer's stored vault to the receiver capability\r\n        receiverRef.deposit(from: <-self.tempVault)\r\n    }\r\n}\r\n","import evmCall from \"./cadence/transactions/evm/call.cdc\";\r\n// Transactions for main account\r\nimport mainAccountCreateNewWithCOA from \"./cadence/transactions/main-account/account/create_new_account_with_coa.cdc\";\r\nimport mainAccountSetupCOA from \"./cadence/transactions/main-account/account/setup_coa.cdc\";\r\nimport mainEVMTransferERC20 from \"./cadence/transactions/main-account/evm/transfer_erc20.cdc\";\r\nimport mainFlowTokenDynamicTransfer from \"./cadence/transactions/main-account/flow-token/dynamic_vm_transfer.cdc\";\r\nimport mainFTGenericTransfer from \"./cadence/transactions/main-account/ft/generic_transfer_with_address.cdc\";\r\n\r\nexport const transactions = {\r\n    evmCall,\r\n    mainAccountCreateNewWithCOA,\r\n    mainAccountSetupCOA,\r\n    mainEVMTransferERC20,\r\n    mainFlowTokenDynamicTransfer,\r\n    mainFTGenericTransfer,\r\n};\r\n","import { scripts } from \"./assets/script.defs\";\r\nimport { FlowAccountBalanceInfo, IFlowScriptExecutor } from \"./types\";\r\n\r\n/**\r\n * Query the balance of an EVM ERC20 token\r\n * @param executor\r\n * @param owner\r\n * @param evmContractAddress\r\n */\r\nexport async function queryEvmERC20BalanceOf(\r\n    executor: IFlowScriptExecutor,\r\n    owner: string,\r\n    evmContractAddress: string\r\n): Promise<bigint> {\r\n    const ret = await executor.executeScript(\r\n        scripts.evmERC20BalanceOf,\r\n        (arg, t) => [arg(owner, t.String), arg(evmContractAddress, t.String)],\r\n        BigInt(0)\r\n    );\r\n    return BigInt(ret);\r\n}\r\n\r\n/**\r\n * Query the decimals of an EVM ERC20 token\r\n * @param executor\r\n * @param evmContractAddress\r\n */\r\nexport async function queryEvmERC20Decimals(\r\n    executor: IFlowScriptExecutor,\r\n    evmContractAddress: string\r\n): Promise<number> {\r\n    const ret = await executor.executeScript(\r\n        scripts.evmERC20GetDecimals,\r\n        (arg, t) => [arg(evmContractAddress, t.String)],\r\n        \"0\"\r\n    );\r\n    return parseInt(ret);\r\n}\r\n\r\n/**\r\n * Query the total supply of an EVM ERC20 token\r\n * @param executor\r\n * @param evmContractAddress\r\n */\r\nexport async function queryEvmERC20TotalSupply(\r\n    executor: IFlowScriptExecutor,\r\n    evmContractAddress: string\r\n): Promise<bigint> {\r\n    const ret = await executor.executeScript(\r\n        scripts.evmERC20GetTotalSupply,\r\n        (arg, t) => [arg(evmContractAddress, t.String)],\r\n        BigInt(0)\r\n    );\r\n    return BigInt(ret);\r\n}\r\n\r\n/**\r\n * Query the account info of a Flow address\r\n * @param executor\r\n * @param address\r\n */\r\nexport async function queryAccountBalanceInfo(\r\n    executor: IFlowScriptExecutor,\r\n    address: string\r\n): Promise<FlowAccountBalanceInfo | undefined> {\r\n    const ret = await executor.executeScript(\r\n        scripts.mainGetAccountInfo,\r\n        (arg, t) => [arg(address, t.Address)],\r\n        undefined\r\n    );\r\n    if (!ret) {\r\n        return undefined;\r\n    }\r\n    return {\r\n        address: ret.address,\r\n        balance: parseFloat(ret.balance),\r\n        coaAddress: ret.coaAddress,\r\n        coaBalance: ret.coaBalance ? parseFloat(ret.coaBalance) : undefined,\r\n    };\r\n}\r\n","import {\r\n    elizaLogger,\r\n    IAgentRuntime,\r\n    Memory,\r\n    Provider,\r\n    State,\r\n} from \"@elizaos/core\";\r\n\r\nimport FlowConnector, { NetworkType } from \"./utils/flow.connector\";\r\n\r\n// Here is the configuration file for fixes.\r\nimport flowJSON from \"../../flow.json\" assert { type: \"json\" };\r\n\r\n// Singleton instance for the Flow connector\r\nlet _instance: FlowConnector;\r\n\r\n/**\r\n * Get the singleton instance of the Flow connector\r\n * @param runtime The runtime object\r\n */\r\nasync function _getDefaultConnectorInstance(\r\n    runtime: IAgentRuntime\r\n): Promise<FlowConnector> {\r\n    if (!_instance) {\r\n        _instance = await _createFlowConnector(runtime, flowJSON);\r\n    }\r\n    return _instance;\r\n}\r\n\r\n/**\r\n * Create a new instance of the Flow connector\r\n * @param runtime\r\n * @param flowJSON\r\n */\r\nasync function _createFlowConnector(\r\n    runtime: IAgentRuntime,\r\n    flowJSON: object\r\n): Promise<FlowConnector> {\r\n    const rpcEndpoint = runtime.getSetting(\"FLOW_ENDPOINT_URL\");\r\n    const network = runtime.getSetting(\"FLOW_NETWORK\") as NetworkType;\r\n    const instance = new FlowConnector(flowJSON, network, rpcEndpoint);\r\n    await instance.onModuleInit();\r\n    return instance;\r\n}\r\n\r\n/**\r\n * Get the singleton instance of the Flow connector\r\n * @param runtime\r\n */\r\nexport async function getFlowConnectorInstance(\r\n    runtime: IAgentRuntime,\r\n    inputedFlowJSON: { [key: string]: unknown } = undefined\r\n): Promise<FlowConnector> {\r\n    let connector: FlowConnector;\r\n    if (\r\n        inputedFlowJSON &&\r\n        typeof inputedFlowJSON === \"object\" &&\r\n        typeof inputedFlowJSON?.networks === \"object\" &&\r\n        typeof inputedFlowJSON?.dependencies === \"object\"\r\n    ) {\r\n        connector = await _createFlowConnector(runtime, inputedFlowJSON);\r\n    } else {\r\n        connector = await _getDefaultConnectorInstance(runtime);\r\n    }\r\n    return connector;\r\n}\r\n\r\n/**\r\n * Flow connector provider for AI agents\r\n */\r\nexport class FlowConnectorProvider {\r\n    constructor(private readonly instance: FlowConnector) {}\r\n\r\n    getConnectorStatus(runtime: IAgentRuntime): string {\r\n        let output = `Now user<${runtime.character.name}> connected to\\n`;\r\n        output += `Flow network: ${this.instance.network}\\n`;\r\n        output += `Flow Endpoint: ${this.instance.rpcEndpoint}\\n`;\r\n        return output;\r\n    }\r\n\r\n    // async getFormattedPortfolio(_runtime: IAgentRuntime): Promise<string> {\r\n    //     return Promise.resolve(this.getConnectorStatus(_runtime));\r\n    // }\r\n}\r\n\r\nconst flowConnectorProvider: Provider = {\r\n    get: async (\r\n        runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        _state?: State\r\n    ): Promise<string | null> => {\r\n        try {\r\n            const provider = new FlowConnectorProvider(\r\n                await getFlowConnectorInstance(runtime)\r\n            );\r\n            return provider.getConnectorStatus(runtime);\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Error in Flow connector provider:\",\r\n                error.message\r\n            );\r\n            return null;\r\n        }\r\n    },\r\n};\r\n\r\n// Module exports\r\nexport { flowConnectorProvider, FlowConnector };\r\n","import * as fcl from \"@onflow/fcl\";\r\nimport type { Account, TransactionStatus } from \"@onflow/typedefs\";\r\nimport { IFlowScriptExecutor } from \"../../types\";\r\nimport Exception from \"../../types/exception\";\r\n\r\nexport type NetworkType = \"mainnet\" | \"testnet\" | \"emulator\";\r\n\r\nlet isGloballyInited = false;\r\nlet globallyPromise = null;\r\n\r\nexport class FlowConnector implements IFlowScriptExecutor {\r\n    /**\r\n     * Initialize the Flow SDK\r\n     */\r\n    constructor(\r\n        private readonly flowJSON: object,\r\n        public readonly network: NetworkType = \"mainnet\",\r\n        private readonly defaultRpcEndpoint: string = undefined\r\n    ) {}\r\n\r\n    /**\r\n     * Get the RPC endpoint\r\n     */\r\n    get rpcEndpoint() {\r\n        switch (this.network) {\r\n            case \"mainnet\":\r\n                return this.defaultRpcEndpoint ?? \"https://mainnet.onflow.org\";\r\n            case \"testnet\":\r\n                return \"https://testnet.onflow.org\";\r\n            case \"emulator\":\r\n                return \"http://localhost:8888\";\r\n            default:\r\n                throw new Exception(\r\n                    50000,\r\n                    `Network type ${this.network} is not supported`\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize the Flow SDK\r\n     */\r\n    async onModuleInit() {\r\n        if (isGloballyInited) return;\r\n\r\n        const cfg = fcl.config();\r\n        // Required\r\n        await cfg.put(\"flow.network\", this.network);\r\n        // Set the maximum of gas limit\r\n        await cfg.put(\"fcl.limit\", 9999);\r\n        // Set the RPC endpoint\r\n        await cfg.put(\"accessNode.api\", this.rpcEndpoint);\r\n        // Load Flow JSON\r\n        await cfg.load({ flowJSON: this.flowJSON });\r\n\r\n        isGloballyInited = true;\r\n    }\r\n\r\n    /**\r\n     * Ensure the Flow SDK is initialized\r\n     */\r\n    private async ensureInited() {\r\n        if (isGloballyInited) return;\r\n        if (!globallyPromise) {\r\n            globallyPromise = this.onModuleInit();\r\n        }\r\n        return await globallyPromise;\r\n    }\r\n\r\n    /**\r\n     * Get account information\r\n     */\r\n    async getAccount(addr: string): Promise<Account> {\r\n        await this.ensureInited();\r\n        return await fcl.send([fcl.getAccount(addr)]).then(fcl.decode);\r\n    }\r\n\r\n    /**\r\n     * General method of sending transaction\r\n     */\r\n    async sendTransaction(\r\n        code: string,\r\n        args: fcl.ArgumentFunction,\r\n        mainAuthz?: fcl.FclAuthorization,\r\n        extraAuthz?: fcl.FclAuthorization[]\r\n    ) {\r\n        await this.ensureInited();\r\n        if (typeof mainAuthz !== \"undefined\") {\r\n            return await fcl.mutate({\r\n                cadence: code,\r\n                args: args,\r\n                proposer: mainAuthz,\r\n                payer: mainAuthz,\r\n                authorizations:\r\n                    (extraAuthz?.length ?? 0) === 0\r\n                        ? [mainAuthz]\r\n                        : [mainAuthz, ...extraAuthz],\r\n            });\r\n        } else {\r\n            return await fcl.mutate({\r\n                cadence: code,\r\n                args: args,\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get transaction status\r\n     */\r\n    async getTransactionStatus(\r\n        transactionId: string\r\n    ): Promise<TransactionStatus> {\r\n        await this.ensureInited();\r\n        return await fcl.tx(transactionId).onceExecuted();\r\n    }\r\n\r\n    /**\r\n     * Get chain id\r\n     */\r\n    async getChainId() {\r\n        await this.ensureInited();\r\n        return await fcl.getChainId();\r\n    }\r\n\r\n    /**\r\n     * Send transaction with single authorization\r\n     */\r\n    async onceTransactionSealed(\r\n        transactionId: string\r\n    ): Promise<TransactionStatus> {\r\n        await this.ensureInited();\r\n        return fcl.tx(transactionId).onceSealed();\r\n    }\r\n\r\n    /**\r\n     * Get block object\r\n     * @param blockId\r\n     */\r\n    async getBlockHeaderObject(\r\n        blockId: string\r\n    ): Promise<fcl.BlockHeaderObject> {\r\n        await this.ensureInited();\r\n        return await fcl\r\n\r\n            .send([fcl.getBlockHeader(), fcl.atBlockId(blockId)])\r\n            .then(fcl.decode);\r\n    }\r\n\r\n    /**\r\n     * Send script\r\n     */\r\n    async executeScript<T>(\r\n        code: string,\r\n        args: fcl.ArgumentFunction,\r\n        defaultValue: T\r\n    ): Promise<T> {\r\n        await this.ensureInited();\r\n        try {\r\n            const queryResult = await fcl.query({\r\n                cadence: code,\r\n                args,\r\n            });\r\n            return (queryResult as T) ?? defaultValue;\r\n        } catch (e) {\r\n            console.error(e);\r\n            return defaultValue;\r\n        }\r\n    }\r\n}\r\n\r\nexport default FlowConnector;\r\n","export default class Exception extends Error {\r\n    constructor(\r\n        readonly code: number,\r\n        message?: string,\r\n        options?: ErrorOptions\r\n    ) {\r\n        super(message, options);\r\n    }\r\n}\r\n","{\r\n    \"dependencies\": {\r\n        \"ArrayUtils\": {\r\n            \"source\": \"mainnet://a340dc0a4ec828ab.ArrayUtils\",\r\n            \"hash\": \"9e8f2d3e35be82da42b685045af834e16d23bcef1f322603ff91cedd1c9bbad9\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"a340dc0a4ec828ab\",\r\n                \"testnet\": \"31ad40c07a2a9788\"\r\n            }\r\n        },\r\n        \"Burner\": {\r\n            \"source\": \"mainnet://f233dcee88fe0abe.Burner\",\r\n            \"hash\": \"71af18e227984cd434a3ad00bb2f3618b76482842bae920ee55662c37c8bf331\",\r\n            \"aliases\": {\r\n                \"emulator\": \"f8d6e0586b0a20c7\",\r\n                \"mainnet\": \"f233dcee88fe0abe\",\r\n                \"testnet\": \"9a0766d93b6608b7\"\r\n            }\r\n        },\r\n        \"CapabilityDelegator\": {\r\n            \"source\": \"mainnet://d8a7e05a7ac670c0.CapabilityDelegator\",\r\n            \"hash\": \"ad3bf8671a74a836b428da7840540c0ce419349be5f6410b18546e9a9217a9d2\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"d8a7e05a7ac670c0\",\r\n                \"testnet\": \"294e44e1ec6993c6\"\r\n            }\r\n        },\r\n        \"CapabilityFactory\": {\r\n            \"source\": \"mainnet://d8a7e05a7ac670c0.CapabilityFactory\",\r\n            \"hash\": \"33d6b142c1db548a193cc06ff9828a24ca2ff8726301e292a8b6863dd0e1e73e\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"d8a7e05a7ac670c0\",\r\n                \"testnet\": \"294e44e1ec6993c6\"\r\n            }\r\n        },\r\n        \"CapabilityFilter\": {\r\n            \"source\": \"mainnet://d8a7e05a7ac670c0.CapabilityFilter\",\r\n            \"hash\": \"77b59eb8245102a84a49d47a67e83eeeaafea920b120cdd6aa175d9ff120c388\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"d8a7e05a7ac670c0\",\r\n                \"testnet\": \"294e44e1ec6993c6\"\r\n            }\r\n        },\r\n        \"CrossVMNFT\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.CrossVMNFT\",\r\n            \"hash\": \"a9e2ba34ecffda196c58f5c1439bc257d48d0c81457597eb58eb5f879dd95e5a\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"CrossVMToken\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.CrossVMToken\",\r\n            \"hash\": \"6d5c16804247ab9f1234b06383fa1bed42845211dba22582748abd434296650c\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"EVM\": {\r\n            \"source\": \"mainnet://e467b9dd11fa00df.EVM\",\r\n            \"hash\": \"5c69921fa06088b477e2758e122636b39d3d3eb5316807c206c5680d9ac74c7e\",\r\n            \"aliases\": {\r\n                \"emulator\": \"f8d6e0586b0a20c7\",\r\n                \"mainnet\": \"e467b9dd11fa00df\",\r\n                \"testnet\": \"8c5303eaa26202d6\"\r\n            }\r\n        },\r\n        \"FTViewUtils\": {\r\n            \"source\": \"mainnet://15a918087ab12d86.FTViewUtils\",\r\n            \"hash\": \"ef8343697ebcb455a835bc9f87b8060f574c3d968644de47f6613cebf05d7749\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"15a918087ab12d86\",\r\n                \"testnet\": \"b86f928a1fa7798e\"\r\n            }\r\n        },\r\n        \"FlowEVMBridge\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridge\",\r\n            \"hash\": \"83d4d1f7c715cfe7b1a65241e94ae4b8cb40e6ce135ce4c3981e4d39e59ba33e\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"FlowEVMBridgeConfig\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeConfig\",\r\n            \"hash\": \"279513a6c107da2af4c847a42169f862ee67105e5a56512872fb6b9a9be3305d\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"FlowEVMBridgeHandlerInterfaces\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeHandlerInterfaces\",\r\n            \"hash\": \"fcbcd095c8145acf6fd07c336d44502f2946e32f4a1bf7e9bd0772fdd1bea778\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"FlowEVMBridgeNFTEscrow\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeNFTEscrow\",\r\n            \"hash\": \"ea7054bd06f978d09672ab2d6a1e7ad04df4b46410943088d555dd9ca6e64240\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"FlowEVMBridgeTemplates\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeTemplates\",\r\n            \"hash\": \"8f27b22450f57522d93d3045038ac9b1935476f4216f57fe3bb82929c71d7aa6\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"FlowEVMBridgeTokenEscrow\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeTokenEscrow\",\r\n            \"hash\": \"b5ec7c0a16e1c49004b2ed072c5eadc8c382e43351982b4a3050422f116b8f46\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"FlowEVMBridgeUtils\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeUtils\",\r\n            \"hash\": \"cd17ed82ae6d6f708a8d022d4228e0b53d2349f7f330c18e9c45e777553d2173\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"FlowStorageFees\": {\r\n            \"source\": \"mainnet://e467b9dd11fa00df.FlowStorageFees\",\r\n            \"hash\": \"e38d8a95f6518b8ff46ce57dfa37b4b850b3638f33d16333096bc625b6d9b51a\",\r\n            \"aliases\": {\r\n                \"emulator\": \"f8d6e0586b0a20c7\",\r\n                \"mainnet\": \"e467b9dd11fa00df\",\r\n                \"testnet\": \"8c5303eaa26202d6\"\r\n            }\r\n        },\r\n        \"FlowToken\": {\r\n            \"source\": \"mainnet://1654653399040a61.FlowToken\",\r\n            \"hash\": \"cefb25fd19d9fc80ce02896267eb6157a6b0df7b1935caa8641421fe34c0e67a\",\r\n            \"aliases\": {\r\n                \"emulator\": \"0ae53cb6e3f42a79\",\r\n                \"mainnet\": \"1654653399040a61\",\r\n                \"testnet\": \"7e60df042a9c0868\"\r\n            }\r\n        },\r\n        \"FungibleToken\": {\r\n            \"source\": \"mainnet://f233dcee88fe0abe.FungibleToken\",\r\n            \"hash\": \"050328d01c6cde307fbe14960632666848d9b7ea4fef03ca8c0bbfb0f2884068\",\r\n            \"aliases\": {\r\n                \"emulator\": \"ee82856bf20e2aa6\",\r\n                \"mainnet\": \"f233dcee88fe0abe\",\r\n                \"testnet\": \"9a0766d93b6608b7\"\r\n            }\r\n        },\r\n        \"FungibleTokenMetadataViews\": {\r\n            \"source\": \"mainnet://f233dcee88fe0abe.FungibleTokenMetadataViews\",\r\n            \"hash\": \"dff704a6e3da83997ed48bcd244aaa3eac0733156759a37c76a58ab08863016a\",\r\n            \"aliases\": {\r\n                \"emulator\": \"ee82856bf20e2aa6\",\r\n                \"mainnet\": \"f233dcee88fe0abe\",\r\n                \"testnet\": \"9a0766d93b6608b7\"\r\n            }\r\n        },\r\n        \"HybridCustody\": {\r\n            \"source\": \"mainnet://d8a7e05a7ac670c0.HybridCustody\",\r\n            \"hash\": \"c8a129eec11c57ee25487fcce38efc54c3b12eb539ba61a52f4ee620173bb67b\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"d8a7e05a7ac670c0\",\r\n                \"testnet\": \"294e44e1ec6993c6\"\r\n            }\r\n        },\r\n        \"IBridgePermissions\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.IBridgePermissions\",\r\n            \"hash\": \"431a51a6cca87773596f79832520b19499fe614297eaef347e49383f2ae809af\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"ICrossVM\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.ICrossVM\",\r\n            \"hash\": \"e14dcb25f974e216fd83afdc0d0f576ae7014988755a4777b06562ffb06537bc\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"ICrossVMAsset\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.ICrossVMAsset\",\r\n            \"hash\": \"aa1fbd979c9d7806ea8ea66311e2a4257c5a4051eef020524a0bda4d8048ed57\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"IEVMBridgeNFTMinter\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.IEVMBridgeNFTMinter\",\r\n            \"hash\": \"65ec734429c12b70cd97ad8ea2c2bc4986fab286744921ed139d9b45da92e77e\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"IEVMBridgeTokenMinter\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.IEVMBridgeTokenMinter\",\r\n            \"hash\": \"223adb675415984e9c163d15c5922b5c77dc5036bf6548d0b87afa27f4f0a9d9\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"IFlowEVMNFTBridge\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.IFlowEVMNFTBridge\",\r\n            \"hash\": \"3d5bfa663a7059edee8c51d95bc454adf37f17c6d32be18eb42134b550e537b3\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"IFlowEVMTokenBridge\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.IFlowEVMTokenBridge\",\r\n            \"hash\": \"573a038b1e9c26504f6aa32a091e88168591b7f93feeff9ac0343285488a8eb3\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"MetadataViews\": {\r\n            \"source\": \"mainnet://1d7e57aa55817448.MetadataViews\",\r\n            \"hash\": \"10a239cc26e825077de6c8b424409ae173e78e8391df62750b6ba19ffd048f51\",\r\n            \"aliases\": {\r\n                \"emulator\": \"f8d6e0586b0a20c7\",\r\n                \"mainnet\": \"1d7e57aa55817448\",\r\n                \"testnet\": \"631e88ae7f1d7c20\"\r\n            }\r\n        },\r\n        \"NonFungibleToken\": {\r\n            \"source\": \"mainnet://1d7e57aa55817448.NonFungibleToken\",\r\n            \"hash\": \"b63f10e00d1a814492822652dac7c0574428a200e4c26cb3c832c4829e2778f0\",\r\n            \"aliases\": {\r\n                \"emulator\": \"f8d6e0586b0a20c7\",\r\n                \"mainnet\": \"1d7e57aa55817448\",\r\n                \"testnet\": \"631e88ae7f1d7c20\"\r\n            }\r\n        },\r\n        \"OracleConfig\": {\r\n            \"source\": \"mainnet://cec15c814971c1dc.OracleConfig\",\r\n            \"hash\": \"48c252a858ce1c1fb44a377f338a4e558a70f1c22cecea9b7bf8cb74e9b16b79\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"cec15c814971c1dc\",\r\n                \"testnet\": \"2a9b59c3e2b72ee0\"\r\n            }\r\n        },\r\n        \"OracleInterface\": {\r\n            \"source\": \"mainnet://cec15c814971c1dc.OracleInterface\",\r\n            \"hash\": \"1ca66227b60dcf59e9d84404398c8151b1ff6395408094669ef1251c78ca2465\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"cec15c814971c1dc\",\r\n                \"testnet\": \"2a9b59c3e2b72ee0\"\r\n            }\r\n        },\r\n        \"PublicPriceOracle\": {\r\n            \"source\": \"mainnet://ec67451f8a58216a.PublicPriceOracle\",\r\n            \"hash\": \"3f0b75a98cc8a75835125421bcf602a3f278eaf94001bca7b7a8503b73cbc9a7\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"ec67451f8a58216a\",\r\n                \"testnet\": \"8232ce4a3aff4e94\"\r\n            }\r\n        },\r\n        \"ScopedFTProviders\": {\r\n            \"source\": \"mainnet://a340dc0a4ec828ab.ScopedFTProviders\",\r\n            \"hash\": \"9a143138f5a5f51a5402715f7d84dbe363b5744be153ee09343aed71cf241c42\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"a340dc0a4ec828ab\",\r\n                \"testnet\": \"31ad40c07a2a9788\"\r\n            }\r\n        },\r\n        \"Serialize\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.Serialize\",\r\n            \"hash\": \"d12a5957ab5352024bb08b281c4de4f9a88ecde74b159a7da0c69d0c8ca51589\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"SerializeMetadata\": {\r\n            \"source\": \"mainnet://1e4aa0b87d10b141.SerializeMetadata\",\r\n            \"hash\": \"eb7ec0ab5abfc66dd636c07a5ed2c7a65723a8d876842035bf9bebd6b0060e3a\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"1e4aa0b87d10b141\",\r\n                \"testnet\": \"dfc20aee650fcbdf\"\r\n            }\r\n        },\r\n        \"StableSwapFactory\": {\r\n            \"source\": \"mainnet://b063c16cac85dbd1.StableSwapFactory\",\r\n            \"hash\": \"46318aee6fd29616c8048c23210d4c4f5b172eb99a0ca911fbd849c831a52a0b\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"b063c16cac85dbd1\",\r\n                \"testnet\": \"cbed4c301441ded2\"\r\n            }\r\n        },\r\n        \"StringUtils\": {\r\n            \"source\": \"mainnet://a340dc0a4ec828ab.StringUtils\",\r\n            \"hash\": \"b401c4b0f711344ed9cd02ff77c91e026f5dfbca6045f140b9ca9d4966707e83\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"a340dc0a4ec828ab\",\r\n                \"testnet\": \"31ad40c07a2a9788\"\r\n            }\r\n        },\r\n        \"SwapConfig\": {\r\n            \"source\": \"mainnet://b78ef7afa52ff906.SwapConfig\",\r\n            \"hash\": \"ccafdb89804887e4e39a9b8fdff5c0ff0d0743505282f2a8ecf86c964e691c82\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"b78ef7afa52ff906\",\r\n                \"testnet\": \"ddb929038d45d4b3\"\r\n            }\r\n        },\r\n        \"SwapError\": {\r\n            \"source\": \"mainnet://b78ef7afa52ff906.SwapError\",\r\n            \"hash\": \"7d13a652a1308af387513e35c08b4f9a7389a927bddf08431687a846e4c67f21\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"b78ef7afa52ff906\",\r\n                \"testnet\": \"ddb929038d45d4b3\"\r\n            }\r\n        },\r\n        \"SwapFactory\": {\r\n            \"source\": \"mainnet://b063c16cac85dbd1.SwapFactory\",\r\n            \"hash\": \"6d319e77f5eed0c49c960b1ef887c01dd7c2cce8a0b39f7e31fb2af0113eedc5\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"b063c16cac85dbd1\",\r\n                \"testnet\": \"cbed4c301441ded2\"\r\n            }\r\n        },\r\n        \"SwapInterfaces\": {\r\n            \"source\": \"mainnet://b78ef7afa52ff906.SwapInterfaces\",\r\n            \"hash\": \"570bb4b9c8da8e0caa8f428494db80779fb906a66cc1904c39a2b9f78b89c6fa\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"b78ef7afa52ff906\",\r\n                \"testnet\": \"ddb929038d45d4b3\"\r\n            }\r\n        },\r\n        \"SwapPair\": {\r\n            \"source\": \"mainnet://ecbda466e7f191c7.SwapPair\",\r\n            \"hash\": \"69b99c4a8abc123a0a88b1c354f9da414a32e2f73194403e67e89d51713923c0\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"ecbda466e7f191c7\",\r\n                \"testnet\": \"c20df20fabe06457\"\r\n            }\r\n        },\r\n        \"TokenList\": {\r\n            \"source\": \"mainnet://15a918087ab12d86.TokenList\",\r\n            \"hash\": \"ac9298cfdf02e785e92334858fab0f388e5a72136c3bc4d4ed7f2039ac152bd5\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"15a918087ab12d86\",\r\n                \"testnet\": \"b86f928a1fa7798e\"\r\n            }\r\n        },\r\n        \"ViewResolver\": {\r\n            \"source\": \"mainnet://1d7e57aa55817448.ViewResolver\",\r\n            \"hash\": \"374a1994046bac9f6228b4843cb32393ef40554df9bd9907a702d098a2987bde\",\r\n            \"aliases\": {\r\n                \"emulator\": \"f8d6e0586b0a20c7\",\r\n                \"mainnet\": \"1d7e57aa55817448\",\r\n                \"testnet\": \"631e88ae7f1d7c20\"\r\n            }\r\n        },\r\n        \"ViewResolvers\": {\r\n            \"source\": \"mainnet://15a918087ab12d86.ViewResolvers\",\r\n            \"hash\": \"37ef9b2a71c1b0daa031c261f731466fcbefad998590177c798b56b61a95489a\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"15a918087ab12d86\",\r\n                \"testnet\": \"b86f928a1fa7798e\"\r\n            }\r\n        },\r\n        \"stFlowToken\": {\r\n            \"source\": \"mainnet://d6f80565193ad727.stFlowToken\",\r\n            \"hash\": \"09b1350a55646fdee652fddf7927fc4b305da5a265cb1bd887e112d84fb5e2be\",\r\n            \"aliases\": {\r\n                \"mainnet\": \"d6f80565193ad727\",\r\n                \"testnet\": \"e45c64ecfe31e465\"\r\n            }\r\n        }\r\n    },\r\n    \"networks\": {\r\n        \"emulator\": \"127.0.0.1:3569\",\r\n        \"mainnet\": \"access.mainnet.nodes.onflow.org:9000\",\r\n        \"testing\": \"127.0.0.1:3569\",\r\n        \"testnet\": \"access.devnet.nodes.onflow.org:9000\"\r\n    }\r\n}\r\n","import {\r\n    elizaLogger,\r\n    IAgentRuntime,\r\n    Memory,\r\n    Provider,\r\n    State,\r\n} from \"@elizaos/core\";\r\nimport NodeCache from \"node-cache\";\r\nimport * as fcl from \"@onflow/fcl\";\r\nimport type { CompositeSignature, Account } from \"@onflow/typedefs\";\r\nimport type { FlowConnector } from \"./utils/flow.connector\";\r\nimport { IFlowScriptExecutor, IFlowSigner } from \"../types\";\r\nimport { getFlowConnectorInstance } from \"./connector.provider\";\r\nimport PureSigner from \"./utils/pure.signer\";\r\nimport Exception from \"../types/exception\";\r\nimport * as queries from \"../queries\";\r\n\r\n/**\r\n * Flow wallet Provider\r\n */\r\nexport class FlowWalletProvider implements IFlowSigner, IFlowScriptExecutor {\r\n    runtime: IAgentRuntime;\r\n    private readonly privateKeyHex?: string;\r\n    public readonly address: string;\r\n    // Runtime data\r\n    private account: Account | null = null;\r\n    public maxKeyIndex = 0;\r\n\r\n    constructor(\r\n        runtime: IAgentRuntime,\r\n        private readonly connector: FlowConnector,\r\n        private readonly cache: NodeCache = new NodeCache({ stdTTL: 300 }) // Cache TTL set to 5 minutes\r\n    ) {\r\n        this.address = getSignerAddress(runtime);\r\n        this.runtime = runtime;\r\n\r\n        const privateKey = runtime.getSetting(\"FLOW_PRIVATE_KEY\");\r\n        if (!privateKey) {\r\n            elizaLogger.warn(\r\n                `The default Flow wallet ${this.address} has no private key`\r\n            );\r\n        } else {\r\n            this.privateKeyHex = privateKey.startsWith(\"0x\")\r\n                ? privateKey.slice(2)\r\n                : privateKey;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the network type\r\n     */\r\n    get network() {\r\n        return this.connector.network;\r\n    }\r\n\r\n    /**\r\n     * Send a transaction\r\n     * @param code Cadence code\r\n     * @param args Cadence arguments\r\n     */\r\n    async sendTransaction(\r\n        code: string,\r\n        args: fcl.ArgumentFunction,\r\n        authz?: fcl.FclAuthorization\r\n    ) {\r\n        return await this.connector.sendTransaction(\r\n            code,\r\n            args,\r\n            authz ?? this.buildAuthorization()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Execute a script\r\n     * @param code Cadence code\r\n     * @param args Cadence arguments\r\n     */\r\n    async executeScript<T>(\r\n        code: string,\r\n        args: fcl.ArgumentFunction,\r\n        defaultValue: T\r\n    ): Promise<T> {\r\n        return await this.connector.executeScript(code, args, defaultValue);\r\n    }\r\n\r\n    /**\r\n     * Build authorization\r\n     */\r\n    buildAuthorization(accountIndex = 0, privateKey = this.privateKeyHex) {\r\n        if (this.account) {\r\n            if (accountIndex > this.maxKeyIndex) {\r\n                throw new Exception(50200, \"Invalid account index\");\r\n            }\r\n        }\r\n        const address = this.address;\r\n        if (!privateKey) {\r\n            throw new Exception(50200, \"No private key provided\");\r\n        }\r\n        return (account: any) => {\r\n            return {\r\n                ...account,\r\n                tempId: `${address}-${accountIndex}`,\r\n                addr: fcl.sansPrefix(address),\r\n                keyId: Number(accountIndex),\r\n                signingFunction: (\r\n                    signable: any\r\n                ): Promise<CompositeSignature> => {\r\n                    return Promise.resolve({\r\n                        f_type: \"CompositeSignature\",\r\n                        f_vsn: \"1.0.0\",\r\n                        addr: fcl.withPrefix(address),\r\n                        keyId: Number(accountIndex),\r\n                        signature: this.signMessage(\r\n                            signable.message,\r\n                            privateKey\r\n                        ),\r\n                    });\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Sign a message\r\n     * @param message Message to sign\r\n     */\r\n    signMessage(message: string, privateKey = this.privateKeyHex) {\r\n        return PureSigner.signWithKey(privateKey, message);\r\n    }\r\n\r\n    // -----  methods -----\r\n\r\n    /**\r\n     * Sync account info\r\n     */\r\n    async syncAccountInfo() {\r\n        this.account = await this.connector.getAccount(this.address);\r\n        this.maxKeyIndex = this.account.keys.length - 1;\r\n        this.cache.set(\"balance\", this.account.balance / 1e8);\r\n        elizaLogger.debug(\"Flow account info synced\", {\r\n            address: this.address,\r\n            balance: this.account.balance,\r\n            maxKeyIndex: this.maxKeyIndex,\r\n            keys: this.account.keys,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the wallet balance\r\n     * @returns Wallet balance\r\n     */\r\n    async getWalletBalance(forceRefresh = false): Promise<number> {\r\n        const cachedBalance = await this.cache.get<number>(\"balance\");\r\n        if (!forceRefresh && cachedBalance) {\r\n            return cachedBalance;\r\n        }\r\n        await this.syncAccountInfo();\r\n        return this.account ? this.account.balance / 1e8 : 0;\r\n    }\r\n\r\n    /**\r\n     * Query the balance of this wallet\r\n     */\r\n    async queryAccountBalanceInfo() {\r\n        return await queries.queryAccountBalanceInfo(this, this.address);\r\n    }\r\n}\r\n\r\n// ----- Helpers -----\r\n\r\n/**\r\n * Check if an address is a Flow address\r\n * @param address Address to check\r\n */\r\nexport function isFlowAddress(address: string) {\r\n    const regExp = /^0x[a-fA-F0-9]{16}$/gi;\r\n    return regExp.test(address);\r\n}\r\n\r\n/**\r\n * Check if an address is an EVM address\r\n * @param address Address to check\r\n */\r\nexport function isEVMAddress(address: string) {\r\n    const regExp = /^0x[a-fA-F0-9]{40}$/gi;\r\n    return regExp.test(address);\r\n}\r\n\r\n/**\r\n * Check if a string is a Cadence identifier\r\n * @param str String to check\r\n */\r\nexport function isCadenceIdentifier(str: string) {\r\n    const cadenceIdentifier = /^A\\.[0-9a-fA-F]{16}\\.[0-9a-zA-Z_]+/;\r\n    return cadenceIdentifier.test(str);\r\n}\r\n\r\n/**\r\n * Get the signer address\r\n */\r\nfunction getSignerAddress(runtime: IAgentRuntime): string {\r\n    const signerAddr = runtime.getSetting(\"FLOW_ADDRESS\");\r\n    if (!signerAddr) {\r\n        elizaLogger.error(\"No signer address\");\r\n        throw new Exception(50200, \"No signer info\");\r\n    }\r\n    return signerAddr;\r\n}\r\n\r\nconst flowWalletProvider: Provider = {\r\n    get: async (\r\n        runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        _state?: State\r\n    ): Promise<string | null> => {\r\n        // Check if the user has an Flow wallet\r\n        if (\r\n            !runtime.getSetting(\"FLOW_ADDRESS\") ||\r\n            !runtime.getSetting(\"FLOW_PRIVATE_KEY\")\r\n        ) {\r\n            elizaLogger.error(\r\n                \"FLOW_ADDRESS or FLOW_PRIVATE_KEY not configured, skipping wallet injection\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            const connector = await getFlowConnectorInstance(runtime);\r\n            const walletProvider = new FlowWalletProvider(runtime, connector);\r\n            const info = await walletProvider.queryAccountBalanceInfo();\r\n            if (!info || info?.address !== walletProvider.address) {\r\n                elizaLogger.error(\"Invalid account info\");\r\n                return null;\r\n            }\r\n            let output = `Here is user<${runtime.character.name}>'s wallet status:\\n`;\r\n            output += `Flow wallet address: ${walletProvider.address}\\n`;\r\n            output += `FLOW balance: ${info.balance} FLOW\\n`;\r\n            output += `Flow wallet's COA(EVM) address: ${info.coaAddress || \"unknown\"}\\n`;\r\n            output += `FLOW balance in COA(EVM) address: ${info.coaBalance ?? 0} FLOW`;\r\n            return output;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in Flow wallet provider:\", error.message);\r\n            return null;\r\n        }\r\n    },\r\n};\r\n\r\n// Module exports\r\nexport { flowWalletProvider };\r\n","import elliptic from \"elliptic\";\r\nimport { SHA3 } from \"sha3\";\r\n\r\nexport default class PureSigner {\r\n    /**\r\n     * Sign a message with a private key\r\n     */\r\n    static signWithKey(privateKeyHex: string, msg: string) {\r\n        const ec = new elliptic.ec(\"p256\");\r\n        const key = ec.keyFromPrivate(Buffer.from(privateKeyHex, \"hex\"));\r\n        const sig = key.sign(this._hashMsg(msg));\r\n        const n = 32;\r\n        const r = sig.r.toArrayLike(Buffer, \"be\", n);\r\n        const s = sig.s.toArrayLike(Buffer, \"be\", n);\r\n        return Buffer.concat([r.valueOf(), s.valueOf()]).toString(\"hex\");\r\n    }\r\n\r\n    /**\r\n     * Hash a message\r\n     */\r\n    private static _hashMsg(msg: string) {\r\n        const sha = new SHA3(256);\r\n        sha.update(Buffer.from(msg, \"hex\"));\r\n        return sha.digest();\r\n    }\r\n}\r\n","import {\r\n    composeContext,\r\n    Content,\r\n    elizaLogger,\r\n    generateObjectArray,\r\n    ModelClass,\r\n    type Action,\r\n    type ActionExample,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    type State,\r\n} from \"@elizaos/core\";\r\nimport Exception from \"../types/exception\";\r\nimport { getFlowConnectorInstance } from \"../providers/connector.provider\";\r\nimport {\r\n    FlowWalletProvider,\r\n    isCadenceIdentifier,\r\n    isEVMAddress,\r\n    isFlowAddress,\r\n} from \"../providers/wallet.provider\";\r\nimport { transferTemplate } from \"../templates\";\r\nimport { validateFlowConfig } from \"../environment\";\r\nimport { TransactionResponse } from \"../types\";\r\nimport { transactions } from \"../assets/transaction.defs\";\r\nimport * as queries from \"../queries\";\r\n\r\n/**\r\n * The generated content for the transfer action\r\n */\r\nexport interface TransferContent extends Content {\r\n    token: string | null;\r\n    amount: string;\r\n    to: string;\r\n    matched: boolean;\r\n}\r\n\r\n/**\r\n * Check if the content is a transfer content\r\n */\r\nfunction isTransferContent(\r\n    runtime: IAgentRuntime,\r\n    content: any\r\n): content is TransferContent {\r\n    elizaLogger.log(\"Content for transfer\", content);\r\n    return (\r\n        (!content.token ||\r\n            (typeof content.token === \"string\" &&\r\n                (isCadenceIdentifier(content.token) ||\r\n                    isEVMAddress(content.token)))) &&\r\n        typeof content.to === \"string\" &&\r\n        (isEVMAddress(content.to) || isFlowAddress(content.to)) &&\r\n        (typeof content.amount === \"string\" ||\r\n            typeof content.amount === \"number\") &&\r\n        typeof content.matched === \"boolean\"\r\n    );\r\n}\r\n\r\n// FIXME: We need to use dynamic key index\r\nconst USE_KEY_INDEX = 0;\r\n\r\nexport class TransferAction {\r\n    constructor(\r\n        private walletProvider: FlowWalletProvider,\r\n        public readonly useKeyIndex: number = USE_KEY_INDEX\r\n    ) {}\r\n\r\n    /**\r\n     * Process the messages and generate the transfer content\r\n     */\r\n    async processMessages(\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ): Promise<TransferContent> {\r\n        // Initialize or update state\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n\r\n        // Compose transfer context\r\n        const transferContext = composeContext({\r\n            state,\r\n            template: transferTemplate,\r\n        });\r\n\r\n        // Generate transfer content\r\n        const recommendations = await generateObjectArray({\r\n            runtime,\r\n            context: transferContext,\r\n            modelClass: ModelClass.MEDIUM,\r\n        });\r\n\r\n        elizaLogger.debug(\"Recommendations\", recommendations);\r\n\r\n        // Convert array to object\r\n        const content = recommendations[recommendations.length - 1];\r\n\r\n        // Validate transfer content\r\n        if (!isTransferContent(runtime, content)) {\r\n            elizaLogger.error(\"Invalid content for SEND_COIN action.\");\r\n            throw new Exception(50100, \"Invalid transfer content\");\r\n        }\r\n\r\n        // Check if the content is matched\r\n        if (!content.matched) {\r\n            elizaLogger.error(\"Content does not match the transfer template.\");\r\n            throw new Exception(\r\n                50100,\r\n                \"Content does not match the transfer template\"\r\n            );\r\n        }\r\n        return content;\r\n    }\r\n\r\n    async transfer(\r\n        content: TransferContent,\r\n        callback?: HandlerCallback\r\n    ): Promise<TransactionResponse> {\r\n        elizaLogger.log(\"Starting Flow Plugin's SEND_COIN handler...\");\r\n\r\n        const resp: TransactionResponse = {\r\n            signer: {\r\n                address: this.walletProvider.address,\r\n                keyIndex: this.useKeyIndex,\r\n            },\r\n            txid: \"\",\r\n        };\r\n        const logPrefix = `Address: ${resp.signer.address}, using keyIdex: ${resp.signer.keyIndex}\\n`;\r\n\r\n        // Parsed fields\r\n        const recipient = content.to;\r\n        const amount =\r\n            typeof content.amount === \"number\"\r\n                ? content.amount\r\n                : parseFloat(content.amount);\r\n\r\n        // Check if the wallet has enough balance to transfer\r\n        const accountInfo = await queries.queryAccountBalanceInfo(\r\n            this.walletProvider,\r\n            this.walletProvider.address\r\n        );\r\n        const totalBalance =\r\n            accountInfo.balance + (accountInfo.coaBalance ?? 0);\r\n\r\n        // Check if the amount is valid\r\n        if (totalBalance < amount) {\r\n            elizaLogger.error(\"Insufficient balance to transfer.\");\r\n            if (callback) {\r\n                callback({\r\n                    text: `${logPrefix} Unable to process transfer request. Insufficient balance.`,\r\n                    content: {\r\n                        error: \"Insufficient balance\",\r\n                    },\r\n                });\r\n            }\r\n            throw new Exception(50100, \"Insufficient balance to transfer\");\r\n        }\r\n\r\n        try {\r\n            // Execute transfer\r\n            const authz = this.walletProvider.buildAuthorization(\r\n                this.useKeyIndex\r\n            ); // use default private key\r\n\r\n            // For different token types, we need to handle the token differently\r\n            if (!content.token) {\r\n                elizaLogger.log(\r\n                    `${logPrefix} Sending ${amount} FLOW to ${recipient}...`\r\n                );\r\n                // Transfer FLOW token\r\n                resp.txid = await this.walletProvider.sendTransaction(\r\n                    transactions.mainFlowTokenDynamicTransfer,\r\n                    (arg, t) => [\r\n                        arg(recipient, t.String),\r\n                        arg(amount.toFixed(1), t.UFix64),\r\n                    ],\r\n                    authz\r\n                );\r\n            } else if (isCadenceIdentifier(content.token)) {\r\n                // Transfer Fungible Token on Cadence side\r\n                const [_, tokenAddr, tokenContractName] =\r\n                    content.token.split(\".\");\r\n                elizaLogger.log(\r\n                    `${logPrefix} Sending ${amount} A.${tokenAddr}.${tokenContractName} to ${recipient}...`\r\n                );\r\n                resp.txid = await this.walletProvider.sendTransaction(\r\n                    transactions.mainFTGenericTransfer,\r\n                    (arg, t) => [\r\n                        arg(amount.toFixed(1), t.UFix64),\r\n                        arg(recipient, t.Address),\r\n                        arg(\"0x\" + tokenAddr, t.Address),\r\n                        arg(tokenContractName, t.String),\r\n                    ],\r\n                    authz\r\n                );\r\n            } else if (isEVMAddress(content.token)) {\r\n                // Transfer ERC20 token on EVM side\r\n                // we need to update the amount to be in the smallest unit\r\n                const decimals = await queries.queryEvmERC20Decimals(\r\n                    this.walletProvider,\r\n                    content.token\r\n                );\r\n                const adjustedAmount = BigInt(amount * Math.pow(10, decimals));\r\n\r\n                elizaLogger.log(\r\n                    `${logPrefix} Sending ${adjustedAmount} ${content.token}(EVM) to ${recipient}...`\r\n                );\r\n\r\n                resp.txid = await this.walletProvider.sendTransaction(\r\n                    transactions.mainEVMTransferERC20,\r\n                    (arg, t) => [\r\n                        arg(content.token, t.String),\r\n                        arg(recipient, t.String),\r\n                        // Convert the amount to string, the string should be pure number, not a scientific notation\r\n                        arg(adjustedAmount.toString(), t.UInt256),\r\n                    ],\r\n                    authz\r\n                );\r\n            }\r\n\r\n            elizaLogger.log(`${logPrefix} Sent transaction: ${resp.txid}`);\r\n\r\n            // call the callback with the transaction response\r\n            if (callback) {\r\n                const tokenName = content.token || \"FLOW\";\r\n                const baseUrl =\r\n                    this.walletProvider.network === \"testnet\"\r\n                        ? \"https://testnet.flowscan.io\"\r\n                        : \"https://flowscan.io\";\r\n                const txURL = `${baseUrl}/tx/${resp.txid}/events`;\r\n                callback({\r\n                    text: `${logPrefix} Successfully transferred ${content.amount} ${tokenName} to ${content.to}\\nTransaction: [${resp.txid}](${txURL})`,\r\n                    content: {\r\n                        success: true,\r\n                        txid: resp.txid,\r\n                        token: content.token,\r\n                        to: content.to,\r\n                        amount: content.amount,\r\n                    },\r\n                });\r\n            }\r\n        } catch (e: any) {\r\n            elizaLogger.error(\"Error in sending transaction:\", e.message);\r\n            if (callback) {\r\n                callback({\r\n                    text: `${logPrefix} Unable to process transfer request. Error in sending transaction.`,\r\n                    content: {\r\n                        error: e.message,\r\n                    },\r\n                });\r\n            }\r\n            if (e instanceof Exception) {\r\n                throw e;\r\n            } else {\r\n                throw new Exception(\r\n                    50100,\r\n                    \"Error in sending transaction: \" + e.message\r\n                );\r\n            }\r\n        }\r\n\r\n        elizaLogger.log(\"Completed Flow Plugin's SEND_COIN handler.\");\r\n\r\n        return resp;\r\n    }\r\n}\r\n\r\nexport const transferAction = {\r\n    name: \"SEND_COIN\",\r\n    similes: [\r\n        \"SEND_TOKEN\",\r\n        \"SEND_TOKEN_ON_FLOW\",\r\n        \"TRANSFER_TOKEN_ON_FLOW\",\r\n        \"TRANSFER_TOKENS_ON_FLOW\",\r\n        \"TRANSFER_FLOW\",\r\n        \"SEND_FLOW\",\r\n        \"PAY_BY_FLOW\",\r\n    ],\r\n    description:\r\n        \"Call this action to transfer any fungible token/coin from the agent's Flow wallet to another address\",\r\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\r\n        await validateFlowConfig(runtime);\r\n        const flowConnector = await getFlowConnectorInstance(runtime);\r\n        const walletProvider = new FlowWalletProvider(runtime, flowConnector);\r\n        try {\r\n            await walletProvider.syncAccountInfo();\r\n            // TODO: We need to check if the key index is valid\r\n        } catch {\r\n            elizaLogger.error(\"Failed to sync account info\");\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: { [key: string]: unknown },\r\n        callback?: HandlerCallback\r\n    ): Promise<boolean> => {\r\n        const flowConnector = await getFlowConnectorInstance(runtime);\r\n        const walletProvider = new FlowWalletProvider(runtime, flowConnector);\r\n        const action = new TransferAction(walletProvider);\r\n        let content: TransferContent;\r\n        try {\r\n            content = await action.processMessages(runtime, message, state);\r\n        } catch (err) {\r\n            elizaLogger.error(\"Error in processing messages:\", err.message);\r\n            if (callback) {\r\n                callback({\r\n                    text:\r\n                        \"Unable to process transfer request. Invalid content: \" +\r\n                        err.message,\r\n                    content: {\r\n                        error: \"Invalid content\",\r\n                    },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            const res = await action.transfer(content, callback);\r\n            elizaLogger.log(\r\n                `Transfer action response: ${res.signer.address}[${res.signer.keyIndex}] - ${res.txid}`\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Send 1 FLOW to 0xa2de93114bae3e73\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sending 1 FLOW tokens now, pls wait...\",\r\n                    action: \"SEND_COIN\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Send 1 FLOW - A.1654653399040a61.FlowToken to 0xa2de93114bae3e73\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sending 1 FLOW tokens now, pls wait...\",\r\n                    action: \"SEND_COIN\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Send 1000 FROTH - 0xb73bf8e6a4477a952e0338e6cc00cc0ce5ad04ba to 0x000000000000000000000002e44fbfbd00395de5\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sending 1000 FROTH tokens now, pls wait...\",\r\n                    action: \"SEND_COIN\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","export const transferTemplate = `Given the recent messages and wallet information below:\r\n\r\n{{recentMessages}}\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested transfer:\r\n- Field \"token\": Cadence Resource Identifier or ERC20 contract address (if not native token). this field should be null if the token is native token: $FLOW or FLOW. Examples for this field:\r\n    1. For Cadence resource identifier, the field should be \"A.1654653399040a61.ContractName\"\r\n    2. For ERC20 contract address, the field should be \"0xe6ffc15a5bde7dd33c127670ba2b9fcb82db971a\"\r\n- Field \"amount\": Amount to transfer, it should be a number or a string. Examples for this field:\r\n    1. \"1000\"\r\n    2. 1000\r\n- Field \"to\": Recipient wallet address, can be EVM address or Cadence address. Examples for this field:\r\n    1. Cadence address: \"0x1654653399040a61\"\r\n    2. EVM address: \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\"\r\n- Field \"matched\": Boolean value indicating if field \"token\" matches the field \"to\" or not. Here is the rules:\r\n    1. if field \"token\" is \"null\" or Cadence resource identifier, field \"to\" can be EVM address or Cadence address, so the value of \"matched\" should be true.\r\n    2. if field \"token\" is ERC20 contract address, field \"to\" should be EVM address, so the value of \"matched\" should be true, otherwise false.\r\n\r\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"token\": string | null\r\n    \"amount\": number | string | null,\r\n    \"to\": string | null,\r\n    \"matched\": boolean\r\n}\r\n\\`\\`\\`\r\n`;\r\n","// Definitions\r\nexport * from \"./environment\";\r\nexport * from \"./types\";\r\nexport * from \"./assets/script.defs\";\r\nexport * from \"./assets/transaction.defs\";\r\nexport * as queries from \"./queries\";\r\n// Providers\r\nexport * from \"./providers/connector.provider\";\r\nexport * from \"./providers/wallet.provider\";\r\n\r\nimport type { Plugin } from \"@elizaos/core\";\r\nimport { flowWalletProvider } from \"./providers/wallet.provider\";\r\nimport { flowConnectorProvider } from \"./providers/connector.provider\";\r\nimport { transferAction } from \"./actions/transfer\";\r\n\r\nexport const flowPlugin: Plugin = {\r\n    name: \"flow\",\r\n    description: \"Flow Plugin for Eliza\",\r\n    providers: [flowWalletProvider, flowConnectorProvider],\r\n    actions: [transferAction],\r\n    evaluators: [],\r\n    services: [],\r\n};\r\n\r\nexport default flowPlugin;\r\n"],"mappings":";;;;;;;AACA,SAAS,SAAS;AAElB,IAAM,0BAA0B;AAEzB,IAAM,gBAAgB,EAAE,OAAO;AAAA,EAClC,cAAc,EACT,OAAO,EACP,IAAI,GAAG,iCAAiC,EACxC,WAAW,MAAM,iCAAiC;AAAA,EACvD,kBAAkB,EACb,OAAO,EACP,IAAI,GAAG,8CAA8C,EACrD,WAAW,MAAM,qCAAqC;AAAA,EAC3D,cAAc,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,SAAS;AAAA,EACrD,mBAAmB,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,uBAAuB;AAC5E,CAAC;AAID,eAAsB,mBAClB,SACmB;AACnB,MAAI;AACA,UAAMA,UAAS;AAAA,MACX,cACI,QAAQ,WAAW,cAAc,KAAK,QAAQ,IAAI;AAAA,MACtD,kBACI,QAAQ,WAAW,kBAAkB,KACrC,QAAQ,IAAI;AAAA,MAChB,cACI,QAAQ,WAAW,cAAc,KACjC,QAAQ,IAAI,gBACZ;AAAA,MACJ,mBACI,QAAQ,WAAW,mBAAmB,KACtC,QAAQ,IAAI,qBACZ;AAAA,IACR;AAEA,WAAO,cAAc,MAAMA,OAAM;AAAA,EACrC,SAAS,OAAO;AACZ,QAAI,iBAAiB,EAAE,UAAU;AAC7B,YAAM,gBAAgB,MAAM,OACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,KAAK,GAAG,CAAC,KAAK,IAAI,OAAO,EAAE,EACpD,KAAK,IAAI;AACd,YAAM,IAAI;AAAA,QACN;AAAA,EAAqD,aAAa;AAAA,MACtE;AAAA,IACJ;AACA,UAAM;AAAA,EACV;AACJ;;;ACpDA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACcO,IAAM,UAAU;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;;;ACpBA,IAAAC,gBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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","names":["config","call_default","call_default","elizaLogger","fcl","elizaLogger","elizaLogger","elizaLogger"]}