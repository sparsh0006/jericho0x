{"version":3,"sources":["../src/index.ts","../src/providers/token.ts","../src/utils/bignumber.ts","../src/providers/trustScoreProvider.ts","../src/services/simulationService.ts","../src/constants.ts","../../../node_modules/uuid/dist/esm-node/rng.js","../../../node_modules/uuid/dist/esm-node/stringify.js","../../../node_modules/uuid/dist/esm-node/native.js","../../../node_modules/uuid/dist/esm-node/v4.js","../src/actions/analyzeTrade.ts","../src/actions.ts","../src/services/twitter.ts","../src/wallet.ts","../src/utils.ts","../src/config.ts"],"sourcesContent":["import type { Plugin, IAgentRuntime, Memory, State } from \"@elizaos/core\";\r\nimport { elizaLogger, settings } from \"@elizaos/core\";\r\nimport { z } from \"zod\";\r\nimport { TwitterClientInterface } from \"@elizaos/client-twitter\";\r\nimport {\r\n    solanaPlugin,\r\n    trustScoreProvider,\r\n    trustEvaluator,\r\n    getTokenBalance,\r\n} from \"@elizaos/plugin-solana\";\r\nimport { TokenProvider } from \"./providers/token\";\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\nimport type { Chain, WalletClient, Signature, Balance } from \"@goat-sdk/core\";\r\nimport * as fs from \"fs\";\r\nimport * as path from \"path\";\r\nimport { TrustScoreProvider } from \"./providers/trustScoreProvider\";\r\nimport { SimulationService } from \"./services/simulationService\";\r\nimport { SAFETY_LIMITS } from \"./constants\";\r\nimport NodeCache from \"node-cache\";\r\nimport { TrustScoreDatabase } from \"@elizaos/plugin-trustdb\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { actions } from \"./actions\";\r\nimport {\r\n    TradeAlert,\r\n    TradeBuyAlert,\r\n    tweetTrade,\r\n    TwitterConfigSchema,\r\n    TwitterService,\r\n} from \"./services/twitter\";\r\nimport {\r\n    executeTrade,\r\n    getChainWalletBalance,\r\n    getWalletBalance,\r\n    getWalletKeypair,\r\n} from \"./wallet\";\r\nimport { ProcessedTokenData } from \"./types\";\r\nimport { analyzeTradeAction } from \"./actions/analyzeTrade\";\r\n\r\n// Update Balance interface to include formatted\r\ninterface ExtendedBalance extends Balance {\r\n    formatted: string;\r\n}\r\n\r\n// Extended WalletProvider interface to ensure proper typing\r\ninterface ExtendedWalletProvider extends WalletClient {\r\n    connection: Connection;\r\n    signMessage(message: string): Promise<Signature>;\r\n    getFormattedPortfolio: (runtime: IAgentRuntime) => Promise<string>;\r\n    balanceOf: (tokenAddress: string) => Promise<ExtendedBalance>;\r\n    getMaxBuyAmount: (tokenAddress: string) => Promise<number>;\r\n    executeTrade: (params: {\r\n        tokenIn: string;\r\n        tokenOut: string;\r\n        amountIn: number;\r\n        slippage: number;\r\n    }) => Promise<any>;\r\n}\r\n\r\nconst REQUIRED_SETTINGS = {\r\n    WALLET_PUBLIC_KEY: \"Solana wallet public key\",\r\n    DEXSCREENER_WATCHLIST_ID: \"DexScreener watchlist ID\",\r\n    COINGECKO_API_KEY: \"CoinGecko API key\",\r\n} as const;\r\n\r\n// Add near the top imports\r\ninterface ExtendedPlugin extends Plugin {\r\n    name: string;\r\n    description: string;\r\n    evaluators: any[];\r\n    providers: any[];\r\n    actions: any[];\r\n    services: any[];\r\n    autoStart?: boolean;\r\n}\r\n\r\n// Add this helper function\r\nfunction validateSolanaAddress(address: string | undefined): boolean {\r\n    if (!address) return false;\r\n    try {\r\n        // Handle Solana addresses\r\n        if (!/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address)) {\r\n            elizaLogger.warn(`Solana address failed format check: ${address}`);\r\n            return false;\r\n        }\r\n\r\n        // Verify it's a valid Solana public key\r\n        const pubKey = new PublicKey(address);\r\n        const isValid = Boolean(pubKey.toBase58());\r\n        elizaLogger.log(\r\n            `Solana address validation result for ${address}: ${isValid}`\r\n        );\r\n        return isValid;\r\n    } catch (error) {\r\n        elizaLogger.error(`Address validation error for ${address}:`, error);\r\n        return false;\r\n    }\r\n}\r\n\r\n// Add function to load token addresses\r\nexport function loadTokenAddresses(): string[] {\r\n    try {\r\n        const filePath = path.resolve(\r\n            process.cwd(),\r\n            \"../characters/tokens/tokenaddresses.json\"\r\n        );\r\n        const data = fs.readFileSync(filePath, \"utf8\");\r\n        const addresses = JSON.parse(data);\r\n\r\n        // Validate addresses\r\n        const validAddresses = addresses.filter((addr: string) => {\r\n            // Solana address validation\r\n            return validateSolanaAddress(addr);\r\n        });\r\n\r\n        elizaLogger.log(\"Loaded token addresses:\", {\r\n            total: validAddresses.length,\r\n            solana: validAddresses.filter((addr) => !addr.startsWith(\"0x\"))\r\n                .length,\r\n            base: validAddresses.filter((addr) => addr.startsWith(\"0x\")).length,\r\n        });\r\n\r\n        return validAddresses;\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to load token addresses:\", error);\r\n        throw new Error(\"Token addresses file not found or invalid\");\r\n    }\r\n}\r\n\r\n// Add cache configuration after other interfaces\r\ninterface CacheEntry {\r\n    lastAnalysis: number;\r\n    tokenData: any;\r\n    trustScore: number;\r\n    analysisResult: any;\r\n}\r\n\r\n// Add cache instance before createGoatPlugin\r\nconst tokenCache = new NodeCache({\r\n    stdTTL: 1200, // 20 minutes in seconds\r\n    checkperiod: 120, // Check for expired entries every 2 minutes\r\n});\r\n\r\n// Add near the top with other interfaces\r\ninterface SkipWaitCache {\r\n    lastTweet: number;\r\n    action: \"WAIT\" | \"SKIP\";\r\n}\r\n\r\n// Add near other cache instances\r\nconst skipWaitCache = new NodeCache({\r\n    stdTTL: 7200, // 2 hours in seconds\r\n    checkperiod: 600, // Check for expired entries every 10 minutes\r\n});\r\n\r\n// Add near other interfaces\r\ninterface TweetRateLimit {\r\n    lastTweet: number;\r\n    count: number; // Track number of tweets in the time window\r\n}\r\n\r\n// Add near other cache instances\r\nconst tweetRateCache = new NodeCache({\r\n    stdTTL: 86400, // 24 hours in seconds\r\n    checkperiod: 3600, // Check every hour\r\n});\r\n\r\n// Add helper function\r\nfunction canTweet(tweetType: \"trade\" | \"market_search\"): boolean {\r\n    const now = Date.now();\r\n    const hourKey = `tweets_${tweetType}_${Math.floor(now / 3600000)}`; // Key by hour and type\r\n    const rateLimit: TweetRateLimit = tweetRateCache.get(hourKey) || {\r\n        lastTweet: now,\r\n        count: 0,\r\n    };\r\n\r\n    // Different limits for different tweet types\r\n    const MAX_TWEETS_PER_HOUR = {\r\n        trade: 10,\r\n        market_search: 10, // Lower limit for market search tweets\r\n    };\r\n\r\n    if (rateLimit.count >= MAX_TWEETS_PER_HOUR[tweetType]) {\r\n        elizaLogger.warn(\r\n            `Tweet rate limit reached for ${tweetType}: ${rateLimit.count} tweets this hour`\r\n        );\r\n        return false;\r\n    }\r\n\r\n    // Update rate limit\r\n    tweetRateCache.set(hourKey, {\r\n        lastTweet: now,\r\n        count: rateLimit.count + 1,\r\n    });\r\n\r\n    return true;\r\n}\r\n\r\n// Add new interfaces near the top with other interfaces\r\ninterface TradePerformance {\r\n    token_address: string;\r\n    recommender_id: string;\r\n    buy_price: number;\r\n    sell_price: number;\r\n    buy_timeStamp: string;\r\n    sell_timeStamp: string;\r\n    buy_amount: number;\r\n    sell_amount: number;\r\n    buy_value_usd: number;\r\n    sell_value_usd: number;\r\n    buy_market_cap: number;\r\n    sell_market_cap: number;\r\n    buy_liquidity: number;\r\n    sell_liquidity: number;\r\n    profit_usd: number;\r\n    profit_percent: number;\r\n    market_cap_change: number;\r\n    liquidity_change: number;\r\n    rapidDump: boolean;\r\n}\r\n\r\ninterface TradePosition {\r\n    token_address: string;\r\n    entry_price: number;\r\n    size: number;\r\n    stop_loss: number;\r\n    take_profit: number;\r\n    open_timeStamp: string;\r\n    close_timeStamp?: string;\r\n    status?: \"OPEN\" | \"CLOSED\";\r\n}\r\n\r\n// Update the analysisParams interface\r\ninterface AnalysisParams extends Record<string, any> {\r\n    walletBalance: number;\r\n    tokenAddress: string;\r\n    price: number;\r\n    volume: number;\r\n    marketCap: number;\r\n    liquidity: number;\r\n    holderDistribution: string;\r\n    trustScore: number;\r\n    dexscreener: any;\r\n    position?: TradePosition;\r\n    tradeHistory?: TradePerformance[];\r\n}\r\n\r\n// Update the interface to match the SQL parameter order\r\ninterface SellDetailsData {\r\n    // SET clause parameters in order\r\n    sell_price: number;\r\n    sell_timeStamp: string;\r\n    sell_amount: number;\r\n    received_sol: number;\r\n    sell_value_usd: number;\r\n    profit_usd: number;\r\n    profit_percent: number;\r\n    sell_market_cap: number;\r\n    market_cap_change: number;\r\n    sell_liquidity: number;\r\n    liquidity_change: number;\r\n    rapidDump: boolean;\r\n    sell_recommender_id: string | null;\r\n}\r\n\r\nasync function updateSellDetails(\r\n    runtime: IAgentRuntime,\r\n    tokenAddress: string,\r\n    recommenderId: string,\r\n    tradeAmount: number,\r\n    latestTrade: any,\r\n    tokenData: any\r\n) {\r\n    const trustScoreDb = new TrustScoreDatabase(runtime.databaseAdapter.db);\r\n\r\n    const trade = await trustScoreDb.getLatestTradePerformance(\r\n        tokenAddress,\r\n        recommenderId,\r\n        false\r\n    );\r\n\r\n    if (!trade) {\r\n        elizaLogger.error(\r\n            `No trade found for token ${tokenAddress} and recommender ${recommenderId}`\r\n        );\r\n        throw new Error(\"No trade found to update\");\r\n    }\r\n\r\n    const currentPrice = tokenData.dexScreenerData.pairs[0]?.priceUsd || 0;\r\n    const marketCap = tokenData.dexScreenerData.pairs[0]?.marketCap || 0;\r\n    const liquidity = tokenData.dexScreenerData.pairs[0]?.liquidity?.usd || 0;\r\n\r\n    const sellValueUsd = tradeAmount * Number(currentPrice);\r\n    const profitUsd = sellValueUsd - trade.buy_value_usd;\r\n    const profitPercent = (profitUsd / trade.buy_value_usd) * 100;\r\n\r\n    // Create sellDetailsData object matching SQL parameter order\r\n    const sellDetails: SellDetailsData = {\r\n        sell_price: Number(currentPrice),\r\n        sell_timeStamp: new Date().toISOString(),\r\n        sell_amount: tradeAmount,\r\n        received_sol: tradeAmount,\r\n        sell_value_usd: sellValueUsd,\r\n        profit_usd: profitUsd,\r\n        profit_percent: profitPercent,\r\n        sell_market_cap: marketCap,\r\n        market_cap_change: marketCap - trade.buy_market_cap,\r\n        sell_liquidity: liquidity,\r\n        liquidity_change: liquidity - trade.buy_liquidity,\r\n        rapidDump: false,\r\n        sell_recommender_id: recommenderId || null,\r\n    };\r\n\r\n    elizaLogger.log(\"Attempting to update trade performance with data:\", {\r\n        sellDetails,\r\n        whereClause: {\r\n            tokenAddress,\r\n            recommenderId,\r\n            buyTimeStamp: trade.buy_timeStamp,\r\n        },\r\n        isSimulation: false,\r\n    });\r\n\r\n    try {\r\n        try {\r\n            // Pass sellDetails first (SET clause), then WHERE clause parameters\r\n            elizaLogger.log(\r\n                \"Verifying parameters for updateTradePerformanceOnSell:\",\r\n                {\r\n                    sellDetails,\r\n                    tokenAddress,\r\n                    recommenderId,\r\n                    buyTimeStamp: trade.buy_timeStamp,\r\n                    isSimulation: false,\r\n                }\r\n            );\r\n\r\n            const success = await trustScoreDb.updateTradePerformanceOnSell(\r\n                tokenAddress, // 1. WHERE token_address = ?\r\n                recommenderId, // 2. WHERE recommender_id = ?\r\n                trade.buy_timeStamp, // 3. WHERE buy_timeStamp = ?\r\n                sellDetails, // 4. SET clause parameters\r\n                false // 5. isSimulation flag\r\n            );\r\n\r\n            if (!success) {\r\n                elizaLogger.warn(\"Trade update returned false\", {\r\n                    tokenAddress,\r\n                    recommenderId,\r\n                    buyTimeStamp: trade.buy_timeStamp,\r\n                });\r\n            }\r\n\r\n            elizaLogger.log(\"Trade performance update completed\", {\r\n                success,\r\n                tokenAddress,\r\n                recommenderId,\r\n                profitPercent: profitPercent.toFixed(2) + \"%\",\r\n                profitUsd: profitUsd.toFixed(4) + \" USD\",\r\n            });\r\n        } catch (dbError) {\r\n            elizaLogger.error(\"Database error during trade update:\", {\r\n                error: dbError,\r\n                query: {\r\n                    sellDetails,\r\n                    whereClause: {\r\n                        tokenAddress,\r\n                        recommenderId,\r\n                        buyTimeStamp: trade.buy_timeStamp,\r\n                    },\r\n                },\r\n            });\r\n            throw dbError;\r\n        }\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to update trade performance:\", {\r\n            error,\r\n            parameters: {\r\n                sellDetails,\r\n                whereClause: {\r\n                    tokenAddress,\r\n                    recommenderId,\r\n                    buyTimeStamp: trade.buy_timeStamp,\r\n                },\r\n                originalTrade: trade,\r\n            },\r\n            errorDetails:\r\n                error instanceof Error\r\n                    ? {\r\n                          message: error.message,\r\n                          stack: error.stack,\r\n                          name: error.name,\r\n                      }\r\n                    : error,\r\n        });\r\n        throw error;\r\n    }\r\n\r\n    return {\r\n        sellDetails,\r\n        currentPrice,\r\n        profitDetails: {\r\n            profitUsd,\r\n            profitPercent,\r\n            sellValueUsd,\r\n        },\r\n    };\r\n}\r\n\r\n// Update the module declaration to match the new parameter order\r\ndeclare module \"@elizaos/plugin-trustdb\" {\r\n    interface TrustScoreDatabase {\r\n        updateTradePerformanceOnSell(\r\n            tokenAddress: string, // Changed order: tokenAddress first\r\n            recommenderId: string, // recommenderId second\r\n            buyTimeStamp: string, // buyTimeStamp third\r\n            sellDetails: SellDetailsData, // sellDetails fourth\r\n            isSimulation: boolean // isSimulation fifth\r\n        ): boolean;\r\n    }\r\n}\r\n\r\nasync function getChainBalance(\r\n    connection: Connection,\r\n    walletAddress: PublicKey,\r\n    tokenAddress: string\r\n): Promise<number> {\r\n    // Use existing Solana balance fetching logic\r\n    return await getTokenBalance(\r\n        connection,\r\n        walletAddress,\r\n        new PublicKey(tokenAddress)\r\n    );\r\n}\r\n\r\nasync function createRabbiTraderPlugin(\r\n    getSetting: (key: string) => string | undefined,\r\n    runtime?: IAgentRuntime\r\n): Promise<Plugin> {\r\n    // Define resumeTrading at the start of the function\r\n    const resumeTrading = async () => {\r\n        // Load and analyze tokens\r\n        const tokenAddresses = loadTokenAddresses().filter(\r\n            (addr) => !addr.startsWith(\"0x\")\r\n        );\r\n        elizaLogger.log(`Analyzing ${tokenAddresses.length} Solana tokens...`);\r\n\r\n        // Analyze regular token list\r\n        for (const tokenAddress of tokenAddresses) {\r\n            await analyzeToken(\r\n                runtime,\r\n                connection,\r\n                twitterService,\r\n                tokenAddress\r\n            );\r\n        }\r\n\r\n        // Add delay between iterations\r\n        await new Promise((resolve) => setTimeout(resolve, 1200000)); // 20 minutes\r\n    };\r\n\r\n    elizaLogger.log(\"Starting GOAT plugin initialization\");\r\n\r\n    // Move connection initialization to the top\r\n    const connection = new Connection(\r\n        runtime?.getSetting(\"SOLANA_RPC_URL\") || \"https://api.mainnet-beta.solana.com\"\r\n    );\r\n\r\n    const keypair = getWalletKeypair(runtime);\r\n\r\n    // Validate required settings\r\n    const missingSettings: string[] = [];\r\n    for (const [key, description] of Object.entries(REQUIRED_SETTINGS)) {\r\n        if (!getSetting(key)) {\r\n            missingSettings.push(`${key} (${description})`);\r\n        }\r\n    }\r\n\r\n    if (missingSettings.length > 0) {\r\n        const errorMsg = `Missing required settings: ${missingSettings.join(\", \")}`;\r\n        elizaLogger.error(errorMsg);\r\n        throw new Error(errorMsg);\r\n    }\r\n\r\n    elizaLogger.log(\"Initializing Solana connection...\");\r\n    let walletProvider: ExtendedWalletProvider = {\r\n        connection,\r\n        getChain: () => ({ type: \"solana\" }),\r\n        getAddress: () => keypair.publicKey.toBase58(),\r\n        signMessage: async (message: string): Promise<Signature> => {\r\n            throw new Error(\r\n                \"Message signing not implemented for Solana wallet\"\r\n            );\r\n        },\r\n        balanceOf: async (tokenAddress: string): Promise<ExtendedBalance> => {\r\n            try {\r\n                if (tokenAddress.startsWith(\"0x\")) {\r\n                    // Handle Base token balance\r\n                    const baseBalance = await getChainBalance(\r\n                        connection,\r\n                        keypair.publicKey,\r\n                        tokenAddress\r\n                    );\r\n                    return {\r\n                        value: BigInt(baseBalance.toString()),\r\n                        decimals: 18, // Base uses 18 decimals\r\n                        formatted: (baseBalance / 1e18).toString(),\r\n                        symbol: \"ETH\",\r\n                        name: \"Base\",\r\n                    };\r\n                } else {\r\n                    // Existing Solana logic\r\n                    const tokenPublicKey = new PublicKey(tokenAddress);\r\n                    const amount = await getTokenBalance(\r\n                        connection,\r\n                        keypair.publicKey,\r\n                        tokenPublicKey\r\n                    );\r\n                    return {\r\n                        value: BigInt(amount.toString()),\r\n                        decimals: 9,\r\n                        formatted: (amount / 1e9).toString(),\r\n                        symbol: \"SOL\",\r\n                        name: \"Solana\",\r\n                    };\r\n                }\r\n            } catch (error) {\r\n                return {\r\n                    value: BigInt(0),\r\n                    decimals: tokenAddress.startsWith(\"0x\") ? 18 : 9,\r\n                    formatted: \"0\",\r\n                    symbol: tokenAddress.startsWith(\"0x\") ? \"ETH\" : \"SOL\",\r\n                    name: tokenAddress.startsWith(\"0x\") ? \"Base\" : \"Solana\",\r\n                };\r\n            }\r\n        },\r\n        getMaxBuyAmount: async (tokenAddress: string) => {\r\n            try {\r\n                if (tokenAddress.startsWith(\"0x\")) {\r\n                    // Handle Base chain balance\r\n                    const baseBalance = await getChainBalance(\r\n                        connection,\r\n                        keypair.publicKey,\r\n                        tokenAddress\r\n                    );\r\n                    return (baseBalance * 0.9) / 1e18; // Base uses 18 decimals\r\n                } else {\r\n                    // Handle Solana balance\r\n                    const balance = await connection.getBalance(\r\n                        keypair.publicKey\r\n                    );\r\n                    return (balance * 0.9) / 1e9; // Solana uses 9 decimals\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    `Failed to get max buy amount for ${tokenAddress}:`,\r\n                    error\r\n                );\r\n                return 0;\r\n            }\r\n        },\r\n        executeTrade: async (params) => {\r\n            try {\r\n                return { success: true };\r\n            } catch (error) {\r\n                throw error;\r\n            }\r\n        },\r\n        getFormattedPortfolio: async () => \"\",\r\n    };\r\n\r\n    elizaLogger.log(\r\n        \"Solana connection and wallet provider initialized successfully\"\r\n    );\r\n\r\n    // Initialize Twitter service if enabled\r\n    let twitterService: TwitterService | undefined;\r\n    try {\r\n        elizaLogger.log(\r\n            \"Configuring Twitter service for trade notifications...\"\r\n        );\r\n        const twitterConfig = TwitterConfigSchema.parse({\r\n            enabled: getSetting(\"TWITTER_ENABLED\") === \"true\",\r\n            username: getSetting(\"TWITTER_USERNAME\"),\r\n            dryRun: false,\r\n        });\r\n\r\n        if (twitterConfig.enabled && runtime) {\r\n            elizaLogger.log(\"Starting Twitter client initialization...\");\r\n            const twitterClient = await TwitterClientInterface.start(runtime);\r\n            twitterService = new TwitterService(twitterClient, twitterConfig);\r\n\r\n            // Add delay after initialization\r\n            await new Promise((resolve) => setTimeout(resolve, 5000));\r\n\r\n            elizaLogger.log(\"Twitter service initialized successfully\", {\r\n                username: twitterConfig.username,\r\n                dryRun: twitterConfig.dryRun,\r\n            });\r\n        }\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to initialize Twitter service:\", error);\r\n    }\r\n\r\n    elizaLogger.log(\"Initializing Solana plugin components...\");\r\n\r\n    try {\r\n        const customActions = actions;\r\n\r\n        // Then update the plugin creation\r\n        const plugin: ExtendedPlugin = {\r\n            name: \"[Rabbi Trader] Onchain Actions with Solana Integration\",\r\n            description: \"Autonomous trading integration with AI analysis\",\r\n            evaluators: [trustEvaluator, ...(solanaPlugin.evaluators || [])],\r\n            providers: [\r\n                walletProvider,\r\n                trustScoreProvider,\r\n                ...(solanaPlugin.providers || []),\r\n            ],\r\n            actions: [...customActions, ...(solanaPlugin.actions || [])],\r\n            services: [],\r\n            autoStart: true,\r\n        };\r\n\r\n        // Add auto-start trading analysis\r\n        if (!runtime) return;\r\n\r\n        elizaLogger.log(\"Starting autonomous trading system...\");\r\n        const analyzeTradeAction = plugin.actions.find(\r\n            (a) => a.name === \"ANALYZE_TRADE\"\r\n        );\r\n\r\n        if (!analyzeTradeAction) return;\r\n\r\n        const interval =\r\n            Number(runtime.getSetting(\"TRADING_INTERVAL\")) || 300000;\r\n\r\n        // Then start trading loop if enabled\r\n        if (!settings.ENABLE_TRADING) return;\r\n\r\n        elizaLogger.log(\"Initializing trading loop...\");\r\n        await resumeTrading();\r\n        setInterval(resumeTrading, interval);\r\n\r\n        elizaLogger.log(\"GOAT plugin initialization completed successfully\");\r\n        return plugin;\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to initialize plugin components:\", error);\r\n        throw new Error(\r\n            `Plugin initialization failed: ${error instanceof Error ? error.message : String(error)}`\r\n        );\r\n    }\r\n}\r\n\r\nasync function analyzeToken(\r\n    runtime: IAgentRuntime,\r\n    connection: Connection,\r\n    twitterService: TwitterService,\r\n    tokenAddress: string\r\n) {\r\n    try {\r\n        // Check cache first\r\n        const cachedData: CacheEntry | undefined = tokenCache.get(tokenAddress);\r\n        const now = Date.now();\r\n\r\n        // Skip if analyzed within last 20 minutes\r\n        if (cachedData && now - cachedData.lastAnalysis < 1200000) {\r\n            elizaLogger.log(\r\n                `Using cached data for ${tokenAddress}, last analyzed ${Math.floor((now - cachedData.lastAnalysis) / 1000)}s ago`\r\n            );\r\n            return;\r\n        }\r\n\r\n        elizaLogger.log(`Starting analysis for token: ${tokenAddress}`);\r\n\r\n        await new Promise((resolve) => setTimeout(resolve, 2000));\r\n\r\n        if (!validateSolanaAddress(tokenAddress)) {\r\n            elizaLogger.error(`Invalid token address format: ${tokenAddress}`);\r\n            return;\r\n        }\r\n\r\n        // Initialize TokenProvider directly with just the token address\r\n        const tokenProvider = new TokenProvider(tokenAddress);\r\n\r\n        // Get processed token data which includes DexScreener data\r\n        elizaLogger.log(`Fetching token data for ${tokenAddress}`);\r\n        const tokenData = await tokenProvider.getProcessedTokenData();\r\n        elizaLogger.log(`Token data fetched for ${tokenAddress}:`, tokenData);\r\n\r\n        // Get trust score and cache it\r\n        const trustProvider = new TrustScoreProvider();\r\n        const trustEvaluation = await trustProvider.evaluateToken(tokenAddress);\r\n        const { trustScore } = trustEvaluation;\r\n\r\n        // Cache the new data\r\n        const cacheEntry: CacheEntry = {\r\n            lastAnalysis: Date.now(),\r\n            tokenData,\r\n            trustScore,\r\n            analysisResult: null, // Will be updated after analysis\r\n        };\r\n        tokenCache.set(tokenAddress, cacheEntry);\r\n\r\n        const walletPublicKey = runtime.getSetting(\"WALLET_PUBLIC_KEY\");\r\n        if (!walletPublicKey) {\r\n            elizaLogger.error(\"No wallet public key configured\");\r\n            return;\r\n        }\r\n\r\n        const balance = await connection.getBalance(\r\n            new PublicKey(walletPublicKey)\r\n        );\r\n\r\n        const walletSolBalance = {\r\n            formatted: (balance / 1e9).toString(),\r\n        };\r\n\r\n        // Initialize trustScoreDb\r\n        const trustScoreDb = new TrustScoreDatabase(runtime.databaseAdapter.db);\r\n\r\n        // Before creating analysisParams, get the latest trade performance\r\n        const latestTrade = trustScoreDb.getLatestTradePerformance(\r\n            tokenAddress,\r\n            runtime.agentId,\r\n            false // not simulation\r\n        );\r\n\r\n        elizaLogger.log(`Latest trade for ${tokenAddress}:`, latestTrade);\r\n\r\n        // Before creating analysisParams, get the correct chain balance\r\n        const walletBalance = await getChainWalletBalance(\r\n            runtime,\r\n            tokenAddress\r\n        );\r\n\r\n        const pair = tokenData.dexScreenerData.pairs[0];\r\n        const analysisParams: AnalysisParams = {\r\n            walletBalance, // Now using the correct chain's balance\r\n            tokenAddress,\r\n            price: Number(pair?.priceUsd || 0),\r\n            volume: pair?.volume?.h24 || 0,\r\n            marketCap: pair?.marketCap || 0,\r\n            liquidity: pair?.liquidity?.usd || 0,\r\n            holderDistribution: tokenData.holderDistributionTrend,\r\n            trustScore: trustScore || 0,\r\n            dexscreener: tokenData.dexScreenerData,\r\n            position: latestTrade\r\n                ? {\r\n                      token_address: latestTrade.token_address,\r\n                      entry_price: latestTrade.buy_price,\r\n                      size: latestTrade.buy_amount,\r\n                      stop_loss: latestTrade.buy_price * 0.85, // 15% stop loss\r\n                      take_profit: latestTrade.buy_price * 1.3, // 30% take profit\r\n                      open_timeStamp: latestTrade.buy_timeStamp,\r\n                      status: latestTrade.sell_timeStamp ? \"CLOSED\" : \"OPEN\",\r\n                  }\r\n                : undefined,\r\n        };\r\n\r\n        // Create initial state first\r\n        const state: State = await runtime.composeState({\r\n            userId: runtime.agentId,\r\n            agentId: runtime.agentId,\r\n            roomId: runtime.agentId,\r\n            content: {\r\n                text: `Initialize state for ${tokenAddress}`,\r\n                type: \"analysis\",\r\n            },\r\n        });\r\n\r\n        // Then create analysis memory using state\r\n        const analysisMemory: Memory = {\r\n            userId: state.userId,\r\n            agentId: runtime.agentId,\r\n            roomId: state.roomId,\r\n            content: {\r\n                text: `Analyze trade for ${tokenAddress}`,\r\n                type: \"analysis\",\r\n            },\r\n        };\r\n\r\n        // Update analysis result in cache after completion\r\n        const analysisResult = await analyzeTradeAction.handler(\r\n            runtime,\r\n            analysisMemory,\r\n            state,\r\n            analysisParams,\r\n            async (response) => {\r\n                if (!response) {\r\n                    elizaLogger.error(\r\n                        `Empty response from analysis for ${tokenAddress}`\r\n                    );\r\n                    return [];\r\n                }\r\n\r\n                elizaLogger.log(\r\n                    `Analysis result for ${tokenAddress}:`,\r\n                    response\r\n                );\r\n                try {\r\n                    // Parse the JSON response from the analysis\r\n                    const result =\r\n                        typeof response.text === \"string\"\r\n                            ? JSON.parse(response.text)\r\n                            : response.text;\r\n\r\n                    if (!result) {\r\n                        elizaLogger.error(\r\n                            `Invalid analysis result for ${tokenAddress}`\r\n                        );\r\n\r\n                        return [];\r\n                    }\r\n\r\n                    if (\r\n                        result.shouldTrade &&\r\n                        result.recommendedAction === \"BUY\"\r\n                    ) {\r\n                        await buy({\r\n                            result,\r\n                            runtime,\r\n                            state,\r\n                            tokenAddress,\r\n                            tokenData,\r\n                            twitterService,\r\n                            trustScore,\r\n                        });\r\n                    } else if (result.recommendedAction === \"SELL\") {\r\n                        await sell({\r\n                            latestTrade,\r\n                            result,\r\n                            runtime,\r\n                            state,\r\n                            tokenAddress,\r\n                            tokenProvider,\r\n                            trustScoreDb,\r\n                            twitterService,\r\n                            trustScore,\r\n                        });\r\n                    } else {\r\n                        elizaLogger.log(\r\n                            `Trade not recommended for ${tokenAddress}:`,\r\n                            result\r\n                        );\r\n                    }\r\n                } catch (parseError) {}\r\n                return [];\r\n            }\r\n        );\r\n        cacheEntry.analysisResult = analysisResult;\r\n        tokenCache.set(tokenAddress, cacheEntry);\r\n    } catch (tokenError) {\r\n        elizaLogger.error(`Error processing token ${tokenAddress}:`, {\r\n            error: tokenError,\r\n            stack: tokenError instanceof Error ? tokenError.stack : undefined,\r\n        });\r\n        await new Promise((resolve) => setTimeout(resolve, 2000));\r\n    }\r\n}\r\n\r\nasync function buy({\r\n    runtime,\r\n    tokenAddress,\r\n    state,\r\n    tokenData,\r\n    result,\r\n    twitterService,\r\n    trustScore,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    tokenAddress: string;\r\n    state: State;\r\n    tokenData: ProcessedTokenData;\r\n    result: any;\r\n    twitterService: TwitterService;\r\n    trustScore: number;\r\n}) {\r\n    elizaLogger.log(`Trade recommended for ${tokenAddress}:`, result);\r\n\r\n    // Continue with simulation if analysis recommends trading\r\n    const simulationService = new SimulationService();\r\n    const simulation = await simulationService.simulateTrade(\r\n        tokenAddress,\r\n        result.suggestedAmount || SAFETY_LIMITS.MINIMUM_TRADE\r\n    );\r\n\r\n    if (simulation.recommendedAction === \"EXECUTE\") {\r\n        try {\r\n            // Check wallet balance before trade\r\n            const currentBalance = await getWalletBalance(runtime);\r\n\r\n            const tradeAmount = Math.min(\r\n                result.suggestedAmount || SAFETY_LIMITS.MINIMUM_TRADE,\r\n                currentBalance * 0.95 // Leave some SOL for fees\r\n            );\r\n\r\n            if (tradeAmount < SAFETY_LIMITS.MINIMUM_TRADE) {\r\n                elizaLogger.warn(\r\n                    `Insufficient balance for trade: ${currentBalance} SOL`\r\n                );\r\n            }\r\n\r\n            // Create trade memory object\r\n            const tradeMemory: Memory = {\r\n                userId: state.userId,\r\n                agentId: runtime.agentId,\r\n                roomId: state.roomId,\r\n                content: {\r\n                    text: `Execute trade for ${tokenAddress}`,\r\n                    tokenAddress,\r\n                    amount: SAFETY_LIMITS.MINIMUM_TRADE,\r\n                    action: \"BUY\",\r\n                    source: \"system\",\r\n                    type: \"trade\",\r\n                },\r\n            };\r\n\r\n            // Execute trade using our custom function\r\n            const tradeResult = await executeTrade(runtime, {\r\n                tokenAddress,\r\n                amount: tradeAmount,\r\n                slippage: tokenAddress.startsWith(\"0x\") ? 0.03 : 0.3, // 3% for Base, 30% for Solana\r\n                chain: tokenAddress.startsWith(\"0x\") ? \"base\" : \"solana\",\r\n            });\r\n\r\n            if (tradeResult.success) {\r\n                elizaLogger.log(\r\n                    `Trade executed successfully for ${tokenAddress}:`,\r\n                    {\r\n                        signature: tradeResult.signature,\r\n                        amount: tradeAmount,\r\n                        memory: tradeMemory,\r\n                    }\r\n                );\r\n\r\n                // Check rate limit before tweeting\r\n                if (twitterService && result.recommendedAction === \"BUY\") {\r\n                    await tweetTrade(twitterService, {\r\n                        token:\r\n                            tokenData.dexScreenerData.pairs[0]?.baseToken\r\n                                ?.symbol || tokenAddress,\r\n                        tokenAddress: tokenAddress,\r\n                        amount: tradeAmount,\r\n                        trustScore: Number(trustScore) || 0,\r\n                        riskLevel: result.riskLevel || \"MEDIUM\",\r\n                        marketData: {\r\n                            priceChange24h:\r\n                                tokenData.dexScreenerData.pairs[0]?.priceChange\r\n                                    ?.h24 || 0,\r\n                            volume24h:\r\n                                tokenData.dexScreenerData.pairs[0]?.volume\r\n                                    ?.h24 || 0,\r\n                            liquidity: {\r\n                                usd:\r\n                                    tokenData.dexScreenerData.pairs[0]\r\n                                        ?.liquidity?.usd || 0,\r\n                            },\r\n                        },\r\n                        timestamp: Date.now(),\r\n                        signature: tradeResult.signature,\r\n                        hash: tradeResult.hash,\r\n                        action: \"BUY\",\r\n                        price: Number(\r\n                            tokenData.dexScreenerData.pairs[0]?.priceUsd || 0\r\n                        ),\r\n                    });\r\n                } else {\r\n                    elizaLogger.log(\"Skipping tweet due to rate limit\");\r\n                }\r\n\r\n                // Record trade using TrustScoreDatabase methods\r\n                const trustScoreDb = new TrustScoreDatabase(\r\n                    runtime.databaseAdapter.db\r\n                );\r\n\r\n                try {\r\n                    // Remove the PublicKey validation for Base addresses\r\n                    elizaLogger.log(\r\n                        `Attempting to validate token address: ${tokenAddress}`\r\n                    );\r\n                    const formattedAddress = tokenAddress.startsWith(\"0x\")\r\n                        ? tokenAddress\r\n                        : new PublicKey(tokenAddress).toBase58(); // Only convert Solana addresses\r\n                    elizaLogger.log(\r\n                        `Token address validated successfully: ${formattedAddress}`\r\n                    );\r\n\r\n                    // Create a new recommender ID for this trade\r\n                    const uuid = uuidv4();\r\n                    const recommender =\r\n                        await trustScoreDb.getOrCreateRecommender({\r\n                            id: uuid,\r\n                            address: \"\",\r\n                            solanaPubkey:\r\n                                runtime.getSetting(\"WALLET_PUBLIC_KEY\") || \"\",\r\n                        });\r\n                    elizaLogger.log(`Created/retrieved recommender:`, {\r\n                        recommender,\r\n                        chainType: tokenAddress.startsWith(\"0x\")\r\n                            ? \"base\"\r\n                            : \"solana\",\r\n                    });\r\n\r\n                    // Prepare trade data\r\n                    const tradeData = {\r\n                        buy_amount: tradeAmount,\r\n                        is_simulation: false,\r\n                        token_address: new PublicKey(tokenAddress).toBase58(),\r\n                        buy_price:\r\n                            tokenData.dexScreenerData.pairs[0]?.priceUsd || 0,\r\n                        buy_timeStamp: new Date().toISOString(),\r\n                        buy_market_cap:\r\n                            tokenData.dexScreenerData.pairs[0]?.marketCap || 0,\r\n                        buy_liquidity:\r\n                            tokenData.dexScreenerData.pairs[0]?.liquidity\r\n                                ?.usd || 0,\r\n                        buy_value_usd:\r\n                            tradeAmount *\r\n                            Number(\r\n                                tokenData.dexScreenerData.pairs[0]?.priceUsd ||\r\n                                    0\r\n                            ),\r\n                    };\r\n                    elizaLogger.log(`Prepared trade data:`, tradeData);\r\n\r\n                    // Create trade record directly using trustScoreDb\r\n                    await trustScoreDb.addTradePerformance(\r\n                        {\r\n                            token_address: formattedAddress, // Use the properly formatted address\r\n                            recommender_id: recommender.id,\r\n                            buy_price: Number(tradeData.buy_price),\r\n                            buy_timeStamp: tradeData.buy_timeStamp,\r\n                            buy_amount: tradeData.buy_amount,\r\n                            buy_value_usd: tradeData.buy_value_usd,\r\n                            buy_market_cap: tradeData.buy_market_cap,\r\n                            buy_liquidity: tradeData.buy_liquidity,\r\n                            buy_sol: tradeAmount,\r\n                            last_updated: new Date().toISOString(),\r\n                            sell_price: 0,\r\n                            sell_timeStamp: \"\",\r\n                            sell_amount: 0,\r\n                            received_sol: 0,\r\n                            sell_value_usd: 0,\r\n                            sell_market_cap: 0,\r\n                            sell_liquidity: 0,\r\n                            profit_usd: 0,\r\n                            profit_percent: 0,\r\n                            market_cap_change: 0,\r\n                            liquidity_change: 0,\r\n                            rapidDump: false,\r\n                        },\r\n                        false\r\n                    );\r\n\r\n                    elizaLogger.log(\r\n                        `Successfully recorded trade performance for ${tokenAddress}`\r\n                    );\r\n                } catch (error) {\r\n                    elizaLogger.error(\"Failed to record trade performance:\", {\r\n                        error,\r\n                        tokenAddress,\r\n                        errorMessage:\r\n                            error instanceof Error\r\n                                ? error.message\r\n                                : String(error),\r\n                        stack: error instanceof Error ? error.stack : undefined,\r\n                        errorType: error?.constructor?.name,\r\n                    });\r\n                }\r\n            } else {\r\n                elizaLogger.error(\r\n                    `Trade execution failed for ${tokenAddress}:`,\r\n                    tradeResult.error\r\n                );\r\n            }\r\n        } catch (tradeError) {\r\n            elizaLogger.error(\r\n                `Error during trade execution for ${tokenAddress}:`,\r\n                {\r\n                    error: tradeError,\r\n                    stack:\r\n                        tradeError instanceof Error\r\n                            ? tradeError.stack\r\n                            : undefined,\r\n                }\r\n            );\r\n        }\r\n    } else {\r\n        elizaLogger.log(\r\n            `Simulation rejected trade for ${tokenAddress}:`,\r\n            simulation\r\n        );\r\n    }\r\n}\r\n\r\nasync function sell({\r\n    state,\r\n    runtime,\r\n    tokenAddress,\r\n    tokenProvider,\r\n    twitterService,\r\n    trustScoreDb,\r\n    latestTrade,\r\n    result,\r\n    trustScore,\r\n}: {\r\n    state: State;\r\n    runtime: IAgentRuntime;\r\n    tokenAddress: string;\r\n    tokenProvider: TokenProvider;\r\n    twitterService: TwitterService;\r\n    trustScoreDb: TrustScoreDatabase;\r\n    result: any;\r\n    latestTrade: TradePerformance;\r\n    trustScore: number;\r\n}) {\r\n    // Get the trade amount from the latest trade\r\n    const tradeAmount = Number(latestTrade?.buy_amount || 0);\r\n\r\n    // Create and save trade memory object for sell\r\n    const tradeMemory: Memory = {\r\n        userId: state.userId,\r\n        agentId: runtime.agentId,\r\n        roomId: state.roomId,\r\n        content: {\r\n            text: `Execute sell for ${tokenAddress}`,\r\n            tokenAddress,\r\n            amount: tradeAmount,\r\n            action: \"SELL\",\r\n            source: \"system\",\r\n            type: \"trade\",\r\n        },\r\n    };\r\n\r\n    // Execute sell trade\r\n    const tradeResult = await executeTrade(runtime, {\r\n        tokenAddress,\r\n        amount: tradeAmount,\r\n        slippage: 0.3, //  30% for Solana\r\n        chain: \"solana\",\r\n    });\r\n\r\n    if (tradeResult.success) {\r\n        elizaLogger.log(`Sell executed successfully for ${tokenAddress}:`, {\r\n            signature: tradeResult.signature,\r\n            amount: tradeAmount,\r\n        });\r\n\r\n        // Get token data first\r\n        const tokenData = await tokenProvider.getProcessedTokenData();\r\n\r\n        // Create recommender\r\n        const uuid = uuidv4();\r\n        const recommender = await trustScoreDb.getOrCreateRecommender({\r\n            id: uuid,\r\n            address: \"\", // Empty since we're only handling Solana\r\n            solanaPubkey: runtime.getSetting(\"WALLET_PUBLIC_KEY\") || \"\",\r\n        });\r\n\r\n        // Update sell details and get prices\r\n        const { sellDetails, currentPrice } = await updateSellDetails(\r\n            runtime,\r\n            tokenAddress,\r\n            recommender.id,\r\n            tradeAmount,\r\n            latestTrade,\r\n            tokenData\r\n        );\r\n\r\n        // Post tweet if enabled\r\n        if (twitterService) {\r\n            await tweetTrade(twitterService, {\r\n                token:\r\n                    tokenData.dexScreenerData.pairs[0]?.baseToken?.symbol ||\r\n                    tokenAddress,\r\n                tokenAddress: tokenAddress,\r\n                amount: tradeAmount,\r\n                trustScore: Number(trustScore) || 0,\r\n                riskLevel: result.riskLevel || \"MEDIUM\",\r\n                marketData: {\r\n                    priceChange24h:\r\n                        tokenData.dexScreenerData.pairs[0]?.priceChange?.h24 ||\r\n                        0,\r\n                    volume24h:\r\n                        tokenData.dexScreenerData.pairs[0]?.volume?.h24 || 0,\r\n                    liquidity: {\r\n                        usd:\r\n                            tokenData.dexScreenerData.pairs[0]?.liquidity\r\n                                ?.usd || 0,\r\n                    },\r\n                },\r\n                timestamp: Date.now(),\r\n                signature: tradeResult.signature,\r\n                hash: tradeResult.hash,\r\n                action: \"SELL\",\r\n                price: Number(currentPrice),\r\n                profitPercent: `${sellDetails.profit_percent.toFixed(2)}%`,\r\n                profitUsd: `${sellDetails.profit_usd.toFixed(4)} USD`,\r\n                reason: `P/L: ${sellDetails.profit_percent.toFixed(2)}%`,\r\n            });\r\n        }\r\n\r\n        elizaLogger.log(\r\n            `Successfully updated sell details for ${tokenAddress}`,\r\n            {\r\n                sellPrice: currentPrice,\r\n                sellAmount: tradeAmount,\r\n            }\r\n        );\r\n    } else {\r\n        elizaLogger.error(\r\n            `Sell execution failed for ${tokenAddress}:`,\r\n            tradeResult.error\r\n        );\r\n    }\r\n}\r\n\r\nexport default createRabbiTraderPlugin;\r\n","import { elizaLogger } from \"@elizaos/core\";\r\nimport NodeCache from \"node-cache\";\r\nimport { ProcessedTokenData, TokenSecurityData, TokenTradeData, DexScreenerPair } from \"../types/token\";\r\nimport { toBN } from \"../utils/bignumber\";\r\n\r\nexport class TokenProvider {\r\n    private cache: NodeCache;\r\n    private isBase: boolean;\r\n\r\n    constructor(private tokenAddress: string, options?: { isBase?: boolean }) {\r\n        this.cache = new NodeCache({ stdTTL: 300 });\r\n        this.isBase = options?.isBase || false;\r\n    }\r\n\r\n    async getProcessedTokenData(): Promise<ProcessedTokenData> {\r\n        const cacheKey = `processed_${this.tokenAddress}`;\r\n        const cached = this.cache.get<ProcessedTokenData>(cacheKey);\r\n        if (cached) return cached;\r\n\r\n        try {\r\n            // Fetch DexScreener data\r\n            const dexData = await this.fetchDexScreenerData();\r\n            const pair = dexData.pairs[0];\r\n\r\n            // Calculate security metrics\r\n            const security: TokenSecurityData = {\r\n                ownerBalance: toBN(pair.liquidity.base).toString(),\r\n                creatorBalance: '0',\r\n                ownerPercentage: 0,\r\n                creatorPercentage: 0,\r\n                top10HolderBalance: toBN(pair.liquidity.base).times(0.1).toString(),\r\n                top10HolderPercent: 10\r\n            };\r\n\r\n            // Calculate trade metrics\r\n            const tradeData: TokenTradeData = {\r\n                price: Number(pair.priceUsd),\r\n                priceChange24h: pair.priceChange.h24,\r\n                volume24h: pair.volume.h24,\r\n                volume24hUsd: toBN(pair.volume.h24).toString(),\r\n                uniqueWallets24h: pair.txns.h24.buys + pair.txns.h24.sells,\r\n                uniqueWallets24hChange: 0\r\n            };\r\n\r\n            // Analyze holder distribution\r\n            const holderDistributionTrend = this.analyzeHolderDistribution(tradeData);\r\n\r\n            const processedData: ProcessedTokenData = {\r\n                security,\r\n                tradeData,\r\n                dexScreenerData: { pairs: [pair] },\r\n                holderDistributionTrend,\r\n                highValueHolders: [],\r\n                recentTrades: pair.volume.h24 > 0,\r\n                highSupplyHoldersCount: 0,\r\n                tokenCodex: { isScam: false }\r\n            };\r\n\r\n            this.cache.set(cacheKey, processedData);\r\n            return processedData;\r\n        } catch (error) {\r\n            elizaLogger.error(`Failed to process token data: ${error}`);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private analyzeHolderDistribution(tradeData: TokenTradeData): string {\r\n        const buyRatio = tradeData.uniqueWallets24h > 0 ?\r\n            tradeData.uniqueWallets24hChange / tradeData.uniqueWallets24h : 0;\r\n\r\n        if (buyRatio > 0.1) return \"increasing\";\r\n        if (buyRatio < -0.1) return \"decreasing\";\r\n        return \"stable\";\r\n    }\r\n\r\n    async shouldTradeToken(): Promise<boolean> {\r\n        const data = await this.getProcessedTokenData();\r\n        const pair = data.dexScreenerData.pairs[0];\r\n\r\n        return (\r\n            pair.liquidity.usd > 50000 &&\r\n            pair.volume.h24 > 10000 &&\r\n            Math.abs(pair.priceChange.h24) < 30 &&\r\n            !data.tokenCodex?.isScam\r\n        );\r\n    }\r\n\r\n    private async fetchDexScreenerData(): Promise<{ pairs: DexScreenerPair[] }> {\r\n        const chainParam = this.isBase ? 'base' : 'solana';\r\n        const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${this.tokenAddress}?chainId=${chainParam}`);\r\n        const data = await response.json();\r\n        return data;\r\n    }\r\n}\r\n","import BigNumber from \"bignumber.js\";\r\n\r\n// Re-export BigNumber constructor\r\nexport const BN = BigNumber;\r\n\r\n// Helper function to create new BigNumber instances\r\nexport function toBN(value: string | number | BigNumber): BigNumber {\r\n    return new BigNumber(value);\r\n}\r\n\r\n","import { elizaLogger } from \"@elizaos/core\";\r\nimport { TokenProvider } from \"./token\";\r\nimport { ProcessedTokenData } from \"../types/token\";\r\n\r\nexport class TrustScoreProvider {\r\n    private tokenProviders: Map<string, TokenProvider> = new Map();\r\n\r\n    getTokenProvider(tokenAddress: string): TokenProvider {\r\n        if (!this.tokenProviders.has(tokenAddress)) {\r\n            this.tokenProviders.set(tokenAddress, new TokenProvider(tokenAddress));\r\n        }\r\n        return this.tokenProviders.get(tokenAddress)!;\r\n    }\r\n\r\n    async calculateTrustScore(tokenData: ProcessedTokenData): Promise<number> {\r\n        const pair = tokenData.dexScreenerData.pairs[0];\r\n        const {\r\n            liquidity,\r\n            volume,\r\n            marketCap\r\n        } = pair;\r\n\r\n        // Weight factors\r\n        const LIQUIDITY_WEIGHT = 0.4;\r\n        const VOLUME_WEIGHT = 0.4;\r\n        const MCAP_WEIGHT = 0.2;\r\n\r\n        // Calculate component scores\r\n        const liquidityScore = Math.min(liquidity.usd / 100000, 1) * LIQUIDITY_WEIGHT;\r\n        const volumeScore = Math.min(volume.h24 / 50000, 1) * VOLUME_WEIGHT;\r\n        const mcapScore = Math.min(marketCap / 1000000, 1) * MCAP_WEIGHT;\r\n\r\n        return liquidityScore + volumeScore + mcapScore;\r\n    }\r\n\r\n    async evaluateToken(tokenAddress: string): Promise<{\r\n        trustScore: number;\r\n        riskLevel: \"LOW\" | \"MEDIUM\" | \"HIGH\";\r\n        tradingAdvice: \"BUY\" | \"SELL\" | \"HOLD\";\r\n        reason: string;\r\n    }> {\r\n        try {\r\n            const provider = this.getTokenProvider(tokenAddress);\r\n            const tokenData = await provider.getProcessedTokenData();\r\n            const trustScore = await this.calculateTrustScore(tokenData);\r\n            const pair = tokenData.dexScreenerData.pairs[0];\r\n\r\n            // Risk assessment\r\n            const riskLevel = trustScore > 0.7 ? \"LOW\" :\r\n                            trustScore > 0.4 ? \"MEDIUM\" : \"HIGH\";\r\n\r\n            // Trading signals\r\n            let tradingAdvice: \"BUY\" | \"SELL\" | \"HOLD\" = \"HOLD\";\r\n            let reason = \"Market conditions stable\";\r\n\r\n            if (pair.priceChange.h24 > 5 && trustScore > 0.4) {\r\n                tradingAdvice = \"BUY\";\r\n                reason = \"Strong upward momentum with good trust score\";\r\n            } else if (pair.priceChange.h24 < -10 || trustScore < 0.3) {\r\n                tradingAdvice = \"SELL\";\r\n                reason = \"Deteriorating conditions or low trust score\";\r\n            }\r\n\r\n            return { trustScore, riskLevel, tradingAdvice, reason };\r\n        } catch (error) {\r\n            elizaLogger.error(`Trust evaluation failed: ${error}`);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","import { elizaLogger } from \"@elizaos/core\";\r\nimport { TokenProvider } from \"../providers/token\";\r\nimport { TrustScoreProvider } from \"../providers/trustScoreProvider\";\r\n\r\nexport class SimulationService {\r\n    private trustScoreProvider: TrustScoreProvider;\r\n\r\n    constructor() {\r\n        this.trustScoreProvider = new TrustScoreProvider();\r\n    }\r\n\r\n    async simulateTrade(\r\n        tokenAddress: string,\r\n        amount: number\r\n    ): Promise<{\r\n        expectedPrice: number;\r\n        priceImpact: number;\r\n        recommendedAction: \"EXECUTE\" | \"ABORT\";\r\n        reason: string;\r\n    }> {\r\n        try {\r\n            const evaluation =\r\n                await this.trustScoreProvider.evaluateToken(tokenAddress);\r\n            const tokenProvider = new TokenProvider(tokenAddress);\r\n            const tokenData = await tokenProvider.getProcessedTokenData();\r\n\r\n            // Get liquidity from DexScreener data\r\n            const liquidity =\r\n                tokenData.dexScreenerData.pairs[0]?.liquidity?.usd || 0;\r\n            const priceImpact = (amount / liquidity) * 100;\r\n\r\n            let recommendedAction: \"EXECUTE\" | \"ABORT\" = \"ABORT\";\r\n            let reason = \"Default safety check failed\";\r\n\r\n            if (evaluation.trustScore > 0.4 && priceImpact < 1) {\r\n                recommendedAction = \"EXECUTE\";\r\n                reason = \"Trade meets safety parameters\";\r\n            }\r\n\r\n            return {\r\n                expectedPrice: tokenData.tradeData.price,\r\n                priceImpact,\r\n                recommendedAction,\r\n                reason,\r\n            };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Trade simulation failed:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","export const SAFETY_LIMITS = {\r\n  MINIMUM_TRADE: 0.01, // Minimum 0.01 SOL per trade\r\n  MAX_POSITION_SIZE: 0.1, // Maximum 10% of token liquidity\r\n  MAX_SLIPPAGE: 0.05, // Maximum 5% slippage allowed\r\n  MIN_LIQUIDITY: 1000, // Minimum $1000 liquidity required\r\n  MIN_VOLUME: 2000, // Minimum $2000 24h volume required\r\n  MIN_TRUST_SCORE: 0.4, // Minimum trust score to trade\r\n  STOP_LOSS: 0.2, // 20% stop loss trigger\r\n  CHECK_INTERVAL: 5 * 60 * 1000, // Check every 5 minutes\r\n  TAKE_PROFIT: 0.12, // Take profit at 12% gain\r\n  TRAILING_STOP: 0.2, // 20% trailing stop from highest\r\n  PARTIAL_TAKE: 0.06, // Take 50% profit at 6% gain\r\n  REENTRY_DELAY: 60 * 60 * 1000, // Wait 1 hour before re-entering\r\n  MAX_ACTIVE_POSITIONS: 5, // Maximum concurrent positions\r\n  MIN_WALLET_BALANCE: 0.05, // Keep minimum 0.05 SOL in wallet\r\n};\r\n\r\nexport const ANALYSIS_HISTORY_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\r\n\r\nexport const MAX_TWEETS_PER_HOUR = {\r\n  trade: 10,\r\n  market_search: 5,\r\n};\r\n\r\nexport const MARKET_SEARCH_INTERVAL = 60 * 60 * 1000; // 1 hour in milliseconds\r\n","import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import crypto from 'crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import {\r\n    Action,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateText,\r\n    ModelClass,\r\n    parseJSONObjectFromText,\r\n} from \"@elizaos/core\";\r\n\r\nexport const analyzeTradeAction: Action = {\r\n    name: \"ANALYZE_TRADE\",\r\n    description: \"Analyze a token for trading opportunities\",\r\n    similes: [\r\n        \"ANALYZE\",\r\n        \"ANALYZE_TOKEN\",\r\n        \"TRADE\",\r\n        \"ANALYZE_TRADE\",\r\n        \"EVALUATE\",\r\n        \"ASSESS\",\r\n    ],\r\n    examples: [],\r\n    validate: async () => true,\r\n    handler: async (runtime, memory, state, params, callback) => {\r\n        try {\r\n            // composeState\r\n            if (!state) {\r\n                state = await runtime.composeState(memory);\r\n            } else state = await runtime.updateRecentMessageState(state);\r\n\r\n            const tokenData = {\r\n                walletBalance: params.walletBalance,\r\n                tokenAddress: params.tokenAddress,\r\n                price: params.price,\r\n                volume: params.volume,\r\n                marketCap: params.marketCap,\r\n                liquidity: params.liquidity,\r\n                holderDistribution: params.holderDistribution,\r\n                trustScore: params.trustScore,\r\n                dexscreener: params.dexscreener,\r\n                position: params.position,\r\n            };\r\n\r\n            // Direct prompt instead of template\r\n            const prompt = `Analyze the following token data and provide a trading recommendation.\r\nReturn the response as a JSON object with the following structure:\r\n{\r\n  \"recommendation\": \"BUY\" | \"SELL\" | \"HOLD\",\r\n  \"confidence\": number (0-100),\r\n  \"reasoning\": string,\r\n  \"risks\": string[],\r\n  \"opportunities\": string[]\r\n}\r\n\r\nToken Data:\r\n${JSON.stringify(tokenData, null, 2)}`;\r\n\r\n            // Generate analysis using direct prompt\r\n            const content = await generateText({\r\n                runtime,\r\n                context: prompt,\r\n                modelClass: ModelClass.LARGE,\r\n            });\r\n\r\n            if (!content) {\r\n                throw new Error(\"No analysis generated\");\r\n            }\r\n\r\n            elizaLogger.log(`Raw analysis response:`, content);\r\n\r\n            // Parse the response to get the recommended action\r\n            const recommendation = parseJSONObjectFromText(content);\r\n            elizaLogger.log(\r\n                `Parsed recommendation for ${params.tokenAddress}:`,\r\n                recommendation\r\n            );\r\n\r\n            // Send result through callback\r\n            if (callback) {\r\n                await callback({\r\n                    text: JSON.stringify(recommendation),\r\n                    type: \"analysis\",\r\n                });\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(`Analysis failed:`, {\r\n                error: error instanceof Error ? error.message : \"Unknown error\",\r\n                stack: error instanceof Error ? error.stack : undefined,\r\n            });\r\n            return false;\r\n        }\r\n    },\r\n};\r\n","import { analyzeTradeAction } from \"./actions/analyzeTrade\";\r\nexport const actions = [analyzeTradeAction];\r\n","import { z } from \"zod\";\r\nimport { elizaLogger } from \"@elizaos/core\";\r\nimport { MAX_TWEETS_PER_HOUR } from \"../constants\";\r\nimport { MarketData } from \"../types\";\r\n\r\nexport const TwitterConfigSchema = z.object({\r\n  enabled: z.boolean(),\r\n  username: z.string().min(1),\r\n  dryRun: z.boolean().optional().default(false),\r\n  apiKey: z.string().optional(),\r\n});\r\n\r\nexport interface TradeAlert {\r\n  token: string;\r\n  amount: number;\r\n  trustScore: number;\r\n  riskLevel: \"LOW\" | \"MEDIUM\" | \"HIGH\";\r\n  marketData: {\r\n    priceChange24h: number;\r\n    volume24h: number;\r\n    liquidity: {\r\n      usd: number;\r\n    };\r\n  };\r\n  timestamp: number;\r\n  signature?: string;\r\n  action?: \"BUY\" | \"SELL\" | \"WAIT\" | \"SKIP\";\r\n  reason?: string;\r\n  price?: number;\r\n  profitPercent?: string;\r\n  profitUsd?: string;\r\n}\r\n\r\nexport interface TradeBuyAlert {\r\n  token: string;\r\n  tokenAddress: string;\r\n  amount: number;\r\n  trustScore: number;\r\n  riskLevel: \"LOW\" | \"MEDIUM\" | \"HIGH\";\r\n  marketData: MarketData;\r\n  timestamp: number;\r\n  signature?: string;\r\n  hash?: string;\r\n  explorerUrl?: string;\r\n  action?: \"BUY\" | \"SELL\" | \"WAIT\" | \"SKIP\";\r\n  reason?: string;\r\n  price?: number;\r\n  profitPercent?: string;\r\n  profitUsd?: string;\r\n}\r\n\r\n// Set up trade notification function\r\nexport const tweetTrade = async (\r\n  twitterService: TwitterService,\r\n  alert: TradeBuyAlert,\r\n) => {\r\n  if (twitterService) {\r\n    await twitterService.postTradeAlert({\r\n      ...alert,\r\n      timestamp: Date.now(),\r\n    });\r\n  }\r\n};\r\n\r\nexport function canTweet(tweetType: \"trade\" | \"market_search\" | \"shabbat\" | \"holiday\"): boolean {\r\n  const now = Date.now();\r\n  const hourKey = `tweets_${tweetType}_${Math.floor(now / 3600000)}`;\r\n\r\n  // Simple in-memory rate limiting\r\n  const tweetCounts = new Map<string, number>();\r\n  const currentCount = tweetCounts.get(hourKey) || 0;\r\n\r\n  if (currentCount >= MAX_TWEETS_PER_HOUR[tweetType]) {\r\n    elizaLogger.warn(`Tweet rate limit reached for ${tweetType}`);\r\n    return false;\r\n  }\r\n\r\n  tweetCounts.set(hourKey, currentCount + 1);\r\n  return true;\r\n}\r\n\r\ninterface TweetOptions {\r\n  skipRateLimit?: boolean;\r\n  type?: 'trade' | 'market_search' | 'shabbat' | 'holiday';\r\n}\r\n\r\nexport class TwitterService {\r\n  private client: any;\r\n  private config: z.infer<typeof TwitterConfigSchema>;\r\n\r\n  // Add public getter for config\r\n  public getConfig() {\r\n    return this.config;\r\n  }\r\n\r\n  constructor(client: any, config: z.infer<typeof TwitterConfigSchema>) {\r\n    this.client = client;\r\n    this.config = config;\r\n  }\r\n\r\n  async postTradeAlert(alert: TradeBuyAlert): Promise<boolean> {\r\n    try {\r\n      const tweetContent = this.formatBuyAlert(alert);\r\n\r\n      if (this.config.dryRun) {\r\n        elizaLogger.log(\r\n          \"Dry run mode - would have posted tweet:\",\r\n          tweetContent,\r\n        );\r\n        return true;\r\n      }\r\n\r\n      if (!canTweet(\"trade\")) {\r\n        elizaLogger.warn(\"Trade tweet rate limit reached\");\r\n        return false;\r\n      }\r\n\r\n      // Use the correct client structure\r\n      await this.client.post.client.twitterClient.sendTweet(tweetContent);\r\n      elizaLogger.log(\"Successfully posted trade alert to Twitter:\", {\r\n        content: tweetContent,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      elizaLogger.error(\"Failed to post trade alert to Twitter:\", {\r\n        error: error instanceof Error ? error.message : String(error),\r\n        alert,\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private formatBuyAlert(alert: TradeBuyAlert): string {\r\n    const priceChangePrefix = alert.marketData.priceChange24h >= 0 ? \"+\" : \"\";\r\n    const trustScoreEmoji =\r\n      alert.trustScore >= 0.8 ? \"\" : alert.trustScore >= 0.5 ? \"\" : \"\";\r\n\r\n\r\n    // Don't include explorer URL if we don't have a valid signature/hash\r\n    const hasValidTxId = alert.hash || alert.signature;\r\n    const explorerUrl = hasValidTxId\r\n        ? `https://solscan.io/tx/${alert.signature}`\r\n      : null;\r\n\r\n    if (alert.action === \"SELL\") {\r\n      // Simplified SELL format\r\n      const actionEmoji =\r\n        Number(alert.profitPercent?.replace(\"%\", \"\")) >= 0\r\n          ? \" PROFIT SELL\"\r\n          : \" LOSS SELL\";\r\n\r\n      const lines = [\r\n        `${actionEmoji} | ${alert.token}`,\r\n        ` P/L: ${alert.profitPercent}`,\r\n        ` Risk: ${alert.riskLevel}`,\r\n        ` Price: $${alert.price?.toFixed(6)}`,\r\n        ` 24h: ${priceChangePrefix}${alert.marketData.priceChange24h.toFixed(1)}%`,\r\n        explorerUrl ? ` ${explorerUrl}` : null,\r\n        `$${alert.token}`,\r\n      ];\r\n\r\n      return lines.filter(Boolean).join(\"\\n\");\r\n    } else {\r\n      // Simplified BUY format\r\n      const lines = [\r\n        ` BUY | ${alert.token}`,\r\n        ` Trust: ${trustScoreEmoji} ${(alert.trustScore * 100).toFixed(0)}%`,\r\n        ` 24h: ${priceChangePrefix}${alert.marketData.priceChange24h.toFixed(1)}%`,\r\n        ` Risk: ${alert.riskLevel}`,\r\n        ` Price: $${alert.price?.toFixed(6)}`,\r\n        explorerUrl ? ` ${explorerUrl}` : null,\r\n        `$${alert.token}`,\r\n      ];\r\n\r\n      return lines.filter(Boolean).join(\"\\n\");\r\n    }\r\n  }\r\n}","import { elizaLogger, IAgentRuntime } from \"@elizaos/core\";\r\nimport { Connection, Keypair, VersionedTransaction } from \"@solana/web3.js\";\r\nimport { decodeBase58 } from \"./utils\";\r\nimport { SAFETY_LIMITS } from \"./constants\";\r\n\r\n/**\r\n * Gets wallet keypair from runtime settings\r\n * @param runtime Agent runtime environment\r\n * @returns Solana keypair for transactions\r\n * @throws Error if private key is missing or invalid\r\n */\r\nexport function getWalletKeypair(runtime?: IAgentRuntime): Keypair {\r\n    // Check chain type from token address or configuration\r\n\r\n    const privateKeyString = runtime?.getSetting(\"WALLET_PRIVATE_KEY\");\r\n    if (!privateKeyString) {\r\n        throw new Error(\"No wallet private key configured\");\r\n    }\r\n\r\n    try {\r\n        const privateKeyBytes = decodeBase58(privateKeyString);\r\n        return Keypair.fromSecretKey(privateKeyBytes);\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to create wallet keypair:\", error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets current SOL balance for wallet\r\n * @param runtime Agent runtime environment\r\n * @returns Balance in SOL\r\n */\r\nexport async function getWalletBalance(\r\n    runtime: IAgentRuntime\r\n): Promise<number> {\r\n    try {\r\n        // Existing Solana balance logic\r\n        const walletKeypair = getWalletKeypair(runtime);\r\n        const walletPubKey = walletKeypair.publicKey;\r\n        const connection = new Connection(\r\n            runtime.getSetting(\"SOLANA_RPC_URL\") ||\r\n                \"https://api.mainnet-beta.solana.com\"\r\n        );\r\n\r\n        const balance = await connection.getBalance(walletPubKey);\r\n        const solBalance = balance / 1e9;\r\n\r\n        elizaLogger.log(\"Fetched Solana wallet balance:\", {\r\n            address: walletPubKey.toBase58(),\r\n            lamports: balance,\r\n            sol: solBalance,\r\n        });\r\n\r\n        return solBalance;\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to get wallet balance:\", error);\r\n        return 0;\r\n    }\r\n}\r\n\r\n// Add helper function to get connection\r\nasync function getConnection(runtime: IAgentRuntime): Promise<Connection> {\r\n    return new Connection(\r\n        runtime.getSetting(\"SOLANA_RPC_URL\") || \"https://api.mainnet-beta.solana.com\"\r\n    );\r\n}\r\n\r\n// Add executeTrade function\r\nexport async function executeTrade(\r\n    runtime: IAgentRuntime,\r\n    params: {\r\n        tokenAddress: string;\r\n        amount: number;\r\n        slippage: number;\r\n        isSell?: boolean;\r\n        chain?: \"base\" | \"solana\";\r\n    },\r\n    retryCount = 0\r\n): Promise<any> {\r\n    // Existing Solana trade logic remains unchanged\r\n    try {\r\n        elizaLogger.log(\"Executing Solana trade with params:\", params);\r\n\r\n        const SOL_ADDRESS = \"So11111111111111111111111111111111111111112\";\r\n\r\n        if (!params.isSell && params.amount < SAFETY_LIMITS.MINIMUM_TRADE) {\r\n            elizaLogger.warn(\"Trade amount too small:\", {\r\n                amount: params.amount,\r\n                minimumRequired: SAFETY_LIMITS.MINIMUM_TRADE,\r\n            });\r\n            return {\r\n                success: false,\r\n                error: \"Trade amount too small\",\r\n                details: {\r\n                    amount: params.amount,\r\n                    minimumRequired: SAFETY_LIMITS.MINIMUM_TRADE,\r\n                },\r\n            };\r\n        }\r\n\r\n        const walletKeypair = getWalletKeypair(runtime);\r\n        const connection = await getConnection(runtime);\r\n\r\n        // Setup swap parameters\r\n        const inputTokenCA = params.isSell ? params.tokenAddress : SOL_ADDRESS;\r\n        const outputTokenCA = params.isSell ? SOL_ADDRESS : params.tokenAddress;\r\n        const swapAmount = Math.floor(params.amount * 1e9);\r\n\r\n        elizaLogger.log(\"Trade execution details:\", {\r\n            isSell: params.isSell,\r\n            inputToken: inputTokenCA,\r\n            outputToken: outputTokenCA,\r\n            amount: params.amount,\r\n            slippage: params.slippage,\r\n        });\r\n\r\n        // Get quote\r\n        const quoteResponse = await fetch(\r\n            `https://quote-api.jup.ag/v6/quote?inputMint=${inputTokenCA}&outputMint=${outputTokenCA}&amount=${swapAmount}&slippageBps=${Math.floor(params.slippage * 10000)}`\r\n        );\r\n\r\n        if (!quoteResponse.ok) {\r\n            const error = await quoteResponse.text();\r\n            elizaLogger.warn(\"Quote request failed:\", {\r\n                status: quoteResponse.status,\r\n                error,\r\n            });\r\n            return {\r\n                success: false,\r\n                error: \"Failed to get quote\",\r\n                details: { status: quoteResponse.status, error },\r\n            };\r\n        }\r\n\r\n        const quoteData = await quoteResponse.json();\r\n        if (!quoteData || quoteData.error) {\r\n            elizaLogger.warn(\"Invalid quote data:\", quoteData);\r\n            return {\r\n                success: false,\r\n                error: \"Invalid quote data\",\r\n                details: quoteData,\r\n            };\r\n        }\r\n\r\n        elizaLogger.log(\"Quote received:\", quoteData);\r\n\r\n        // Get swap transaction\r\n        const swapResponse = await fetch(\"https://quote-api.jup.ag/v6/swap\", {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({\r\n                quoteResponse: quoteData,\r\n                userPublicKey: walletKeypair.publicKey.toString(),\r\n                wrapAndUnwrapSol: true,\r\n                computeUnitPriceMicroLamports: 2000000,\r\n                dynamicComputeUnitLimit: true,\r\n            }),\r\n        });\r\n\r\n        const swapData = await swapResponse.json();\r\n        if (!swapData?.swapTransaction) {\r\n            throw new Error(\"No swap transaction returned\");\r\n        }\r\n\r\n        elizaLogger.log(\"Swap transaction received\");\r\n\r\n        // Deserialize transaction\r\n        const transactionBuf = Buffer.from(swapData.swapTransaction, \"base64\");\r\n        const tx = VersionedTransaction.deserialize(transactionBuf);\r\n\r\n        // Get fresh blockhash and sign transaction\r\n        const { blockhash, lastValidBlockHeight } =\r\n            await connection.getLatestBlockhash(\"finalized\");\r\n        tx.message.recentBlockhash = blockhash;\r\n        tx.sign([walletKeypair]);\r\n\r\n        // Send with confirmation using more lenient settings\r\n        const signature = await connection.sendTransaction(tx, {\r\n            skipPreflight: false,\r\n            maxRetries: 5,\r\n            preflightCommitment: \"processed\",\r\n        });\r\n\r\n        elizaLogger.log(\"Transaction sent:\", signature);\r\n\r\n        // Wait for confirmation with more lenient settings\r\n        const confirmation = await connection.confirmTransaction(\r\n            {\r\n                signature,\r\n                blockhash,\r\n                lastValidBlockHeight,\r\n            },\r\n            \"processed\"\r\n        ); // Use 'processed' instead of default 'finalized'\r\n\r\n        if (confirmation.value.err) {\r\n            throw new Error(`Transaction failed: ${confirmation.value.err}`);\r\n        }\r\n\r\n        // Add additional verification\r\n        const status = await connection.getSignatureStatus(signature);\r\n        if (status.value?.err) {\r\n            throw new Error(\r\n                `Transaction verification failed: ${status.value.err}`\r\n            );\r\n        }\r\n\r\n        elizaLogger.log(\"Solana trade executed successfully:\", {\r\n            signature,\r\n            explorer: `https://solscan.io/tx/${signature}`,\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            signature,\r\n            confirmation,\r\n            explorer: `https://solscan.io/tx/${signature}`,\r\n        };\r\n    } catch (error) {\r\n        // Handle blockhash errors with retry and longer timeout\r\n        if (\r\n            (error.message?.includes(\"Blockhash not found\") ||\r\n                error.message?.includes(\"block height exceeded\")) &&\r\n            retryCount < 3\r\n        ) {\r\n            elizaLogger.warn(\r\n                `Transaction error, retrying (${retryCount + 1}/3)...`\r\n            );\r\n            await new Promise((resolve) => setTimeout(resolve, 5000)); // Longer delay between retries\r\n            return executeTrade(runtime, params, retryCount + 1);\r\n        }\r\n\r\n        elizaLogger.error(\"Trade execution failed:\", {\r\n            error: error instanceof Error ? error.message : error,\r\n            stack: error instanceof Error ? error.stack : undefined,\r\n            params,\r\n            retryCount,\r\n        });\r\n\r\n        return {\r\n            success: false,\r\n            error: error.message || error,\r\n            params,\r\n            stack: error instanceof Error ? error.stack : undefined,\r\n        };\r\n    }\r\n}\r\n\r\nexport async function getChainWalletBalance(\r\n    runtime: IAgentRuntime,\r\n    tokenAddress: string\r\n): Promise<number> {\r\n    // Get Solana balance\r\n    return await getWalletBalance(runtime);\r\n}\r\n\r\n// Add this helper function at the top level\r\nexport async function simulateTransaction(\r\n    client: any,\r\n    tx: any\r\n): Promise<string> {\r\n    try {\r\n        const result = await client.call({\r\n            account: client.account,\r\n            to: tx.to,\r\n            data: tx.data,\r\n            value: tx.value,\r\n            gas: tx.gas,\r\n            gasPrice: tx.gasPrice,\r\n        });\r\n        return result;\r\n    } catch (error) {\r\n        return `Simulation failed: ${error.message}`;\r\n    }\r\n}\r\n","import { elizaLogger, IAgentRuntime, settings, State } from \"@elizaos/core\";\r\nimport { PublicKey } from \"@solana/web3.js\";\r\nimport { PROVIDER_CONFIG } from \"./config\";\r\nimport { ANALYSIS_HISTORY_EXPIRY } from \"./constants\";\r\n\r\nexport function isValidSolanaAddress(address: string): boolean {\r\n    try {\r\n        // Check if it's a valid Solana public key format\r\n        new PublicKey(address);\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport async function fetchWithRetry(\r\n    url: string,\r\n    options: RequestInit = {},\r\n    chain: \"solana\" | \"base\" = \"solana\"\r\n): Promise<any> {\r\n    let lastError: Error;\r\n\r\n    for (let i = 0; i < PROVIDER_CONFIG.MAX_RETRIES; i++) {\r\n        try {\r\n            elizaLogger.log(`Attempt ${i + 1} for ${url} with chain ${chain}`);\r\n\r\n            // Ensure headers are properly initialized\r\n            const headers = {\r\n                Accept: \"application/json\",\r\n                \"x-chain\": chain,\r\n                \"X-API-KEY\": settings.BIRDEYE_API_KEY || \"\",\r\n                ...options.headers,\r\n            };\r\n\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                headers,\r\n            });\r\n\r\n            const responseText = await response.text();\r\n\r\n            if (!response.ok) {\r\n                throw new Error(\r\n                    `HTTP error! status: ${response.status}, message: ${responseText}`\r\n                );\r\n            }\r\n\r\n            try {\r\n                return JSON.parse(responseText);\r\n            } catch (parseError) {\r\n                throw new Error(\r\n                    `Failed to parse response: ${responseText}, error: ${parseError.message}`\r\n                );\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(`Attempt ${i + 1} failed:`, {\r\n                error: error instanceof Error ? error.message : String(error),\r\n                url,\r\n                chain,\r\n                attempt: i + 1,\r\n            });\r\n            lastError =\r\n                error instanceof Error ? error : new Error(String(error));\r\n\r\n            if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {\r\n                await new Promise((resolve) =>\r\n                    setTimeout(\r\n                        resolve,\r\n                        PROVIDER_CONFIG.RETRY_DELAY * Math.pow(2, i)\r\n                    )\r\n                );\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    throw lastError;\r\n}\r\n\r\nexport function decodeBase58(str: string): Uint8Array {\r\n    const ALPHABET =\r\n        \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\r\n    const ALPHABET_MAP = new Map(\r\n        ALPHABET.split(\"\").map((c, i) => [c, BigInt(i)])\r\n    );\r\n\r\n    let result = BigInt(0);\r\n    for (const char of str) {\r\n        const value = ALPHABET_MAP.get(char);\r\n        if (value === undefined) throw new Error(\"Invalid base58 character\");\r\n        result = result * BigInt(58) + value;\r\n    }\r\n\r\n    const bytes = [];\r\n    while (result > 0n) {\r\n        bytes.unshift(Number(result & 0xffn));\r\n        result = result >> 8n;\r\n    }\r\n\r\n    for (let i = 0; i < str.length && str[i] === \"1\"; i++) {\r\n        bytes.unshift(0);\r\n    }\r\n\r\n    return new Uint8Array(bytes);\r\n}\r\n\r\ninterface AnalyzedToken {\r\n    address: string;\r\n    timestamp: number;\r\n    symbol: string;\r\n}\r\n\r\nexport async function manageAnalyzedTokens(\r\n    runtime: IAgentRuntime,\r\n    state: any,\r\n    newToken?: AnalyzedToken\r\n): Promise<AnalyzedToken[]> {\r\n    try {\r\n        const historyKey = \"analyzed_tokens_history\";\r\n        let history: AnalyzedToken[] = [];\r\n\r\n        if (!state) {\r\n            state = {};\r\n        }\r\n\r\n        if (state[historyKey]) {\r\n            try {\r\n                const parsed = JSON.parse(state[historyKey]);\r\n                if (Array.isArray(parsed)) {\r\n                    history = parsed;\r\n                }\r\n            } catch (e) {\r\n                elizaLogger.warn(\"Failed to parse history, resetting\", e);\r\n            }\r\n        }\r\n\r\n        const now = Date.now();\r\n        history = history.filter(\r\n            (token) =>\r\n                token &&\r\n                token.timestamp &&\r\n                now - token.timestamp < ANALYSIS_HISTORY_EXPIRY\r\n        );\r\n\r\n        if (newToken) {\r\n            history.push(newToken);\r\n        }\r\n\r\n        // Update state with roomId\r\n        state = await runtime.updateRecentMessageState({\r\n            ...state,\r\n            userId: runtime.agentId,\r\n            agentId: runtime.agentId,\r\n            roomId: runtime.agentId,\r\n            content: {\r\n                ...state.content,\r\n                [historyKey]: JSON.stringify(history),\r\n            },\r\n        } as State);\r\n\r\n        return history;\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to manage analyzed tokens history:\", {\r\n            error: error instanceof Error ? error.message : error,\r\n        });\r\n        return [];\r\n    }\r\n}\r\n","export const PROVIDER_CONFIG = {\r\n  BIRDEYE_API: \"https://public-api.birdeye.so\",\r\n  TOKEN_SECURITY_ENDPOINT: \"/defi/token_security?address=\",\r\n  TOKEN_METADATA_ENDPOINT: \"/defi/v3/token/meta-data/single?address=\",\r\n  MARKET_SEARCH_ENDPOINT: \"/defi/v3/token/trade-data/single?address=\",\r\n  TOKEN_PRICE_CHANGE_ENDPOINT:\r\n    \"/defi/v3/search?chain=solana&target=token&sort_by=price_change_24h_percent&sort_type=desc&verify_token=true&markets=Raydium&limit=20\",\r\n  TOKEN_VOLUME_24_CHANGE_ENDPOINT:\r\n    \"/defi/v3/search?chain=solana&target=token&sort_by=volume_24h_change_percent&sort_type=desc&verify_token=true&markets=Raydium&limit=20\",\r\n  TOKEN_BUY_24_CHANGE_ENDPOINT:\r\n    \"/defi/v3/search?chain=solana&target=token&sort_by=buy_24h_change_percent&sort_type=desc&verify_token=true&markets=Raydium&offset=0&limit=20\",\r\n\r\n  TOKEN_SECURITY_ENDPOINT_BASE: \"/defi/token_security?address=\",\r\n  TOKEN_METADATA_ENDPOINT_BASE: \"/defi/v3/token/meta-data/single?address=\",\r\n  MARKET_SEARCH_ENDPOINT_BASE: \"/defi/v3/token/trade-data/single?address=\",\r\n  TOKEN_PRICE_CHANGE_ENDPOINT_BASE:\r\n    \"/defi/v3/search?chain=base&target=token&sort_by=price_change_24h_percent&sort_type=desc&offset=0&limit=20\",\r\n  TOKEN_VOLUME_24_ENDPOINT_BASE:\r\n    \"/defi/v3/search?chain=base&target=token&sort_by=volume_24h_usd&sort_type=desc&offset=2&limit=20\",\r\n  TOKEN_BUY_24_ENDPOINT_BASE:\r\n    \"/defi/v3/search?chain=base&target=token&sort_by=buy_24h&sort_type=desc&offset=2&limit=20\",\r\n\r\n  MAX_RETRIES: 3,\r\n  RETRY_DELAY: 2000,\r\n};\r\n\r\n// Add configuration for enabled chains\r\nexport const CHAIN_CONFIG = {\r\n  SOLANA_ENABLED: false, // Can be controlled via settings\r\n  BASE_ENABLED: true, // Can be controlled via settings\r\n};\r\n\r\n// Add Base chain configuration near other export constants\r\nexport const BASE_CONFIG = {\r\n  RPC_URL: process.env.EVM_PROVIDER_URL || \"https://mainnet.base.org\",\r\n  ROUTER_ADDRESS: \"0x327Df1E6de05895d2ab08513aaDD9313Fe505d86\", // Base Uniswap V2 Router\r\n  WETH_ADDRESS: \"0x4200000000000000000000000000000000000006\", // Base WETH\r\n  CHAIN_ID: 8453,\r\n  // Add Aerodrome-specific addresses\r\n  AERODROME: {\r\n    WETH: \"0x4200000000000000000000000000000000000006\",\r\n    USDC: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\r\n    USDT: \"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb\",\r\n  },\r\n};\r\n\r\n// Add 0x API configuration near other export constants\r\nexport const ZEROEX_CONFIG = {\r\n  API_URL: \"https://api.0x.org\",\r\n  API_KEY: process.env.ZEROEX_API_KEY || \"\",\r\n  QUOTE_ENDPOINT: \"/swap/permit2/quote\",\r\n  PRICE_ENDPOINT: \"/swap/permit2/price\",\r\n  SUPPORTED_CHAINS: {\r\n    BASE: 8453,\r\n  },\r\n  HEADERS: {\r\n    \"Content-Type\": \"application/json\",\r\n    \"0x-api-key\": process.env.ZEROEX_API_KEY || \"\",\r\n    \"0x-version\": \"v2\",\r\n  },\r\n};\r\n"],"mappings":"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","names":["elizaLogger","settings","Connection","PublicKey","elizaLogger","elizaLogger","elizaLogger","elizaLogger","NodeCache","crypto","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","resolve","elizaLogger","PublicKey","NodeCache","elizaLogger","PublicKey","resolve","Connection","analyzeTradeAction","settings"]}